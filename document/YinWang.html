<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272187; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="829"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_790286" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">丘奇和图灵</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠    </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">丘奇和图灵</p><p style="margin:0px 0px 20px;padding:0px;">丘奇（Alonzo Church）和图灵（Alan Turing）是两位对计算机科学具有最大影响力的人物，然而他们却具有非常对立的观点和相差很多的名气。在我长达16年的计算机科学生涯中，总是感觉到自己的思想反反复复的徘徊于这两个“阵营”之间。丘奇代表了“逻辑”和“语言”，而图灵代表着“物理”和“机器”。在前面的8年中，我对丘奇一无所知，而在后面的8年中，我却很少再听到图灵的名字。他们的观点谁对谁错，是一个无法回答的问题。完全投靠丘奇，或者完全投靠图灵，貌似都是错误的做法。这是一种非常难说清楚的，矛盾的感觉，但是今天我试图把自己的感悟简要的介绍一下。</p>
丘奇与图灵之争
<p style="margin:0px 0px 20px;padding:0px;">想必世界上所有的计算机学生都知道图灵的大名和事迹，因为美国计算机器学会（ACM）每年都会颁发“图灵奖”，它被誉为计算机科学的最高荣誉。大部分的计算机学生都会在某门课程（比如“计算理论”）学习“图灵机”的原理。然而，有多少人知道丘奇是什么人，他做出了什么贡献，他与图灵是什么样的关系呢？我想恐怕不到一半的人吧。</p><p style="margin:0px 0px 20px;padding:0px;">如果你查一下<a href="http://www.genealogy.math.ndsu.nodak.edu/id.php?id=8014" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">数学家谱图</a>，就会发现丘奇其实是图灵的博士导师。然而从 Andrew Hodges 所著的《<a href="http://www.turing.org.uk/bio/part3.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">图灵传</a>》，你却可以看到图灵的心目中仿佛并没有这个导师，仿佛自己的“全新发明”应得的名气，被丘奇抢走了一样（注意作者的用词：robbed）。事实到底是怎样的，恐怕谁也说不清楚。我只能说，貌似计算机科学从诞生之日开始就充满了各种“宗教斗争”。</p><p style="margin:0px 0px 20px;padding:0px;">虽然现在图灵更加有名，然而在现实的程序设计中，却是丘奇的理论在起着绝大部分的作用。据我的经验，丘奇的理论让很多事情变得简单，而图灵的机器却过度的复杂。丘奇所发明的 lambda calculus 以及后续的工作，是几乎一切程序语言的理论基础。而根据老一辈的计算机工程师们的描述，最早的计算机构架也没有受到图灵的启发，那是一些电机工程师完全独立的工作。然而有趣的是，继承了丘奇衣钵的计算机科学家们拿到的那个大奖，仍然被叫做“图灵奖”。我粗略的算了一下，在迄今所有的图灵奖之中，程序语言的研究者占了近三分之一。</p>
从图灵机到 lambda calculus
<p style="margin:0px 0px 20px;padding:0px;">图灵机永远的停留在了理论的领域，绝大多数被用在“计算理论”（Theory of Computation）中。计算理论其实包括两个主要概念：“可计算性理论”（computability）和“复杂度理论”(complexity）。这两个概念在通常的计算理论书籍（比如 Sipser 的经典教材）里，都是用图灵机来叙述的。在学习计算理论的时候，绝大多数的计算机学生恐怕都会为图灵机头痛好一阵子。</p><p style="margin:0px 0px 20px;padding:0px;">然而在做了研究生“计算理论”课程一个学期的 TA 之后我却发现，其实几乎所有计算理论的原理，都可以用 lambda calculus，或者程序语言和解释器的原理来描述。所谓“通用图灵机”（Universal Turing Machine），其实就是一个可以解释自己的解释器，叫做“元解释器”（meta-circular interpreter）。在 Dan Friedman 的 B621 程序语言理论课程中，我最后的项目就是一个 <a href="https://github.com/yinwang0/old-toys/blob/master/meta-interp.ss" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">meta-circular interpreter</a>。这个解释器能够完全的解释它自己，而且可以任意的嵌套（也就是说用它自己来解释它自己，再来解释它自己……）。然而我的“元解释器”却是基于 lambda calculus 的，所以我后来发现了一种方法，可以完全的用 lambda calculus 来解释计算理论里面几乎所有的定理。</p><p style="margin:0px 0px 20px;padding:0px;">我为这个发现写了两篇博文：《<a href="http://yinwang0.wordpress.com/2012/03/22/reducibility" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">A Reformulation of Reducibility</a>》和《<a href="http://yinwang0.wordpress.com/2012/10/25/halting" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Undecidability Proof of Halting Problem without Diagonalization</a>》。我把 Sipser 的<a href="http://www.amazon.com/dp/113318779X" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">计算理论课本</a>里面的几乎整个一章的证明都用我自己的这种方式改写了一遍，然后讲给上课的学生。因为这种表示方法比起通常的“图灵机+自然语言”的方式简单和精确，所以收到了相当好的效果，好些学生对我说有一种恍然大悟的感觉。</p><p style="margin:0px 0px 20px;padding:0px;">我把这一发现告诉了我当时的导师 Amr Sabry。他笑了，说这个他早就知道了。他推荐我去看一本书，叫做《<a href="http://www.diku.dk/~neil/Comp2book.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Computability and Complexity from a Programming Perspective</a>》，作者是大名鼎鼎的 Neil Jones (他也是“<a href="http://www.itu.dk/~sestoft/pebook/pebook.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Partial Evaluation</a>”这一重要概念的提出者）。这本书不是用图灵机，而是一种近似于 Pascal，却又带有 lambda calculus 的一些特征的语言（叫做 “WHILE 语言”）来描述计算理论。用这种语言，Jones 不但轻松的证明了所有经典的计算理论定理，而且能够证明一些使用图灵机不能证明的定理。</p><p style="margin:0px 0px 20px;padding:0px;">我曾经一直不明白，为什么可以如此简单的解释清楚的事情，计算理论需要使用图灵机，而且叙述也非常的繁复和含糊。由于这些证明都出于资深的计算理论家们之手，让我不得不怀疑自己的想法里面是不是缺了点什么。可是在看到了 Jones 教授的这本书之后，我倍感欣慰。原来一切本来就是这么的简单！</p><p style="margin:0px 0px 20px;padding:0px;">后来从 CMU 的教授 Robert Harper 的一篇博文《<a href="http://existentialtype.wordpress.com/2011/03/16/languages-and-machines" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Languages and Machines</a>》中，我也发现 Harper 跟我具有类似的观点，甚至更加极端一些。他强烈的支持使用 lambda calculus，反对图灵机和其他一切机器作为计算理论的基础。这也难怪，因为 Harper 跟丘奇是“直系”的<a href="http://www.genealogy.math.ndsu.nodak.edu/id.php?id=50068" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">学术血统关系</a>：Alonzo Church -&gt; Stephen Kleene -&gt; Robert Constable -&gt; Robert Harper。其中 Stephen Kleene 是图灵的师兄，也是一个超级聪明的人。</p>
从 lambda calculus 到电子线路
<p style="margin:0px 0px 20px;padding:0px;">当我在 2012 年的 POPL 第一次见到 Neil Jones 的时候，他和蔼的跟我解释了许许多多的问题。当我问到他这本书的时候，他对我说：“我不推荐我的书给你，因为大部分的人都觉得 lambda calculus 难以理解。”Lambda calculus 难以理解？我怎么不觉得呢？我觉得图灵机麻烦多了。然后我才发现，由于经过了这么多年的研究之后，自己对 lambda calculus 的理解程度已经到了深入骨髓的地步，所以我已经全然不知新手对它是什么样的感觉。原来“简单”这个词，在具有不同经历的人头脑里，有着完全不同的含义。</p><p style="margin:0px 0px 20px;padding:0px;">所以其实 Jones 教授说的没错，lambda calculus 也许对于大部分人来说不合适，因为对于它没有一个好的入门指南。Lambda calculus 出自逻辑学家之手，而逻辑学家们最在行的，就是把很简单的“程序”用天书一样的公式表示出来。这难怪老一辈的逻辑学家们，因为他们创造那些概念的时候，计算机还不存在。但是如果现在还用那一堆符号，恐怕就有点落伍了。大部分人在看到 beta-reduction, alpha-conversion, eta-conversion, ... 这大堆的公式的时候，就已经头痛难忍了，怎么还有可能利用它来理解计算理论呢？</p><p style="margin:0px 0px 20px;padding:0px;">其实那一堆符号所表示的东西，终究超越不了现实里的物体和变化，最多不过再幻想一下“多种未来”或者“时间机器”。有了计算机之后，这些符号公式，其实都可以用数据结构和程序语言来表示。所以 lambda calculus 在我的头脑里真的很简单。每一个 lambda 其实就像是一个电路模块。它从电线端子得到输入，然后输出一个结果。你把那些电线叫什么名字根本不重要，重要的是同一根电线的名字必须“一致”，这就是所谓的“alpha-conversion”的原理…… 不在这里多说了，如果你想深入的了解我心目中的 lambda calculus，也许可以看看我的另一篇博文《<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">怎样写一个解释器</a>》，看看这个关于类型推导的<a href="http://www.tudou.com/programs/view/GU9GtDuWSMk" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">幻灯片</a>的开头，或者进一步，看看如何推导出 <a href="http://yinwang0.wordpress.com/2012/04/09/reinvent-y" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Y combinator</a>，或者看看《<a href="http://yinwang0.wordpress.com/2012/09/16/what-is-a-program" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">What is a program?</a>》。你也可以看看 Matthias Felleisen 和 Matthew Flatt 的《<a href="http://www.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/notes.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Programming Languages and Lambda Calculi</a>》。</p><p style="margin:0px 0px 20px;padding:0px;">所以，也许你看到了在我的头脑里面并存着丘奇和图灵的影子。我觉得丘奇的 lambda calculus 是比图灵机简单而强大的描述工具，然而我却又感染到了图灵对于“物理”和“机器”的执着。我觉得逻辑学家们对 lambda calculus 的解释过于复杂，而通过把它理解为物理的“电路元件”，让我对 lambda calculus 做出了更加简单的解释，把它与“现实世界”联系在了一起。</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/lambda-inside.png" type="image/png" height="450" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="394"/></p><p style="margin:0px 0px 20px;padding:0px;">所以到最后，丘奇和图灵这两种看似矛盾的思想，在我的脑海里得到了和谐的统一。这些精髓的思想帮助我解决了许多的问题。感谢你们，计算机科学的两位鼻祖。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="839"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_d93460" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">创造力的真正含义</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">　　创造力的真正含义</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着别人都在看球赛的时候，你独自在操场上练球，欣赏那球飞出去时的弧线。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着让你最开心的事情不再是享受别人的创造，而是创造。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会从非常不起眼的小东西里面得到启发，而当你兴高采烈的告诉其它人的时候，会遭遇到他们司通见惯的语气。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你不再能从本领域专家的嘴里得到启发。你会更喜欢跟完完全全的外行讲话。你会把世界上最难的一些问题编成小故事讲给你可爱的女朋友，而她的回答，经常莫名其妙撞上你梦寐以求的答案。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会在所有的东西身上看到可以改进的地方。你会怀疑设计这些东西的人其实根本没用过他们自己的产品。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会永远像一个小孩。你会看到所谓的“大人”们看不到的可能性，这些“大人”有可能比你还要小几十岁。当你告诉他们自己的想法时，他们的反应总是让你失望。在父母的眼里，你总是不能成熟，而在你的眼里，父母和其他人一样，看不到其实他们自己才是真正不成熟的人。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你人生中遇到的最大障碍不再是技术的难题，而是人类的愚蠢。你人生最大的错误，是低估了这种愚蠢的力量。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会非常孤独。别人推崇至极的东西在你眼里不过是小菜一碟，所以人们会认为你不是他们的同类，而优先与同样的狂热分子为伍。你有时甚至会发现自己没有逃避的自由，没有不跟着起哄的自由。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你经常会为了得到最底层的启发，问一些貌似很基础的问题。有些人看到这些问题就会以此作为你水平不够的证据，从而以为可以凌驾于你之上。如果是在 IRC 聊天室，他们会说：“去，读了文档再来问！”</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你有比别人大很多的安全感，你不会理解，上司或者导师为什么会害怕你不能完成项目，因为他们永远不会看到，也不会相信你能看到的东西。你会需要反反复复的安慰他们，但他们仍然会像拿到新衣服之前的皇帝一样派人来打探你，看你是不是真的在制造传说中那能够鉴别 IQ 的布料。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你不会再在乎人们不知所以的赞许。大部分时候这种赞许反而变成了对你能力的侮辱，所以你多希望他们什么都别说，特别是不要当着众人的面，因为你知道，这除了引起其他人的嫉妒和敌意，没有任何其它作用。你会想在地上找个缝钻进去。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你自认为的一些雕虫小技会被人当成是大作，而自己真正满意的大作却由于看起来小，没有人理会。每当你做出一点什么，人们就以为你是什么，从而把你的一生定格在那里。他们不明白，你的价值不在于你做的东西，而在于你自己。你是没有界限的人。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会分不清什么是新的想法，什么是旧的想法。因为不管别人看起来新的还是旧的，都是你自己想出来的。因为你忙着创造，你没有时间去追究一个想法别人是否已经有了。你只知道什么是好的，管它是新的还是已经有的。你知道自己可能是在重新发明轮子，但是你知道，当把轮子全部都发明完了之后，除了发明新的东西你别无选择。你会发现，发明轮子是非常重要的练习，因为没有发明过轮子的人，他们也发明不出什么特别好的车子。</p><p style="margin:0px 0px 20px;padding:0px;">拥有创造力，意味着你会很难找到工作，因为面试你的人会提出很多需要死记硬背的问题。面对他们的时候，你根本不知道那些术语是什么，然而等你回头一查，发现它们是自己几年前想出来却又抛弃了的，没有名字的主意。</p><p style="margin:0px 0px 20px;padding:0px;">所以，拥有创造力带来的更多是苦难和孤独。可是如果上天再给你一次可以抛弃它的机会，你仍然会毫不犹豫的说，不！</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="847"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_79028c" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">为什么一种程序语言是不够用的</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我曾经希望设计出一种“终极语言”，然而我却发现一种语言其实是不够用的。这是为什么呢？</p><p style="margin:0px 0px 20px;padding:0px;">我们都知道，程序语言里包含了变量，数字，对象，函数等“元素”。它们就像物理学的<a href="http://en.wikipedia.org/wiki/Elementary_particle" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">基本粒子</a>一样，可以用于构造我们所需要的几乎任何“模型”。既然所有的东西都是用基本粒子组成的，那么除了物理学，我们为什么还要有化学和生物？化学家使用的语言是化学元素，它们比基本粒子大很多。生物学家的语言就更大一些了，处于细胞的级别。那么为什么化学家和生物学家不使用基本粒子来描述他们的领域呢？</p><p style="margin:0px 0px 20px;padding:0px;">那是因为基本粒子无法提供足够的“抽象”。它们到底是如何组成原子，原子又如何能产生细胞，这些事情到现在还没搞清楚。用基本粒子来表示化学和生物学，那么我们恐怕要等很久很久以后才能描述化学和生物的现象和原理。</p><p style="margin:0px 0px 20px;padding:0px;">同样的，变量，数字，对象，函数等语言的要素，也是不足以表达我们需要的所有程序的。有人认为函数是这些元素的“终极粘合剂”，可是函数的结构组合能力却不是万能的。函数接受一些参数，返回一个结果。然而有些我们需要表达的概念却不是这样的结构，比如一个带有多根电线的黑匣子，它可以从任何电线输入东西，然后从剩下的电线输出。每根电线的输入和输出方式，在不同的“调用”可以随意的更改。比如，电线 A 第一次被调用是输入，第二次被调用就变成了输出。</p><p style="margin:0px 0px 20px;padding:0px;">这个黑匣子就是逻辑语言（比如 Prolog，miniKanren）的基本元素。你如何用函数来表示它呢？你不能。因为不管你怎么把函数组合起来，这个黑匣子的电线不是连接到函数的输入，就是连接到输出。所以它们总是有“固定”的方向，不能满足这种奇怪的黑匣子的工作方式。所以虽然这个元素可以用更加基本的元素（比如变量等）组成，然而函数却不能作为这里的粘合剂。</p><p style="margin:0px 0px 20px;padding:0px;">所以一旦出现了这样用现有的元素和粘合剂没法表示的东西，我们就需要为语言加入新的构造，也就是把语言扩展。这个构造必须经过一个比函数更加剧烈的转化，才能实现我们想要的功能。</p><p style="margin:0px 0px 20px;padding:0px;">第一种方式是写一个解释器，用来描述这个黑匣子的工作方式。黑匣子被作为一个普通的数据结构，输入解释器，然后我们从解释器得到它的结果。这貌似是万能的方式。</p><p style="margin:0px 0px 20px;padding:0px;">另外一种“几乎万能”的方式是使用宏（macro）。宏可以把这个黑匣子的“语言描述”（也就是AST）拆散，然后组成一个用原来的语言元素组成的结构，并且把它插入到原来的程序里面。这就相当于把黑匣子“编译”成了我们已有的语言，然后“嵌入”。比如对于逻辑语言的黑匣子，当我们在调用它的时候，宏就会知道它的输入和输出的“方向”。一旦知道了这个方向，它的行为方式就会像一个函数，所以我们就可以以此把它编译成函数。在下一个调用的地方，输入输出的方向又有不同，所以就把它编译成另外一个函数。</p><p style="margin:0px 0px 20px;padding:0px;">所以，每一个宏其实就是一个编译器。你可以用 Lisp/Scheme 的宏来实现几乎任何语言结构。这种“嵌入式语言”通常被叫做 EDSL (Embedded Domain Specific Language)。</p><p style="margin:0px 0px 20px;padding:0px;">有些其它语言也提供一些构建 EDSL 的能力，比如 Haskell, Scala 等。虽然它们有一定构建 EDSL 的能力，却不能达到 Lisp/Scheme 宏的地步。它们往往使用“重载”的方式来定义一些操作符，比如&quot;+&quot;号，然后把这些操作符作用于这个 EDSL 的 AST 所特有的类型，从而让操作符“自动切换”到这个 EDSL 的语义。</p><p style="margin:0px 0px 20px;padding:0px;">Haskell 有一个 EDSL 叫 Accelerate 就是这样实现的，它使用 type class 来重载操作符，用于 GPU 的操作。然而我却发现使用它的时候，有时候我必须打进一些莫名其妙的，跟我想要表达的概念毫无关系东西。这是因为重载的能力是有限的，它并不能像宏一样，可以任意的拆解和拼装整个表达式。所以 Accelerate 在很多时候需要你写一些特定的东西，这样它才能避免歧义，实现正确的重载操作。到后来，我发现这些多余的符号成为了非常碍眼的东西，让我无法直接的看到我所要表达的概念。</p><p style="margin:0px 0px 20px;padding:0px;">所以我觉得 Lisp 和 Scheme 的宏是很重要的东西。然而有一个前提：宏一定要少用，要在非常有必要的时候才定义宏。否则你的语言里就会出现很多奇怪的结构，这些结构没法用函数调用的语义来理解，这样就造成了程序员之间交流的障碍。在 Common Lisp 里面有多种很炫的 looping macro 就这样的例子，它们让 Common Lisp 的程序难以理解。</p><p style="margin:0px 0px 20px;padding:0px;">然而说一种语言是不够用的，并不是说世界上的那么多种语言都是必须存在的。实际上，它们大部分的功能都是重复的，很多设计糟糕的语言根本就没必要存在。所以我说的“不够用”不是从实用主义的角度出发，而是从原理性的角度出发的。我只是说，在特定的需求面前，你有可能需要为语言加入新的构造和语义。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="848"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_aef7df" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">在 Sourcegraph 的第三天</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">这个星期一我就正式加入 <a href="http://www.sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Sourcegraph</a> 了。做自己感兴趣的东西真是不感觉累。这里没有人是老板，每个人都是老板，每个人都写很不错的代码。虽然每天工作的时间比起在 Voxer 多了很多，但是感觉也好了很多。Quinn 和 Beyang 每天都工作到半夜，但是仍然每天精神饱满。我比他们稍微偷懒一些。工作不是因为有压力，而是有一种像打电玩一样的“瘾”，这样的工作还能叫工作吗？那叫“玩物不丧志” :-)</p> 
<p style="margin:0px 0px 20px;padding:0px;">我们的条件是艰苦的，办公室又小又乱。虽然条件很快就会改善，我却一点也不在乎这个。Steve Jobs 不也是在车库里创造了 Apple 吗？这才像是个 startup 嘛。我们的目标是：精确的，按语义的搜索全世界的代码，成为程序语言界的 Google。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/sg-office.jpg" type="image/jpeg" height="700" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></p> 
<p style="margin:0px 0px 20px;padding:0px;">(上图为我们的 co-founder 和 CTO Beyang 同学，他非常能吃，冰箱里的剩菜都是他吃掉的。还吃不饱就拿电炉煮泡面。）</p> 
<p style="margin:0px 0px 20px;padding:0px;">Sourcegraph 的系统界面做得相当干净友好，所以来到这里的第三天，我就已经成功的把 PySonar2 加入到了 Sourcegraph 里面，并且改进了 PySonar2 的很多代码。不久你就可以在 <a href="http://www.sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">sourcegraph.com</a> 上面看到你的 GitHub Python 代码的类型。我还会把 PySonar2 移植给 Ruby 和其他一些语言。</p> 
<p style="margin:0px 0px 20px;padding:0px;">另外，我推荐 Quinn 和 Beyang 一天之间写出来的小玩意：sourcegraph 的 <a href="https://chrome.google.com/webstore/detail/sourcegraph/dgjhfomjieaadpoljlnidmbgkdffpack" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Chrome 插件</a>。安装之后，当你浏览 GitHub 的 repo 的时候，就会自动显示出 Sourcegraph 为你索引出的引用次数最多的那些代码：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/chrome-sg.png" type="image/png" height="406" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></p> 
<p style="margin:0px 0px 20px;padding:0px;">PySonar2 其实具有一种非常强大的类型系统，包含了 intersection type, union type 等类型，这些都是 Java, Haskell, OCaml 等语言不具有的灵活而强大的类型。PySonar2 也可以推导出高阶函数类型。</p> 
<p style="margin:0px 0px 20px;padding:0px;">比如下面这个例子是 Flask 框架的 route 函数（显示在我修改过的本地 Sourcegraph 网站上）：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/python-type.png" type="image/png" height="459" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></p> 
<p style="margin:0px 0px 20px;padding:0px;">PySonar2 推导出它的类型是：</p>(Flask, str) -&gt; (() -&gt; str) -&gt; () -&gt; str 
<p style="margin:0px 0px 20px;padding:0px;">这里是一个高阶函数，它表示： route 接受一个 Flask  对象 (self) 和一个 str，然后生成一个中间函数。这个函数接受另一个函数（类型为 () -&gt; str），然后又生成一个函数。这个函数被调用之后，会返回一个 str。这就是为什么你可以这样调用它：</p>app.route('/')(index) 
<p style="margin:0px 0px 20px;padding:0px;">其中 index 函数的类型是 () -&gt; str（如图所示）。它不接受参数，返回一个 str。</p> 
<p style="margin:0px 0px 20px;padding:0px;">目前这个功能还不在主网站上面。等完全调试通过后，不久就会放到上面。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="852"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_d60925" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">RubySonar：一个 Ruby 静态分析器</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">RubySonar：一个 Ruby 静态分析器</p> 
<p style="margin:0px 0px 20px;padding:0px;">在过去一个多月时间里，我大部分时间都在做一个 Ruby 的静态分析叫做 <a href="https://github.com/yinwang0/rubysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">RubySonar</a>。它使用与 PySonar2 类似的技术，不过针对 Ruby 的语义进行了很多调整。现在这个分析器已经能够支持 <a href="https://sourcegraph.com/github.com/rails/rails" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Sourcegraph</a> 的 Ruby 代码搜索和浏览。这比起之前的效果是一个很大的进步。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://sourcegraph.com/github.com/jekyll/jekyll/symbols/ruby/gem/Jekyll/Command/$classmethods/globs" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/rubysonar1.gif" type="image/gif" height="443" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;">在 RubySonar 的帮助下，对于很多 repo，Sourcegraph 可以搜索到比以前多几十倍甚至上百倍的符号，当然代码的使用范例也随之增加了。代码定位的准确性有很大提高，基本不会出现错位的情况了，另外还支持了局部变量的加亮，所以看起来有点像个“静态 IDE”的味道。</p> 
<p style="margin:0px 0px 20px;padding:0px;">由于 RubySonar 比起 Sourcegraph 之前用的基于 <a href="http://yardoc.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">YARD</a> 的分析在速度上有上百倍的提高，我们现在可以处理整个 <a href="https://sourcegraph.com/github.com/ruby/ruby" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Ruby 标准库</a>（而不只是以前的一小部分）。<a href="https://sourcegraph.com/github.com/rails/rails" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Ruby on Rails</a> 的结果也有比较大的改善。另外，以前不支持的像 <a href="https://sourcegraph.com/github.com/Homebrew/homebrew" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Homebrew</a> 之类的独立应用，现在也可以分析了。</p> 
<p style="margin:0px 0px 20px;padding:0px;">RubySonar 的静态分析使用跟 PySonar2 相同的跨过程，数据流+控制流分析，而且采用同样的类型推导系统，所以分析的精度是很高的。我还没有跟 Ruby 的 IDE 比较过，不过因为构架的先进性，它应该已经能处理一些现在最好的 Ruby IDE 也搞不定的事情，当然由于时间短，在细节上比起它们肯定也有不足之处。</p> 
<p style="margin:0px 0px 20px;padding:0px;">虽然 Ruby 和 Python 看起来是差不多的语言，为了把 PySonar2 改到 Ruby 上，还是做了不少的工作的。最开头我试图让它们“重用”大部分代码，只是在不一样的地方做一些条件分支进行特殊处理。可是后来发现这样越来越复杂，越来越危险。为了照顾一个语言的特性，很容易破坏掉为另一个语言已经千辛万苦调试好的代码。结果最后决定把它们完全分开，其中共享的代码通过手工拷贝修改。事实证明这个决定是正确的，否则到现在我可能还在为一些莫名其妙的错误伤脑筋。这个经验告诉我，所谓的 DRY（Don't Repeat Yourself）原则其实有它的局限性。有时候你真的是宁愿拷贝粘贴代码也不要共享。</p> 
<p style="margin:0px 0px 20px;padding:0px;">当然到现在，我对 Ruby 和 Python 之间的差别也就有了很清楚的对比。它们的一些灵活的设计给了我一定的<a href="http://www.yinwang.org/blog-cn/2013/04/12/inspiration" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">启发</a>。我看到了过于死板的静态类型系统带来的一些没必要存在的不便，然而我也清楚地看到它们过度的灵活性和一些不知所以的设计给程序员和静态分析带来了哪些不必要的麻烦。所以虽然 PySonar 和 RubySonar 都可以说是针对这两种语言最先进的静态分析技术，但它们有一些不可逾越的局限性。它们能够发现程序里存在类型错误，但它们却不能保证程序完全没有类型错误。我并不认为 PySonar 和 RubySonar 是我最好的作品，我只是顺手拈来，尽力而为，另外从它们的设计中汲取一些经验教训，让我自己设计的语言避免这些问题，却又相对灵活。</p> 
<p style="margin:0px 0px 20px;padding:0px;">目前 RubySonar 还缺少对 native 库代码的支持，但是由于代码始终保持了简单的原则（RubySonar 只有 7000 多行代码），那些东西会比较容易加进去。感兴趣的 Ruby 用户可以看看自己的 repo 是否已经得到处理，如果没有的话可以来信告诉我，也欢迎给我指出其中存在的问题。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="854"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_6e3de8" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">“One语言”的设计理念</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">上文提到我下一篇博客要讲静态分析的原理，但是睡了一晚上之后，觉得更有动力先讲一下我的语言的设计，以后再讲静态分析的事情。当然这篇文章里面也会涉及到静态分析的一些东西。以后我应该尽量避免谈到“下一篇博客”要讲什么，因为我总是喜欢改变主意。</p><p style="margin:0px 0px 20px;padding:0px;">其实我一直在设计一种语言。从进入 Cornell 之后，我就在搜集各种资料信息，想设计一种“终极语言”，它会使得编程变得极其简单。因为大家都用这同一种语言，所以不管是人还是程序间的信息交换都会变得非常容易。软件的构造效率会大幅度提高。</p><p style="margin:0px 0px 20px;padding:0px;">虽然离“终极”的目标还差一截，但是我还是把这种语言暂时称为 One。如果写一本书，就应该叫：The One Programming Language。THE ONE — 让我想起了骇客帝国的 Neo 哈哈…… 也许可以把用这个语言写出来的操作系统叫做 Neo。一种用于取代 Unix 的操作系统，就是我的下一个目标。实际上这个操作系统就是 One 语言的“运行时系统”（runtime）。</p><p style="margin:0px 0px 20px;padding:0px;">（现在发现 One 这个名字不好。Neo 可以考虑。不过只是个名字，以后换换就行。）</p>为什么我们只需要一种程序语言<p style="margin:0px 0px 20px;padding:0px;">有些人认为只用一种程序语言貌似天方夜谭的事情，然而我觉得这是有可能实现的。</p><p style="margin:0px 0px 20px;padding:0px;">很多人从自然语言的现状出发，觉得世界上需要多种程序语言。然而圣经的故事告诉我们，在最早的时候全世界只有一种语言。但是由于全部人都用这种语言，信息交互非常迅速，人类发展很快。上帝开始担心人会超越自己，所以就施了一个法术，让不同地方的人开始说不同的语言。这样人们由于信息交互不流畅，发展就减慢了。当然圣经只是一本故事书，但这貌似仍然说明了一些问题。</p><p style="margin:0px 0px 20px;padding:0px;">从认知科学的角度来看，人类其实根本不是用自然语言思考的，不管是中文还是英语，法语…… 不同国家的人在思考的时候，脑子里其实运行的是同一种没有名字的“人脑语言”。来自感官的信号，和神经元之间的电化学反应，在人脑里面形成了一种动态的“电路”和“模型”。人脑就是使用这些电路来推动这些模型，从而预测出将来会发生的事情。他们需要交流的时候，才会把这些模型转换为自然语言。程序语言其实就跟人脑里面的这种语言类似，它也是一种用于构造“模型”的材料，只不过这种模型不是由人脑，而是由电脑来运行。这就是为什么我们能用电脑来预报天气。</p><p style="margin:0px 0px 20px;padding:0px;">从物理的角度来看，我们生活的世界本来就是由非常简单的材料——基本粒子构成的。我们看到的千奇百怪的物体，不过都是这些基本粒子经过不同的方式组合在一起而已。所以有什么理由认为我们需要很多种程序语言呢？</p><p style="margin:0px 0px 20px;padding:0px;">从历史来看，已经有这样的系统存在过：Lisp Machine, <a href="http://www.yinwang.org/blog-cn/2013/03/07/oberon" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Oberon</a>。</p><p style="margin:0px 0px 20px;padding:0px;">所以，我觉得世界上根本不需要那么多种程序语言。理想的情况是一种就够了。</p>One语言的基本要素<p style="margin:0px 0px 20px;padding:0px;">One语言的设计融合了很多种语言的因素和一些新的想法。它并不是简单的把它们放在一起，而是从哲学的角度出发，让这些要素无缝的组合在一起。需要描述的每一个模型，都有一个最直接，最高效的描述方式，而不需要转几道弯，绕过一堆语言设计的无端限制来完成。</p><p style="margin:0px 0px 20px;padding:0px;">我现在就介绍一下几个最主要的要素。偏向于某些语言的人也许会对我的选择比较吃惊，但是我会对这些选择做出简要的分析，说明我的理由，或者给出之前的一些博文的链接。</p>语法<p style="margin:0px 0px 20px;padding:0px;">One 语言使用与 Lisp/Scheme 类似的，基于“S表达式”的语法，但比它们的“语法”含量还要少，还要简单。比如，它不包含 #(...) 这样的东西。通常所谓的“S表达式”其实包含了不少的复杂性，这使得“reader”（也就是 Lisp 的 parser）的构造其实并不像传说中的那么简单。这样的选择的目的，在于让语法分析变得极其容易，速度极快。再加上编译器速度也快，“编译加运行”的过程里面，“编译”占的比重非常之小。所以开发程序的时候你可以专注于源程序，而不必担心“build”的过程。</p><p style="margin:0px 0px 20px;padding:0px;">这样的语法会在早期带来一定的“打字开销”，但是从长远角度来看是有益处的。因为我的设想中，Neo 系统会自带一种基于“结构化编辑”的 IDE，它能够帮助高效的编辑 One 语言的源文件，也可以让人可以选择更加美观，更加简洁的“渲染”方式。由于语言实现考虑到了这一点，所以编译器会给 IDE 提供相当大的支持，使得 IDE 的实现变得容易。</p><p style="margin:0px 0px 20px;padding:0px;">在这种 IDE 实现以前，也可以用 Emacs 加 <a href="http://mumble.net/~campbell/emacs/paredit.el" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">paredit-mode.el</a>。</p><p style="margin:0px 0px 20px;padding:0px;">关于语法，详细的思想可以参考之前一篇博文：《<a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">谈语法</a>》。</p>函数式<p style="margin:0px 0px 20px;padding:0px;">One 语言具有 first-class function。函数可以作为值任意传递。跟 Scheme 一样，这是一种真正的 lambda。很多语言虽然有叫 lambda 的东西，但却不能正确的实现，比如 Python 和 C++11。</p><p style="margin:0px 0px 20px;padding:0px;">具有真正的 lambda 的语言都需要 closure optimization。这个优化如果不做，就会产生大量的内存访问。C++11 要求程序员自己写出 free variable 在 [...] 里，就是因为它的编译器不能做好这个优化。在 Chez Scheme 和 Kent 的课程里，这种优化都是做得很好的，做到了极点。</p>副作用<p style="margin:0px 0px 20px;padding:0px;">One 语言不是一种“纯函数式”语言，它允许自由的使用副作用。为什么不设计成像 Haskell 那样的纯函数式语言，不但是出于效率的需求，而且是因为“纯函数式”本身的问题。纯函数式语言所能表达的一切对于“安全性”的要求，其实都可以通过简单的静态分析来达到。实际上，静态分析系统的实现，里面就有很多类似 monads 的东西。纯函数式语言带来了程序员的各种麻烦，因为它相当于让程序员自己在实现一些简单的静态分析系统。关于这个问题，可以参考另一篇博文：《<a href="http://www.yinwang.org/blog-cn/2013/03/31/purely-functional" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">对函数式语言的误解</a>》。</p><p style="margin:0px 0px 20px;padding:0px;">所以 One 语言允许使用各种副作用和赋值。当然，真的需要纯函数式数据结构的时候，你也可以实现它们，你只要不用赋值语句就可以。</p>没有 let (暂行）<p style="margin:0px 0px 20px;padding:0px;">跟 Lisp 和 Scheme 不同，对于变量的“绑定”不使用 let，而是采用像 C 和 Java 里的变量声明。在 Lisp 里的</p>(let ([x 1])  ...)<p style="margin:0px 0px 20px;padding:0px;">变成了变量声明（语法是暂时的设计，重用类型声明的语法，看是否能把它们“统一”起来）：</p>(: x 1)...<p style="margin:0px 0px 20px;padding:0px;">去掉 let 的原因是，let 往往形成不必要的嵌套和缩进，然而从“模型”的角度，它跟变量声明是一样的效果：它们都是电路里的一个节点。另外 let 和 if 一起，经常产生一些复杂难读的结构，比如，</p>(let ([x (if y 0 1)]) ...)<p style="margin:0px 0px 20px;padding:0px;">你必须把 (if y 0 1) 嵌套在 let 之内才能让同一个变量依据不同的条件得到不同的值。可是如果你有变量声明和赋值语句，你就可以写：</p>(: x)(if y  (&lt;- x 0)  (&lt;- x 1))<p style="margin:0px 0px 20px;padding:0px;">这样其实清晰一些。这种变量多的时候，赋值的好处就更加明显。赋值语句只能对已经“绑定”的变量进行赋值，而不能构造新的绑定。声明和赋值都不需要类型标记，系统会很容易的自动推导出类型。</p>不区分stack和heap变量<p style="margin:0px 0px 20px;padding:0px;">跟 C++ 和 C# 不同，但是跟 Scheme 和 Java 类似， 所有的变量都只是一个名字，程序员没必要知道它被放在堆栈（stack）上还是堆（heap）上。做这样的选择是为了让“名字”这个概念更加有一致性。为什么程序员需要知道它在哪里呢？这种事情本来就应该是编译器来做的。程序员所要知道的只是“一个名字对应一个对象”。</p><p style="margin:0px 0px 20px;padding:0px;">编译器尽量把对象放在堆栈上，这样可以减少 heap 的碎片现象。</p>快速而高效的寄存器分配算法<p style="margin:0px 0px 20px;padding:0px;">几十年来，很多编译器都使用一种图着色的寄存器分配算法，这种算法的复杂度是 NP-Complete 的，就算近似解的复杂度也不能达到线性时间。</p><p style="margin:0px 0px 20px;padding:0px;">经过一个学期与 Kent Dybvig 的 independent study，我设计了一个与 Chez Scheme 类似，却又在某些地方应该更加高效的算法。这个算法极其简单，基本上是线性时间，但却可以达到超过图着色算法的效果。它其实自然的包含了 linear scan 和 live range splitting 两种技术的组合。原理是把寄存器作为堆栈的“cache”，这样寄存器的分配就变成了一个静态的“cache replacement”算法。</p><p style="margin:0px 0px 20px;padding:0px;">这个方法被记录与我写的（Kent挂名）的一篇 paper 稿（未发表）。你可以在这里看到它的全文。</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://arxiv.org/abs/1202.5539" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://arxiv.org/abs/1202.5539</a></p><p style="margin:0px 0px 20px;padding:0px;">其实寄存器分配现在已经几乎不是一个问题，因为现在的处理器一般都有足够多的寄存器，使得笨一点的算法也能分配好寄存器。</p>自动的，非 GC 实时内存管理<p style="margin:0px 0px 20px;padding:0px;">由于希望 One 语言能够被应用于实时系统，所以我现在不考虑使用垃圾回收（GC）。在目前来看，再好的垃圾回收算法也是不能完全保证实时回收内存的。引起程序的暂停情况，在很多情况下是不可接受的。这不只是在实时的控制系统（比如飞机，导弹，汽车等），而且在现在的高度发达的互联网上，GC 带来的停顿也会引起问题，这就是为什么我听说淘宝和 Twitter 都试图改进 JVM 的 GC。Chez Scheme 使用了 generational GC，总共有5个 generation。据说效率相当高，可是我仍然怀疑它是否能达到最高的实时系统标准，因为貌似没有实时系统在使用 Chez Scheme （天知道呢，<a href="http://www.reddit.com/r/programming/comments/10ld5i/cisco_systems_acquires_chez_scheme" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Cisco 收购了 Chez Scheme</a> 拿去做什么了）。</p><p style="margin:0px 0px 20px;padding:0px;">GC 的问题大概就是为什么 C++ 继续流行的原因。我觉得与其解决这个问题，带来 runtime 的复杂性，不如使用另外的方式。其实我早就设计出了一种自动的引用计数的方式，但是我一直有点怀疑它的效率会受到引用计数变化的影响。利用一定的静态分析，编译器可以降低一部分这种开销。比如通过 escape analysis，自动把没法“逃脱”(escape）堆栈作用域的数据都作为堆栈数据处理，剩下的才放在 heap 上。只有放在 heap 上的对象才需要被引用计数。放在堆栈上的对象会在函数结束时被回收。</p><p style="margin:0px 0px 20px;padding:0px;">对于引用计数里面的 cycle 问题，一般的做法是与偶尔的 GC 结合，但是一旦有了 GC，似乎又会不可避免的出现停顿的问题，所以我决定依靠程序员自己做记号来实现。如果他需要指出“我现在的赋值语句会在数据结构中构造一个环”，他就使用一种特殊的赋值语句 （语法是临时设计），比如：</p>(&lt;= node.next ls.head)<p style="margin:0px 0px 20px;padding:0px;">这样的赋值语句虽然会降低 node.next 的引用计数，但却不会对 ls.head 的引用计数产生影响，所以产生一个 weak pointer。如果他不小心写成了普通的赋值语句怎么办呢？那就在系统里留下一些垃圾。所以恐怕也需要结合一下基于 arena 的方式，就像 Unix 一样，把结束之后的进程占用的内存完全释放掉。</p><p style="margin:0px 0px 20px;padding:0px;">根据我跟一个编译器工程师的讨论，Objective-C 的自动引用计数（ARC）是相当高效的，然而这种自动引用计数方法是否能满足实时系统要求，还有待实践考验（因为没有人在实时系统里用 Objective-C）。也许有一天我会再次考虑使用 GC 或者其他方式，但它应该只需要程序员做非常少的工作。</p>使用 Partial Evaluation 来统一整个编译器的设计<p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.itu.dk/~sestoft/pebook/pebook.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Partial Evaluation</a> 是 Neil Jones 在 80 年代提出的一种自动生成编译器的方法。在 Chez Scheme 里面有一个优化过程叫做 CP0，是一个 online partial evaluation。在 Kent 的另一个课程，我们实现了 CP0 的算法。</p><p style="margin:0px 0px 20px;padding:0px;">这种 online partial evaluation，可以一步就完成其它编译器里面的很多种优化，比如 constant folding, copy propagation 等。它也可以被作为很多要素的实现方式，比如用于优化掉多余的动态类型检查。这样我就从中得到了一种可以实现动静态类型检查“自动划分”的方法。</p><p style="margin:0px 0px 20px;padding:0px;">再加上从静态分析领域得到的启发，我就得到了以下的类型系统。这个类型系统，也就是 One 语言不同于所有其他语言的特色。</p>强大，灵活而简单的类型系统<p style="margin:0px 0px 20px;padding:0px;">One 语言采用一种我正在设计的非常强大的类型系统。它合并了多种类型系统的最好的部分（Hindley-Milner, intersection type, dependent types ……），但却又不是简单的把它们堆放在一起。这种类型系统给程序员一种“连续性”的强度选择，从完全的动态检查，简单的类型，一直到最严格的定理证明方式（完全确保算法的正确性）。程序员可以完全不写类型，也可以选择只写某些类型。这给编程带来很大的灵活性，实现起来却又很简单。</p><p style="margin:0px 0px 20px;padding:0px;">程序员可以写完全不带类型的函数：</p>(def id (x) x)<p style="margin:0px 0px 20px;padding:0px;">他没有给参数 x 类型标记，所以类型系统自动的认为 x 可以是“任何对象”。由于函数直接返回了参数 x，而没有针对它的类型进行“操作”，所以这个函数可以通过类型检查。这样就构造出完全“多态”（polymorphic）的函数，可以接受任何对象作为参数。</p><p style="margin:0px 0px 20px;padding:0px;">进一小步，程序员也可以声明参数的“简单类型”，这就像普通的语言比如 C 或者 Java 一样。然而跟很多语言不同的是，类型的标记不是放在参数列表上，而是放在函数内部，就像一个普通的 assertion。比如：</p>(def id-int (x)  (assert (: x int))  x)<p style="margin:0px 0px 20px;padding:0px;">这里的 &quot;:&quot; 表示一种“子类型关系”。(assert (: x int)) 表示：x 必须是整数，或者是整数的“子类型”，也就是说它必须是一种“可以被当成是整数的对象”。</p><p style="margin:0px 0px 20px;padding:0px;">把类型声明放在函数体内，不是为了显得酷，而是为了取得语义的“一致性”。这个类型声明可以是一个很复杂的表达式，比如 (assert (or (: x int) (: x bool)))，它可以表示 x 或者是 int，或者是 bool。这样，我就可以简单的实现 dependent type 的功能，因为我的“类型声明”里面可以含有任意的代码（不过返回值必须是 bool）。</p><p style="margin:0px 0px 20px;padding:0px;">跟大部分基于 HM 系统的函数式语言（ML，Haskell）不同，One 语言只有一种类型间的关系：子类型。子类型关系表示了类型间的“兼容性”(compatibility)。子类型关系是一种更加灵活的关系，就像“子集合”关系。如果 (: A B)，那么 A 和 B 可以是“等价”的，也有可能 B “真包含”A，也就是说“有某些 B 的成员不是 A”。所以 (: A B) 就是说，所有的 A 都是 B。</p><p style="margin:0px 0px 20px;padding:0px;">更近一步，程序员可以声明更加细节的“需求”，比如：</p>(def bar (x)  (assert (and (: x int) (&lt; x 5)))  x)<p style="margin:0px 0px 20px;padding:0px;">这就是说，x 是整数，而且必须小于5。这样 bar 的调用者就有“责任”证明这个事实。它的代码也许像这个样子：</p>(def call-bar (y)  (assert (: y int))  (cond    [(&lt; y 4)     (bar y)]     ...))<p style="margin:0px 0px 20px;padding:0px;">注意，call-bar 其实什么事也没做，然而系统能够自动从条件 (&lt; y 4) 推断出 (&lt; y 5) 肯定也成立，从而知道 (bar y) 是可以安全调用的。也就是说，系统通过 call-bar 的定义，自动证明了这个定理。</p><p style="margin:0px 0px 20px;padding:0px;">这种类型的工作方式是几乎所有语言都还没有的。它来自于我对静态分析和机器定理证明的理解。它可以让程序员对函数的调用者提出比较复杂的需求。但是过于复杂的定理可能就需要人工帮助了。为了实现的简单，我目前并不打算把它设计为可以证明很复杂的定理，否则有可能变成 Agda 和 ACL2 那样很少有人会用的东西。</p><p style="margin:0px 0px 20px;padding:0px;">类型标记间的依赖关系</p><p style="margin:0px 0px 20px;padding:0px;">可以选择不写类型，并不是说如果程序员的疏忽没写类型，就会导致运行时错误。类型系统在类型标记的“数据流”中，存在一种严格的逻辑依赖关系。比如，如果你写这样一个函数：</p>(def foo (y)  (id-int y))<p style="margin:0px 0px 20px;padding:0px;">编译器会拒绝这个程序，因为 id-int 被声明为只接受 int 类型，而它的调用者 foo 却没能在调用它之前“证明”y是一个 int。</p><p style="margin:0px 0px 20px;padding:0px;">注意这里我使用了“证明”这个词。这是因为每一个像 (assert (: x int)) 这样的“类型声明”，其实是一个“证明请求”。它的意思是“调用我的人必须事先向我证明，x 的值肯定是一个整数”。</p><p style="margin:0px 0px 20px;padding:0px;">然而 foo 却不能保证 y 是一个整数，因为 y 从外面进来，不知道它是什么！这时候，foo 的作者可以加一个证明请求：</p>(def foo (y)  (assert (: y int))  (id-int y))<p style="margin:0px 0px 20px;padding:0px;">这样程序就能通过编译，因为“证明请求”使得证明的责任“转嫁”到了 foo 的调用者，不管它是谁。这样就形成了一种逻辑的“依赖关系链”。</p><p style="margin:0px 0px 20px;padding:0px;">这些逻辑有可能叠加组合起来，形成比较复杂的逻辑表达式。这样调用函数的人，就有责任做两件事情之一：1）直接证明这个“定理” 2）写一个“证明请求”，转嫁证明的责任给自己的调用者。</p><p style="margin:0px 0px 20px;padding:0px;">显然对于复杂的定理，有可能目前还没有人把它证明出来（如哥德巴赫猜想），或者证明它需要很长的时间。这时候程序员为了短期的目标，可以使用 assume“显式”的声明：我没法证明这个定理。比如：</p>(def gold (x)  (assert (goldbach-conjecture x))  x)(def bar (z)  (assume (goldbach-conjecture z))  (gold z))<p style="margin:0px 0px 20px;padding:0px;">这个 (assume (goldbach-conjecture)) 告诉编译器：“我没法证明哥德巴赫猜想，我暂时假设它成立”。这样编译生成的代码会自动在 (assume (goldbach-conjecture z)) 处插入动态检查，判断 z 是否符合哥德巴赫猜想。这样如果运行时输入的参数 z 不满足哥德巴赫猜想，程序就会发生运行时错误当掉。当然，你也许能因此拿到 Fields Medal（因为你碰巧证明了哥德巴赫猜想不成立），也有可能因此而丧生（因为这代码位于你坐的宇宙飞船的自动着陆系统）。</p><p style="margin:0px 0px 20px;padding:0px;">这种类型系统有点像 dependent type，但是它更加实用，也容易使用和实现。只要把所有的 assert 和 assume 进行一个 Partial Evaluation 就行。实际上，Partial Evaluation 就是 dependent type 的本质。</p><p style="margin:0px 0px 20px;padding:0px;">这就是这个类型系统里面比较有特色的地方。另外它还包括了我的 PySonar 和 Typed Racket 里面具有的 union type。这种 union type 可以很好的解决 null pointer 的问题。关于 null pointer，可以参考我的一篇<a href="http://yinwang0.wordpress.com/2013/06/03/null" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">英文博文</a>。</p><p style="margin:0px 0px 20px;padding:0px;">静态分析工具一般都有友好的“bug路径显示”，在这种具有 union type 的类型系统里面，我也想实现类似的报错功能。比如：</p>(def baz (x) : int  (: x int)  (cond   [(&lt; x 1) 2]   [else &quot;bad&quot;]))<p style="margin:0px 0px 20px;padding:0px;">由于 cond 表达式是一个分支语句，所以这个函数的返回类型被推导为 {int, string}。然而类型标记却说它的类型应该是 int。所以编译器报错，说“{int, string} 不能与 int 兼容。”我觉得出错信息应该更加详细一些，它应该指出，这个多余的 string 是从哪里来的，比如指明 &quot;bad&quot; 以及它的行号（在结构化编辑器里，直接标记出它的 AST 节点位置）。</p>并行和分布式计算<p style="margin:0px 0px 20px;padding:0px;">One 语言可以比较简单的实现并行计算，这与 C# 的 async/wait 有点类似，但是它的设计目标是让这种原语成为系统里唯一的并行操作原语，从而让并行计算变得极其容易实现。我们提供一个关键字叫 par，用于指定某段代码可以并行执行。比如你可以说：</p>(: x (par (long-computation)))(: y x)(do-other-things)(foo (wait y))<p style="margin:0px 0px 20px;padding:0px;">这里的 par 表示：(long-computation) 应该被自动安排为异步执行。</p><p style="margin:0px 0px 20px;padding:0px;">第二行的 y 能够直接得到 x 的“可能还没计算的值”（在 C# 里面叫做 Task）。由于还没有人使用 y 的值，我们并不需要检查 (long-computation) 是否已经执行完毕。所以 (: y x) 和 (do-other-things) 可以毫无停顿的进行。这样 (long-computation) 就和 (: y x) ... (do-other-things) 成为了两个独立的“线程”。</p><p style="margin:0px 0px 20px;padding:0px;">直到必须使用 y 的值，我们才用 wait 去检查“y 计算出来了吗？”，因为 y 其实就是 x，所以这其实是在问：“x 计算出来了吗？”如果 x 还没计算完毕，那么就会等待它计算完才会调用 foo。这样两个线程就汇合在了一起。</p><p style="margin:0px 0px 20px;padding:0px;">为什么 par 和 wait 需要显式声明，而不能对程序员透明呢？这是来源于现实系统的限制。我们不能让编译器自动的插入 par 来并行执行某段代码，因为我们不知道 (long-computation) 到底会计算多久。也许它只是一个简单的加法呢？如果我们把这么微小的操作分配给另一个处理器，我们就增加了处理器间通信的开销。然而要想知道一段代码的运行时间，却是一个不可计算的问题。所以我们不得以，必须要求程序员来指定哪段代码运行时间足够长，值得进行并行计算。</p><p style="margin:0px 0px 20px;padding:0px;">那么为什么要使用 wait，而不能直接调用 (foo y) 呢？因为问像“x 执行完了吗”这样的问题是需要时间的。虽然时间很短，但是反复的问就积少成多了。任何地方的 par 语句都可能产生“还没计算完的值”，它们可能会随着“数据流”到达代码的任意位置。如果我们不能准确的定位它们可能出现的位置，我们就必须在使用每个变量之前问这个问题：“你计算出来了吗？”这样就带来了程序效率的大幅度降低。这与我之前谈到的“<a href="http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">惰性求值</a>”的缺点类似。然而，想要定位这些确实需要 wait 的位置，就需要全局的数据流分析。这在要求速度很快，或者需要模块化的编译器里是不大可行的。</p><p style="margin:0px 0px 20px;padding:0px;">由于 One 语言写出来的所有函数和表达式都有可能成为 Neo 操作系统的一个“线程”，当已有的线程仍然在运行的时候，我们有可能写出新的代码，编译然后执行。所以模块化的编译似乎是一个必须的东西。也就是说，进行全局数据流分析貌似开销太大，因为这种流分析可能需要分析系统里正在运行的所有进程的所有代码。</p><p style="margin:0px 0px 20px;padding:0px;">以上就是我能想到的 One 语言里比较有特色的地方。具体的设计和实现，还有待多方面的调查和讨论才能最后决定。关于 Neo 操作系统的设计，可以参考我以前的一篇<a href="http://www.yinwang.org/blog-cn/2013/04/14/os-design" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>。当然，虽然我搞定语言的类型系统和编译器没问题，运行时系统（操作系统）的设计，我肯定需要更有经验的人帮忙。所以欢迎大家跟我切磋。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="855"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="font-size: 12px; line-height: 200%; color: rgb(2, 2, 2); margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><a href="http://yinwang0.lofter.com/post/183ec2_c44d60" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">我和权威的故事</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="font-size: 12px; line-height: 200%; color: rgb(2, 2, 2); margin: 0px; padding: 0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">我和权威的故事</p><p style="margin:0px 0px 20px;padding:0px;">每个人小时候心里都是没有权威的，就像每个人小时候也都不相信广告一样。可是权威就像广告，你听一遍不信，听两遍不信，……，直到一千遍的时候，它忽然开始起作用了，而且这作用越来越强。</p><p style="margin:0px 0px 20px;padding:0px;">消灭广告所造成的幻觉，最好的办法就是去尝试，去实地的考察它。有些虚幻的东西只要你第一次尝试就会像肥皂泡一样破灭掉。可是如果你不主动去接触它，它就会一直在你脑海里造成一种美好神圣的假象。很神奇的一个现象就是，权威对人思想的作用其实也跟广告一样。</p><p style="margin:0px 0px 20px;padding:0px;">上大学以前的人因为没有专业，所以还不怎么崇拜权威，大不了追追歌星，影星，球星啥的。而进入大学之后，就会开始对本领域的权威耳濡目染。一遍，两遍，一千遍的听到同学们仰慕某“牛人”或者“大师”的名字，虽然从来没亲身见过，不知不觉就对这人产生了崇拜心理。Donald Knuth, Dennis Ritchie, Ken Thompson, Rob Pike, ... 就是通过这些途径成为了很多计算机学生的权威。以至于几十年以后，他们的一些历史遗留下来的糟糕设计和错误思想还被很多人奉为神圣。</p>
Donald Knuth
<p style="margin:0px 0px 20px;padding:0px;">很多人（包括我）都曾经对 Knuth 和他的 The Art of Computer Programming (TAOCP) 极度崇拜。在我大学和研究生的时候，有些同学花了不少钱买回精装的 TAOCP 全三卷，说是大概不会看，但要放在书架上做摆设，镇场子。当时我本着“书非借不能读也”的原则，再加上搬家的时候书是最费力气的东西，所以坚决不买书。我就从图书馆把 TAOCP 借了来。说实话我哪里看的下去啊？那里面的程序都是用一个叫 MIX 的处理器的汇编语言写的。一个字节只有6位，每位里面可以放一个十进制数（不是二进制）！还没开始写程序呢，就开始讲数学，然后就是几十页的公式推导，证明…… 接着我就睡着了。但我总是听说有人真的看完过 TAOCP，然后就成为了大师。比尔盖茨也宣称：“要是谁看完了 TAOCP，请把简历投给我！” 在这一系列的号召和鼓吹之下，我好几次的把 TAOCP 借回来，心想这次一定决心看完这旷世奇书。每次都是雄心勃勃的开始，可从来就没看完过开头那段 MIX 机器语言和数学公式。</p><p style="margin:0px 0px 20px;padding:0px;">看不懂 TAOCP 总是感觉很失败，因为看不懂 TAOCP 就成不了“大师”，可我仍然认为 Knuth 就是计算机科学的神，总能从他那学点什么吧。所以又开始折腾他的其他作品。这就是为什么我开始用 TeX，并且成为中国 TeX 界的主要“传教士”之一。为了 TeX，我把 Knuth 的 TeXbook 借回来，从头到尾看了两遍，做完所有的习题，包括最难的那种“double bend”习题。接着又开始看 MetaFont。开头还挺有成就感，可是不多久就发现学会的那些 TeX 技巧到了临场的时候就不知道该怎么用，然后就全都忘记了。这就是为什么我把 TeXbook 看了两遍，可是看完第二遍之后不久还是忘记得一干二净。</p><p style="margin:0px 0px 20px;padding:0px;">师兄师姐看到我用 TeX，说怎么折腾这么过时的玩意儿。我很气愤他们以及国内学术界居然都用 Word 排版论文，然后我就开始针锋相对，写出一系列煽动文章鼓吹 TeX 的种种好处，打击“所见即所得排版”这种低智商玩意儿。这还不够，又开始折腾 Knuth 设计的 MMIX 处理器，并且认为 MMIX 的寄存器环就是世界上最先进的设计。有几次发现一些无关紧要的小错，就给 Knuth 发 email，居然拿到两张传说中的“Knuth 支票”，并且一度引以为豪。当然像所有拿到 Knuth 支票的人一样，你是不会去兑现它的，甚至有人把它们放在相框里作为摆设。我还没那么疯狂，那两张支票一直在它们原来的信封里。多年以后我到美国想兑现那支票的时候，发现它们已经过期了。</p><p style="margin:0px 0px 20px;padding:0px;">当你心里有了这样的权威，其他人的话你是不可能听得进去的，就算他们其实比你心目中的权威更具智慧也一样。在清华的时候我很喜欢一门叫做“计算几何”的课，就经常跟那门课的老师交流思想。有一次我在 email 里面提到 Donald Knuth 是我的偶像，那位老师很委婉的回复道：“有偶像很好啊，Knuth 也曾经是我的偶像。” 我对“曾经”这两个字感到惊讶：难道这意味着 Knuth 现在不是他的偶像了？在我执意的询问之下他才委婉的告诉我，世界上还有很多很聪明的人，Knuth 并不是计算机科学的一切。你应该多看看其他人的作品，特别是一些数学家的。然后他给了我几个他觉得不错的人的名字。</p><p style="margin:0px 0px 20px;padding:0px;">现在回想起来，这些话对我是有深远作用的。那位老师虽然在系里的“牛人”们眼里是个“研究能力（也就是发paper能力）不强”的人，但是他却对我的人生转折有着强有力的作用。他引导了我去追寻自己真正的兴趣，而不是去追寻虚无的名气。我发现很多人都在为着名气而进行一些自己其实不感兴趣的事情，去做一些别人觉得“牛气”的事情。我真希望他们遇到跟我一样的好老师。</p><p style="margin:0px 0px 20px;padding:0px;">在现在看来，Knuth 的 TAOCP 真的是所谓的“神圣的白象”（white elephant）。很少有人真的看过，却要显得好像看过一样，并且很喜欢。这就让试图看懂它的人更加自卑和着急，甚至觉得自己智商有问题。别人都看过了，我怎么就看不懂呢？其实 TAOCP 里面的大部分算法都不是 Knuth 自己设计的，而且他对别人算法的解释经常把简单的问题搞得很复杂。再加上他执意要用汇编语言，又让程序的理解难度加倍。有一句名言说：“跟真正的大师学习，而不是跟他们的徒弟。”如果你真的要学一个算法，就应该直接去读那算法的发明者的论文，而不是转述过来的“二手知识”。二手的知识往往把发明者原来的动机和思路都给去掉了，只留下苍白无味的“最后结果”。</p><p style="margin:0px 0px 20px;padding:0px;">TeX 其实也是异常糟糕的设计。它过度的复杂，很少有人搞得懂怎么配置。经常为了一个简单的效果折腾很久，然后不久就忘了当时怎么做的，回头来又得重新折腾。原因就是因为 TeX 的设计没有“一致性”，不可以“compose”，所以你需要学太多东西，而不是学习几个简单的东西，然后把它们组合起来。在程序语言设计者看来，TeX 的语言是世界上最恶劣的设计之一。Knuth 的作品里面有他的贡献和价值，TeX 的排版算法（而不是语言）仍然是不错的东西。可是如果因为这些好东西爱屋及乌，而把他所推崇的那些乱七八糟的设计当成神圣的话，那你自己的设计就逃脱不出同样的思维模式，给用户造成很大的麻烦。仍然对 TeX 顶礼膜拜的人应该看一下 <a href="http://www.texmacs.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">TeXmacs</a>，看看它的作者是如何默默无闻的，彻彻底底的超越了 TeX 和 Knuth。</p>
Cornell
<p style="margin:0px 0px 20px;padding:0px;">可是权威和名气的威力还是很大的。虽然 Knuth 在我心目中的位置不再处于“垄断地位”，世界上可以占据我心里那个位置的人和事物还很多。在离开清华之后我申请了美国的大学。也许是天意也许是巧合，只有两所大学给了我 offer：Cornell 和 Indiana，而我竟然先后到了这两所大学就读。</p><p style="margin:0px 0px 20px;padding:0px;">说实话，Indiana 给了我比 Cornell 更好的 offer。Cornell 给我的是一个 TA 的半工读职位，而 Indiana 给我的是一个不需要工作白拿钱的 fellowship。说实话我从来没有搞明白 Cornell 这样的“牛校”怎么会给我这样的人 offer，GPA 一般，paper 很菜，而 Indiana 却是真正在乎我的。Indiana 的 fellowship 来自 GEB 的作者 Doug Hofstadter。他从 email 了解到我的处境和我渴求真知的愿望之后，毅然决定给我，一个素不相识的人写推荐信。后来我才发现，我的 fellowship 的资金也是他提供的。</p><p style="margin:0px 0px 20px;padding:0px;">可是 Indiana 和 Hofstadter 的名气哪里能跟 Cornell 的号称 “CS前五” 相比啊？Indiana 的 offer 晚来了几天。当收到 Indiana 的 offer 时，我已经接受了 Cornell。Hofstadter 很惊讶也很失望，因为他以为我一定会做他的学生，可是听说我接受了 Cornell 的 offer，他也不知道该怎么办。我只隐约的记得他告诉我，学校的排名并不是最重要的东西……</p><p style="margin:0px 0px 20px;padding:0px;">名气和权威的力量是如此之大，它让我不去选择真正欣赏我并且能给我真知的人。有时候回想起来，我当时真的是在寻找真知吗？我明白什么叫做真知吗？</p><p style="margin:0px 0px 20px;padding:0px;">Cornell 给了我什么呢？到现在想起来，它给我的东西恐怕只有教训，很多的教训。我在一篇老的博文里面提到过，Cornell 的学生一上课就抄笔记，一天到晚都在赶作业。可其实 Cornell 不只是爱抄笔记的学生的天堂，而且是崇拜权威者的天堂。即使你不是那么的崇拜权威，你不可避免的会被一群像朝圣者一样的人围在中间，在你耳边说某某人多么多么的牛。不管你向同学打听哪一个教授，得到的回答总是：“哇，他很牛的！” 然后你就去上了他的几节课，觉得不咋的嘛，可是人家就说那是因为你不理解他的价值。这种气氛我好像在另一个地方感觉到过呢？啊对了，那是在 Google。这样的气氛也许并不是偶然，Cornell 的大部分 PhD 同学当时的最大愿望，就是毕业后能去 Google 工作。当然，后来 Facebook 上升成为了他们的首选。</p><p style="margin:0px 0px 20px;padding:0px;">Cornell 的研究可以用“与时俱进”来形容，什么热门搞什么。当时 Facebook 和社交网络正在崛起，所以系里最热门的一个教授就是研究社交网络的。我去听过他几堂课，他用最容易的一些图论算法分析一些社交网络数据，然后得出一些“理论”。其中好些结论实在太显然了，我觉得根本不需要数据分析就能猜到，真是不觉得有什么特别的。可是 Facebook 名气之大，跟着这位教授必然有出路啦，再加上有人在耳边煽风点火，所以有好多的学生为做他的 PhD 挤破了头皮，被刷下来的就只好另投门路了。每次新来一个教授都会被吹捧上天，说是多么多么的聪明，甚至称为天才。然后就有一群的人去上他的课，试图做他的学生。结果人家每节课都是背对学生面朝黑板，写下一堆堆的公式和证明，一堂课总共就没回过几次头。还不如干脆打印出来让大家自己回家看。下面的人当然就是狂抄笔记，有的人甚至带着录音笔，生怕漏掉一句话。人多了竞争也就难免了。上课的同学们就开始勾心斗角，三国演义的战术都拿出来了。作业做不出来就来找你讨论，等你想讨论了就说自己也没做出来。没听懂偏要故作点头状，显得听懂了，让你觉得有压力。自己越是喜欢的教授就越是说他不咋的，扯淡，然后就自己去跟他。自己不喜欢的教授就告诉你他真是厉害啊，只可惜人家不要我。怎么感觉就跟皇帝的后宫差不多呢 ;-) 直到两年后我离开 Cornell 之前，还有好些同学因为没找到教授而焦头烂额。因为两年内没有找到导师的 PhD 学生，基本上等于必须退学。</p><p style="margin:0px 0px 20px;padding:0px;">当我离开 Cornell 之后，有一位国内的学生给我发 email 套磁（从系里主页上找到我的地址），问我 Cornell 情况如何。我告诉他我都已经走人了，并且告诉了他我的感觉，一天到晚抄笔记赶作业之类的。然后又问我一个刚毕业的 PhD 的情况，我说他水平不咋的，博士论文我看过了，很扯淡，解决一个根本不存在的问题。他对我说的话有点惊讶，但还是将信将疑。为了确保万无一失，他在 visiting day 的时候专程去 Cornell 考察了一下。回去又给我 email，说见到好多牛人啊，大开眼界，哪里像你说的那么不堪。还说跟那位 PhD 的导师谈过话，真是世界级的牛人那，他的博士论文也是世界一流的。我就无话可说了，仁者见仁，智者见智，随他去吧，哎。</p><p style="margin:0px 0px 20px;padding:0px;">结果两年之后，我又收到这位同学的 email，说他在 Cornell 还没找到导师，走投无路了，问我有没有办法转学。</p>
图灵奖
<p style="margin:0px 0px 20px;padding:0px;">说到这里应该有人会问这个问题，我是不是也属于那种没找到导师走投无路的人。答案是，对的，我确实没有在 Cornell 找到合适的导师。然后我就猜到有人会说，就知道王垠水平不行嘛，没搞定导师，被迫退学，哈哈！可是事情其实没他们想象的那么简单。作为一个 PhD 学生，不仅必须精通学术，而且要懂得政治和行情。可是由于学生之间的勾心斗角，他们之间的信息互通程度，是没法和教授之间的信息互通程度相比的。这就造成了“学生阶级”在这场信息战上的劣势。</p><p style="margin:0px 0px 20px;padding:0px;">进入 Cornell 之后我上了一门程序语言的课，就开始对这些东西入迷。可是由于“与时俱进”，Cornell 的研究方向并不是那么平衡的发展的，程序语言领域的专家们早已因为受到忽视而转移阵地，剩下一群用纸和笔做扯淡理论的。说实话，在历史上程序语言方向曾经是 Cornell 的强项，出现了一些很厉害的成果。可是当我在 Cornell 的时候，只剩下两个名不见经传的教员，一个助理教授，一个副教授。其实 Robert Constable 也在那里，可惜的是他做了 dean 之后已经没空理学生了，以至于我两年之后都不知道这个人的存在。我当时也不知道 Cornell 有过这段历史，看不到它的研究重心的移动趋势。我不喜欢那个副教授搞的项目，全是在 Java 上面加上一些函数式语言早就有的功能。可是人家做的热门语言，所以拉得到资金，备受系里亲睐，他的学生们也比较趾高气昂。有一次我跟他的一个学生说了我的一个想法，他说：“你那也能叫研究吗？待会儿我给你看看什么是真正的研究！” 其实那只是我的一个微不足道的想法，我也没说那是真正的研究啊，只是随便聊一下而已。我是不可能跟那样的人合作的，所以我就跟那个助理教授做了一点静态分析的项目。当然我们分析的也不是什么好东西，是用 Fortran 写的 MPI 程序。说实话，那个助理教授其实挺有点真知灼见，他有几句话现在仍然在指引我，防止我误入歧途。他也是很谦虚很好的人，可是好人不一定有好报的。后来他没有拿到 tenure 职位，不得不离开 Cornell 加入了工业界，而我就失去了最后一个有可能在程序语言方向做我的导师的人。</p><p style="margin:0px 0px 20px;padding:0px;">没办法，我就开始探索其它相关领域的教授，比如做数据库的，做系统的，看他们对相关的语言设计是否感兴趣。可惜他们都不感兴趣，而且告诉我程序语言领域太狭窄了。我当时还将信将疑，甚至附和他们的说法，可是现在我断定他们都是一知半解胡说八道。如果他们虚心向程序语言专家请教，现在数据库和操作系统的设计也不会那么垃圾，关系式，SQL，NoSQL，…… 一个比一个扯淡。没有办法，我就开始探索其他的方向，我开始了解图形学和数值分析等东西，进展很不错。可是终究我还是发现，我不喜欢图形学和数值分析所用的语言。我想制造出更好的程序语言来解决这些问题。而教授们也能感觉到你不是真的感兴趣，而且他们貌似不喜欢有不同想法的学生，从而会优先考虑对他的东西更加欣赏的学生。</p><p style="margin:0px 0px 20px;padding:0px;">这就让我走到了跟那位向我打听 Cornell 情况的同学差不多的局面，真是心里有无限的苦却没有人可以理解。这时候我想到了系里的一些德高望重的教授，比如得过图灵奖的人，也许这些顶级的大牛会给我指出方向。于是我就联系到一位图灵奖得主，说想找他聊聊。我说我感兴趣的东西 Cornell 貌似并不重视和发展。Cornell 的校训是“any person, any study”，而我却找不到我想 study 的东西。最后我谈了一下我对 Cornell 的总体感受。我说我觉得大家上课都是死记硬背，不是很 intellectual，我不是很确定学术界是否还保留有它原来的智慧和对真知的向往。</p><p style="margin:0px 0px 20px;padding:0px;">我真的是很诚恳的告诉了他这些，只是希望得到一些建议。结果他立马开始用质问的语气问我，你成绩怎么样？考试都通过了没有？哎，说白了就是想搞清楚你是不是成绩不好没人要。怎么就跟高中教导主任一样。于是乎那次谈话就这样不了了之。可是没有想到，这次谈话就造成了我最后的离别。在学生们互相之间勾心斗角，不通信息的同时，系里的教授们其实背后都是“通气”的。他们根本不懂得如何教学，就知道拿作业和考试往学生头上砸，幸存下来的就各自挑去做徒弟，挨不住的就打发掉。这算盘打得真是妙啊。我也不知道他们是什么机制，每个学生对哪些教授感兴趣，他们貌似都了如指掌。然后系里的教授们不知道怎么的，仿佛就都知道有这样一个不知趣的学生，居然敢说学术界的坏话！</p><p style="margin:0px 0px 20px;padding:0px;">大地震前夕的天空总是异常的美。我竟然在过道里看到那位图灵奖教授对我点头致意并且微笑，以前做 TA 时把我呼来唤去还横竖不满意的教授也对我笑脸相迎。我仿佛觉得，我推心置腹的一席话打动了那位德高望重的教授，再加上在图形学和数值计算的扎实进展，给我的学术生涯带来了转机。可是，我那一次真正的领悟了什么叫做所谓的“笑里藏刀”。</p><p style="margin:0px 0px 20px;padding:0px;">由于那个学期上的图形学还有矩阵计算的课成绩都不错，我心想应该能找这两个教授其中一个做导师吧。再加上那些貌似友好的笑容…… 所以没想很多，居然过了一个非常快乐的寒假。没有任何前兆，没有任何直接的通知（email，电话），一封纸信不知道是什么时候默默地进到了我在系里的，基本上从来不看的信夹子里，直到下一个学期开始的时候（2月份）我才发现。信是系主任写的，大概就是说，由于你的表现，我们觉得 Cornell 不是适合你的地方……</p><p style="margin:0px 0px 20px;padding:0px;">我本来就有想走的意思，可就是喜欢呆在一个地方懒得动。如果你们早一点告诉我这个，我还可以申请转学到其它学校。可是都 2 月份了才收到这样的东西，Cornell 啊 Cornell，你让我现在怎么办？我想我可以说你不仁不义吧？</p><p style="margin:0px 0px 20px;padding:0px;">在这个走投无路的时候，我想起了曾经关心过我却又很失望的 Hofstadter 教授。我厚着脸皮告诉他我在 Cornell 很不开心，我很后悔没有认真地考虑过 Indiana。我很想研究程序语言，可是 Cornell 不在乎这个领域。他回信说，没有关系，你能找到自己喜欢的东西就应该去追寻它，这次不要再冲着名气做决定好吗。Indiana 的 Dan Friedman 就是做程序语言的，你可以联系他，就说是我介绍你去的。</p><p style="margin:0px 0px 20px;padding:0px;">于是给 Friedman 发了 email，很快得到了回信说：“王垠，两年前我们都看过你的材料。我们觉得你是一个非常出众的学生。可惜你最后没有选择我们。你要明白，人生最重要的事情不是名利，而是找到你愿意合作的人。你的材料都还在我们这里。现在招生已经快结束了，但是我会把你的材料提交给招生委员会，让他们破例再次考虑你的申请。” 我和 <a href="http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Dan Friedman 的故事</a>就从这里开始了。</p>
常青藤联盟和“世界一流大学”
<p style="margin:0px 0px 20px;padding:0px;">我在 Cornell 的经历应该不是偶然，不是因为我比较特殊。跟我同时进入 Cornell 的博士生有好几个几年后没有拿学位就离开了。其中有一个是非常聪明的，我根本听不懂的理论课他还能拿A，可是四年后退学去了 Facebook。有些本科生也告诉我类似的经历，说被系里某些教授“整了”。Cornell 的自杀率居美国大学前列。我走了以后有一次一周之类有三个学生从瀑布旁边的那座桥跳下去。我觉得自己在 Cornell 所感受到的压力确实超乎想象，是有可能把人逼上绝路的。现在回想起来真是可笑，因为对权威和名气的下意识的崇拜，我给了一群根本没有资格来教育我的人向我施加无端压力的权力。</p><p style="margin:0px 0px 20px;padding:0px;">我应该指出，这种现象应该不是 Cornell 所特有的。我对清华，还有 Princeton，Harvard，MIT，Stanford，Berkeley，CMU 等学校的学生都有了解。这些所谓的“世界一流大学”或者“世界一流大学 wannabee”差不多都是类似的气氛。你冲着它们的名气和“关系网”挤破了头皮进去，然后就每天有人在你耳边对其它某些人感叹：哇，他好牛啊！发了好多 paper，还得了XX奖。跟参加传销大会似的，让你感觉个人的价值被完全的忽视。然后就是填鸭式的教育，无止境的作业和考试，让你感觉他们不是在“教育”你，而是在“筛选”你。这种筛选总是筛掉最差的，但也筛掉最好的，因为最好的学生能意识到你在干什么，他们不给你筛选他们的机会。所以剩下来的就是最一般的，循规蹈矩听话的。在这样的环境里，你感觉不到真正的智慧和真知的存在。GRE 考试所鼓吹的什么“批判性思维”（critical thinking ）在美国大学里其实是相当缺乏的。学生们只不过是在被培训成为某些其他人的工具，他们具有固定的思维定势，而不是真正的创造者和开拓者。</p><p style="margin:0px 0px 20px;padding:0px;">人们在这些大学里的时候都是差不多感受的，可是一旦他们出来了，就会对此绝口不提。自己身上挂着这些学校的镀金牌子，怎么能砸了自己的品牌，长别人的威风？所以每当我批判 Cornell 就有些以前的同学一脸的着急相，好像自己没有吃过那苦头一样。</p>
再见了，权威们
<p style="margin:0px 0px 20px;padding:0px;">亲爱的同胞们，如果你们觉得有了可以在背后说王垠“被Cornell 退学”的机会，那么你们就错了。我之所以可以告诉你们这些貌似不可告人的故事，是因为你们可能也会经历这些事情。对权威和名校的崇拜，让你们成为了被“教授阶级”摆布的傀儡和他们在学术战场上的牺牲品。我很幸运的遇到了像 Hofstadter 和 Friedman 这样的好人，而你们也许就没有这么幸运。</p><p style="margin:0px 0px 20px;padding:0px;">几经颠簸的求学生涯，让我获得了异常强大的力量。我的力量不仅来自于 Friedman，Dybvig 等教授的教诲，而且在于我自己不懈的追求。机会只亲睐有准备的头脑，并不是每个 Friedman 的学生都可以像我一样在一个星期之内解决十多年才完成的研究，完全独立的进行思考。我可以说，这个领域在过去一个世纪的研究很少有逃脱过我的洞察力和直觉的。我看到一个东西一般很快就会知道它到底会不会管用，我经常发现一些被认为很牛的设计其实是在解决一个根本不存在的问题，而真正的问题却没有得到有效的解决。这里面很大程度上是历史上权威的阴影造成的，它让人们不敢否认这些大牛作品的价值，不敢抛弃它们，所以他们很多的时间花在了解决历史遗留问题，而不是真正的问题。这就是为什么我的<a href="http://yinwang0.wordpress.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">英文blog</a>标题叫做“Surely I Am Joking”，因为它记录了我为什么认为一些问题是根本不存在的，或者是人为造成的。</p><p style="margin:0px 0px 20px;padding:0px;">曾经 Knuth 是我心中唯一的权威。后来我又屈服于 Cornell 和常青藤联盟的权威和名气。我因为图灵的威名而误以为图灵奖得主都是德高望重的前辈。应该说，在 Indiana 的日子里，权威主义的影子也是经常出现的。Indiana 学生们的权威比较特殊一点，不然就是 Dan Friedman，不然就是 Kent Dybvig，不然就是 Tony Hoare 之类的。所以你有时据理力争的时候就会听到人这样跟你辩论：“Kent 说……” 不管你说什么，他们都想抬出一个明星来压倒你。我很尊敬 Friedman 和 Dybvig，但我也看到他们的一些思维方式并不是那么的正确，我从来不引用他们的话作为理论依据。我也不喜欢 Indiana 同学们的这种崇拜权威的行为。</p><p style="margin:0px 0px 20px;padding:0px;">在一而再再而三的上当受骗之后，我终于把所有的权威们从我的脑子里轰了下去。这些权威包括所有大学的所有教授，所有的图灵奖得主，Unix 和类似操作系统的设计者，所有的程序语言设计者，图灵，他的导师邱奇，他的师兄 Kleene，被程序语言研究者奉为权威的逻辑学家们比如 Per Martin Lof，各大IT界“牛公司”，美国国防部，美国宇航局，…… 我现在的实力其实超越了 Cornell 和其他任何“牛校”的教授。我的学识不再接受学术界和任何人的评价。我们完全处于平起平坐的低位。如果你觉得你心目中的超级偶像在我之上的话，请先问问我对他们的博士论文或者图灵奖作品有何评价 :-)</p><p style="margin:0px 0px 20px;padding:0px;">不再是我心目中的权威并不等于我鄙视他们或者不尊敬他们。他们在我的脑子里失去的只是他们在很多其他人脑子里的那种被膜拜的地位，那种你可以用“XX人说过……”来压倒理性分析的地位。现在他们在我心目中是一群普通的，有血有肉，有好心肠或者坏心眼的，高傲，谦虚或者虚伪的人。他们设计的东西，好的地方我可以借鉴，但是没有任何人的东西我是不加批判全盘接受的。我深深地知道接受错误的想法的危害性，所以我也希望大家都具有批判的思维，不要盲目的接受我说的话。我不喜欢“大神”或者“牛人”这种称呼。</p><p style="margin:0px 0px 20px;padding:0px;">最后我希望国内的同学们，不要盲目的崇拜国外的所谓“大师”，“牛校”或者“牛公司”。祝你们早日消灭掉心里的各种权威以及对他们的畏惧心理，认识到自己的价值和力量。</p><p style="margin:0px 0px 20px;padding:0px;">新年快乐！</p></div></div></div></div></div></div></div></div><span style="font-size: 12px; line-height: 200%; color: rgb(2, 2, 2); text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="862"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c563b" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Yoda 表示法错在哪里</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在上一篇<a href="http://www.yinwang.org/blog-cn/2013/04/14/terminology/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>里，我提到了 Yoda 表示法。</p>Yoda Notation（Yoda 表示法）<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/yoda-notation.jpeg" type="image/jpeg" height="169" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="298"/></p><p style="margin:0px 0px 20px;padding:0px;">它的含义是，在 C/C++ 里面使用这样的表达式顺序：</p>if (&quot;blue&quot; == theSky) ...<p style="margin:0px 0px 20px;padding:0px;">这是为了避免意外的写成：</p>if (theSky = &quot;blue&quot;) ...<p style="margin:0px 0px 20px;padding:0px;">“Yoda 表示法”的名字来源于《星球大战》的 Yoda 大师。他说话的单词顺序相当奇特，比如：“Backwards it is, yes!”</p>一般认为<blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">使用这个表示法是为了“变通”（workaround） C/C++ 的一个设计抉择：使用 =来表示赋值，而使用 == 来表示比较。这个设计充分的展现了“先辈的罪”（Sins of our Forefathers）这一词汇的精髓。</p></blockquote>我认为<blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">使用 = 来表示赋值其实并不是真正的错误所在。真正的错误在于 C/C++ 的赋值语句不应该返回一个值。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">也就是说，theSky = &quot;blue&quot; 的所有功能应该只是“赋值”这种“副作用”，副作用不应该具有“值”。即使你牵强附会说它有一个值，它的“值”也应该是 void（随之这个void 会被类型检查所拒绝，因为它不是 if 所期望的 bool）。所以，一个良好的语言不应该允许你把 theSky = &quot;blue&quot; 放进 if (...) 的“条件”里面。如果你真的要赋值又要判断，它会迫使你把这拆开成两行：</p>theSky = &quot;blue&quot;;if (theSky) ...<p style="margin:0px 0px 20px;padding:0px;">更近一步。if (theSky) 这个写法其实也是一个先辈的罪。theSky 的类型是 string，它不应该可以直接被作为 bool 使用。if (...) 的条件应该必须是一个 bool。 所以这里其实应该写成：</p>theSky = &quot;blue&quot;;if (theSky != NULL) ...<p style="margin:0px 0px 20px;padding:0px;">因为赋值语句永远不可能出现在条件的位置，所以之前的那种错误，即使我们使用 = 作为赋值操作符，也完全不可能出现。这样我们也就完全没必要用 Yoda 表示法了。</p><p style="margin:0px 0px 20px;padding:0px;">相反，如果我们只是把 = 换成像 Pascal 的 := 这样的赋值操作符，而保留其它的“特性”（赋值操作会返回值）的话，我们其实还是会遇到同样的问题：</p>if (theSky := &quot;blue&quot;) ...<p style="margin:0px 0px 20px;padding:0px;">这里假设你想打 =，却不小心打成了 :=。机会虽然小，但是仍然有可能。而我推荐的解决方案，会让你故意想犯错误都不可能，编译器会拒绝接受你的程序。</p><p style="margin:0px 0px 20px;padding:0px;">所以你看到了，问题的根源其实不在于赋值操作的名字，而是有更深的原因。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="864"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_b18f1f" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">PySonar2 与 Sourcegraph 集成完毕</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">来到 Sourcegraph 两个星期了，我可以说这里的每一天都是激动人心的，这是一个有真正创造活力的 startup。我们的发展速度相当之快，每一天都出现新的点子，或者发现以前做法的一些大幅度简化。不得不承认 Quinn 和 Beyang 是比我有魄力的人。我虽然做出了 PySonar，却让它的代码束之高阁多年之久，没有发挥出应有的作用。是 Quinn 和 Beyang 坚持不懈地做出了 <a href="http://www.sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Sourcegraph.com</a> 这个网站，才使 PySonar 可以发挥出这么强劲的效果，用以搜索全世界的 Python 代码，为广大程序员造福。当然，我们的目标不只限于 Python。Sourcegraph 目前支持 Go, JavaScript, Python 和 Ruby。其中 Ruby 的支持还处于初步阶段，需要改善，更多其它的语言正在开发中。</p> 
<p style="margin:0px 0px 20px;padding:0px;">经过两个星期的勤奋却又不知疲倦的工作，PySonar2 今天正式与 <a href="http://www.sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Sourcegraph.com</a> 集成完毕。现在只要登录 Sourcegraph 主网站，就可以看到开源 Python 代码的 PySonar2 分析结果。</p> 
<p style="margin:0px 0px 20px;padding:0px;">PySonar2 的类型推导系统能够不依赖类型标记却精确地分析出 Python 函数的参数类型。比如下图所示的 Flask 框架的最常用的五个函数的参数，都是通常的方法很难确定类型的，PySonar2 却能得知它们的正确用法。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://sourcegraph.com/github.com/mitsuhiko/flask" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/pysonar2-sg-flask.png" type="image/png" height="560" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;">最有意思的是那个 render_template。PySonar2 为它推导出来的类型是一个 intersection type：</p>templating.render_template(template_name_or_list, **context)str -&gt; ?| [str] -&gt; ? 
<p style="margin:0px 0px 20px;padding:0px;">这是说，第一个参数 template_name_or_list 的类型或者是 str 或者是 [str]（含有 str 的 list）。如果你给它 str 它就会输出 ? （PySonar2 不知道它会输出什么）。如果你给它 [str]，它输出 ?.</p> 
<p style="margin:0px 0px 20px;padding:0px;">如果你注意一下这个参数的英文含义 &quot;template name or list&quot;，就会觉得仿佛 PySonar2 能读懂英语一样。然而 PySonar2 其实不会英语，它只会 Python。它通过代码之间的调用关系和异常强大的类型推导，找到了这个参数的类型。</p>Sourcegraph 的一些使用诀窍 
<p style="margin:0px 0px 20px;padding:0px;">Sourcegraph 有一些不为人知的巧妙设计，但是由于 Quinn 和 Beyang 太谦虚而且太忙了，所以都没来的及宣传。我现在在这里透露两招小窍门。</p>启动分析你需要的代码库 
<p style="margin:0px 0px 20px;padding:0px;">如果在 Sourcegraph 网站上面没有找到你需要的代码库，这不等于你需要等我们来启动分析。你可以自己动手！</p> 
<p style="margin:0px 0px 20px;padding:0px;"><span>方法很简单：把你的 GitHub 地址去掉 <a href="http://xn--http-9j5fi0surdzs1c//sourcegraph.com/" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">http://之后放到http://sourcegraph.com/</a> 后面，然后 Sourcegraph 就会显示一个等待页面，同时自动开始分析这个 repo，一般大小的代码库几分钟到半个小时就会处理完毕。目前支持的语言是 Go, JavaScript, Python, Ruby（更多的语言会陆续加入）。</span></p> 
<p style="margin:0px 0px 20px;padding:0px;"><span>举个例子，如果你想分析 <a href="http://github.com/myname/myrepo" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">http://github.com/myname/myrepo</a> 的代码，就在浏览器输入地址：</span></p><span><a href="http://sourcegraph.com/github.com/myname/myrepo" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">http://sourcegraph.com/github.com/myname/myrepo</a> 
</span><p style="margin:0px 0px 20px;padding:0px;">如果 Sourcegraph 还没有分析过这个 repo 它就会把它加入到工作队列里，然后你可以做其他的事情或者浏览其他的代码。分析完毕之后浏览器就会自动跳转到你所需要的代码库。</p>在你的 GitHub README 里面使用 Sourcegraph 徽章 
<p style="margin:0px 0px 20px;padding:0px;">你也许发现有些人在自己的 GitHub 里有 Sourcegraph 徽章，这样一来别人就能得知你的代码库的一些统计信息。比如我的 psydiff 的 README 里面有这样一个：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="http://github.com/yinwang0/psydiff" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/psydiff-badge.png" type="image/png" height="346" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="648"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;">它表示 psydiff 的代码被看过的次数。你也可以使用其他的一些徽章，比如最常用的函数，交叉引用数，用户数，等等：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://sourcegraph.com/github.com/yinwang0/psydiff/badges" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/sg-badges.png" type="image/png" height="422" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="332"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;">要得到这些徽章很简单，只要在你的 repo 的 Sourcegraph 主页里点击如图所示的扳手状小图标，然后把 &quot;Image URL&quot; 拷贝到你的网页里就行：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://sourcegraph.com/github.com/yinwang0/psydiff/badges" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/sg-settings.png" type="image/png" height="190" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="566"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://sourcegraph.com/github.com/yinwang0/psydiff/badges" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/badge-image-url.png" type="image/png" height="333" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;"><span>Sourcegraph <a href="http://yinwang0.lofter.com/post/183ec2_b18f1fmailto:%E7%9A%84%E5%8A%9F%E8%83%BD%E8%99%BD%E7%84%B6%E9%9D%9E%E5%B8%B8%E5%BC%BA%E5%8A%B2%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BE%88%E5%A4%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%98%E5%A4%84%E4%BA%8E%E8%B5%B7%E6%AD%A5%E9%98%B6%E6%AE%B5%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E6%88%96%E8%80%85%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E8%AF%B7%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC%EF%BC%9Ahi@sourcegraph.com." style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">的功能虽然非常强劲，但是很多设计的工作还处于起步阶段。如果你有什么建议或者发现问题，请联系我们：hi@sourcegraph.com.</a></span></p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="870"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><a href="http://yinwang0.lofter.com/post/183ec2_d60965" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">程序语言与它们的工具</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">　作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">程序语言与它们的工具</p><p style="margin:0px 0px 20px;padding:0px;">谈论了这么多程序语言的事情，说得好像语言的好坏就是选择它们的决定性因素。然而我一直没有提到的一个问题是，“程序语言”和“程序语言工具”的设计，其实完全是两码事。一个优秀的程序语言，有可能由于设计者的忽视或者时间短缺，没有提供良好的辅助工具。而一个不怎么好的程序语言，由于用的人多了，往往就会有人花大力气给它设计工具，结果大大的提高了易用性和程序员的生产力。我曾经提到，程序语言其实不是工具，它们是像木头，钉子，胶水一样的材料。如果有公司做出非常好的胶水，粘性极强，但它的包装不好，一打开就到处乱跑，弄得一团糟。你是愿意买这样的胶水还是稍微差一点但粘性足够，包装设计合理，容易涂抹，容易存储的呢？我想大部分人会选择后者，除非后者的粘性实在太弱，那样的话包装再好都白搭。</p><p style="margin:0px 0px 20px;padding:0px;">这就是为什么虽然我这么欣赏 Scheme，却没有用 Scheme 或者 Racket 来构造 PySonar 和 RubySonar，甚至没有选择 Scala 和 Clojure，而是“臭名昭著”的 Java。这不只是因为 PySonar 最初的代码由于项目原因是用 Java 写的，而且因为 Java 正好有足够的表达能力，可以实现这样的系统，但是最重要的其实是，Java 的工具非常成熟和迅捷。很难想象如果缺少了 Eclipse 我还能在三个月内做出像 PySonar 那样的东西。而现在我只用了一个月就做出了 RubySonar，其中很大的功劳在于 IntelliJ。这些 IDE 的跳转功能，让我可以在代码中自由穿梭。而它们的 refactor 功能，让我不必再为变量的命名而烦恼，因为只要临时起个不重复的名字就行，以后改起来小菜一碟。另外我还经常使用这些 IDE 里面的 debugger，利用它们我可以很方便的找到 bug 的起因。PySonar2 在有一段时间变得很慢，看不出是哪里出了问题。最后我下载了一个 JProfiler 试用版，很快就发现了问题的所在。如果这问题出现在 Scheme 代码里面，恐怕就要费很多功夫才能找到，因为 Scheme 没有像 JProfiler 那样的工具。</p><p style="margin:0px 0px 20px;padding:0px;">但这并不等于说学习 Scheme 是没有用处的。恰恰相反，Scheme 的知识在任何时候都是非常有用的。一个只学过 Java 的程序员基本上是不可能写出我那样的 Java 代码的。虽然那看起来是 Java，但是其实 Scheme 的灵魂已经融入到其中了。我从 Scheme 学到的知识不但让我知道 Java 可以怎么用，而且让我知道 Java 本身是如何被造出来的。我知道 Java 哪些地方是好的，哪些地方是不好的，从而能够择其善而避其不善。我的代码没有用任何的“Java 设计模式”，也没有转弯抹角的重载。</p><p style="margin:0px 0px 20px;padding:0px;">其实我有空的时候在设计和实现自己的语言（由于缺乏想象力，暂命名为 Yin），它的实现语言也在最近换成了 Java。Yin 的语法接近于 Scheme，好像理所当然应该用 Scheme 或者 Racket 来实现。有些人可能已经看到了我 GitHub 上面的第一个 prototype 实现（项目已经进入私密状态）用的是 Typed Racket。Racket 在很大程度上是比 Java 好的语言，然而它却有一个让我非常恼火的问题，以至于最后我怀疑自己能否用它顺利实现自己的语言。</p><p style="margin:0px 0px 20px;padding:0px;">这个问题就是，当运行出现错误的时候，Racket 不告诉我出错代码的具体行号，甚至出错的原因都不说清楚。我经常看到这样一些出错信息：</p>
“函数调用参数个数错误”“变量 a 没有定义，位于 loop 处”
<p style="margin:0px 0px 20px;padding:0px;">只说是函数调用，函数叫什么名字不说。只说是 loop，文件里那么多 loop，到底是哪一个不知道。出错信息里面往往有很多别的垃圾信息，把你指向 Racket 系统里面的某一个文件。有时候把代码拷贝进 DrRacket 才能找到位置，可是很多时候甚至 DrRacket 都不行。每当遇到这些就让我思路被打断很长时间，导致代码质量的下降。</p><p style="margin:0px 0px 20px;padding:0px;">其它的 Scheme 实现也有类似的问题，像 Petite Chez 这样的就更加严重，只有商业版的 Chez Scheme 会好一些，所以这里不只是小小的批评一下。这种对工具设计的不在意心理，在 Lisp 和 Scheme 等函数式语言的社区里非常普遍。每当有人抱怨它们出错信息混乱，没有 debugger，没有基本的静态检查，铁杆 Schemer 们就会鄙视你说：“Aziz 说得好，我从来不 debug，因为我从来不写 bug。”“函数式语言编程跟普通语言不一样。你要先把小块的代码调试好了，问题都找到了，再组合起来。”“当程序有问题却找不到在哪里的时候，说明我思路混乱，我就把它重写一遍……”我很无语，天才就是这样被传说出来的 :)</p><p style="margin:0px 0px 20px;padding:0px;">除了由于高傲，Scheme 不提供出错位置的另外一个重要原因，其实是因为它的宏系统。由于 Scheme 的核心非常小，被设计为可以扩展成各种不同的语言，所以绝大部分的代码其实是由宏展开而成的。而由于 Scheme 的宏可以包含非常复杂的代码变换（比 C 语言的宏要强大许多），如果被展开的代码出了问题，是很难回溯找到程序员自己写的那块代码的。即使找到了也很难说清楚那块代码本来是什么东西，因为编译器看到的只是经过宏展开后的代码。如果实现者为了图简单没有把原来的位置信息存起来，那就完全没有办法找到了。这问题有点像有些 C++ 编译器给模板代码的出错信息。</p><p style="margin:0px 0px 20px;padding:0px;">所以出现这样的问题，不仅仅是语言设计者的心态问题，而且是语言自己的设计问题。我觉得 Lisp 的宏系统其实是一个多余的东西，带来的麻烦多于好处。一个语言应该是拿来用的，而不是拿来扩展的。如果连最基本的报错信息都因此不能准确定位，扩展能力再强又有什么意义呢？所以强调一个语言可以扩展甚至变成另外一种语言，其实是过度抽象。一个设计良好的语言应该基本上不需要宏系统，所以 Yin 语言的语法虽然像 Lisp，但我不会提供任何宏的能力。而且由于以上的经历，Yin 语言从一开头就为方便工具的设计做出了努力。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="875"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_60e883" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">程序语言理论的学习对于程序员教育的作用</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">推荐 Dan Friedman 的这篇文章 “<a href="http://www.cs.indiana.edu/~dfried/dfried/dfried/mex.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">The Role of the Study of Programming Languages in the Education of a Programmer</a>”。它介绍的是对<strong style="font-style:normal;font-weight:bold;font-size:100%;">程序语言理论</strong>的学习会对程序员的教育产生什么样的作用。这是一篇很长的英语文章，到后面会非常技术性，所以一般人只需要看前10页的小故事就行了。</p><p style="margin:0px 0px 20px;padding:0px;">其中的几个要点是：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">在一个实际的工程项目中，当需要数据库的时候，人们召唤数据库专家；当需要网络方案的时候，人们召唤网络专家；当需要操作系统的时候，人们召唤操作系统专家。但是所有这些事情都离不开的一个东西是程序语言，所以程序语言专家往往能够起到总览全局的构架和协调作用。但是人们往往不知道程序语言专家是什么，以及如何找到他们。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">这里的 &quot;study of programming languages&quot; 并不是指学习某一种特定的程序语言（比如 C, Java 或者 Scheme），而是指学习如何<strong style="font-style:normal;font-weight:bold;font-size:100%;">实现</strong>程序语言的一些概念，也就是写一些解释器。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">学习任何知识的最好方法，就是对它进行<strong style="font-style:normal;font-weight:bold;font-size:100%;">建模</strong>。所以学习程序语言最好的办法，就是实现程序语言。对于普通的程序员（不打算成为程序语言专家的），这不需要特别专业高效的实现，一个大概的实现也行。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">这样的学习能够让人掌握编程语言的一些“精髓”(essentials)。之后学用一种新的语言，不过是把这些已经学到的精髓筛选组合一下。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">Friedman 指出，对程序语言理论的学习最重要的两个作用是：1)它教会你如何避免程序语言中的不好的思想。2)它教会你如何在任何语言里使用好的思想（包括本身没有这种好的设计的语言）。文中提到的例子包括动态作用域 (dynamic scoping)，Java 的缺少尾递归优化等为什么是坏主意，以及为什么程序语言的理论知识可以教会你如何在没法改变语言的情况下绕过这些问题，达到好的设计。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">这个文章里面提到的人 Jon Rossie 和 Anurag Mendhekar 都是 Friedman 的学生。他们用亲身经历讲述程序语言的理论知识如何在他们的现实工程中起到重大的作用。Jon Rossie 现在是 Cisco 的 Principle Engineer。Anurag Mendhekar 是 Online Anywhere 的总设计师和创始人，后来被 Yahoo! 收购，现在是另一家公司的 CEO。Friedman 还有很多其他学术后裔都在世界上最好的工作职位。比如 Google 的 V8 JavaScript 编译器的构架师，Cython 的设计师，Cisco 的另一个 Principle Engineer，还有一些是创业家，终身教授等等。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">This article was posted on yinwang's sina blog, on 2012-06-13. Though it's not available now.</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="881"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_6ea2de" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">“One语言”是不存在的</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">昨天心血来潮，把我对一种“终极语言”的很多方面想法记录了下来。然而事后我却发现挺多矛盾的地方，现在我已经很难想象这样的语言能够成为“唯一”的程序语言。对人脑的工作原理也纯属我自己的臆测，没有经过任何科学实验的检验。</p><p style="margin:0px 0px 20px;padding:0px;">我是一个很矛盾的人，我怀疑别人，也怀疑自己。有时候想通了的问题，后来却又忘记了。其实很早的时候，我想出了一个很“哲学”理由，说明为什么一种语言是不足以满足所有人的需要的。可是不知道怎么到后来又推翻了自己，写出了为什么世界上只需要一种语言的理由。</p><p style="margin:0px 0px 20px;padding:0px;">那么现在我就来回顾一下我之前的想法，为什么一种语言是永远不够用的。</p><p style="margin:0px 0px 20px;padding:0px;">我们都知道，程序语言里包含了变量，数字，对象，函数等“元素”。它们就像物理学的<a href="http://en.wikipedia.org/wiki/Elementary_particle" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">基本粒子</a>一样，可以用于构造我们所需要的几乎任何“模型”。既然所有的东西都是用基本粒子组成的，那么除了物理学，我们为什么还要有化学和生物？化学家使用的语言是化学元素，它们比基本粒子大很多。生物学家的语言就更大一些了，处于细胞的级别。那么为什么化学家和生物学家不使用基本粒子来描述他们的领域呢？</p><p style="margin:0px 0px 20px;padding:0px;">那是因为基本粒子无法提供足够的“抽象”。它们到底是如何组成原子，原子又如何能产生细胞，这些事情到现在还没搞清楚。用基本粒子来表示化学和生物学，那么我们恐怕要等很久很久以后才能描述化学和生物的现象和原理。</p><p style="margin:0px 0px 20px;padding:0px;">同样的，变量，数字，对象，函数等语言的要素。也是不足以表达我们需要的所有程序的。有人认为函数是这些元素的“终极粘合剂”，可是函数的结构组合能力却不是万能的。函数接受一些参数，返回一个结果。然而有些我们需要表达的概念却不是这样的结构，比如一个带有多根电线的黑匣子，它可以从任何电线输入东西，然后从剩下的电线输出。每根电线的输入和输出方式，在不同的“调用”可以随意的更改。比如，电线 A 第一次被调用是输入，第二次被调用就变成了输出。</p><p style="margin:0px 0px 20px;padding:0px;">这个黑匣子就是逻辑语言（比如 Prolog，miniKanren）的基本元素。你如何用函数来表示它呢？你不能。因为不管你怎么把函数组合起来，这个黑匣子的电线不是连接到函数的输入，就是连接到输出。所以它们总是有“固定”的方向，不能满足这种奇怪的黑匣子的工作方式。</p><p style="margin:0px 0px 20px;padding:0px;">所以一旦出现了这种东西，我们就需要为语言加入新的元素。这个元素可以用更加基本的元素（比如变量等）组成，然而函数却不能作为这里的粘合剂。这个结构必须经过一个更加剧烈的转化，才能实现我们想要的功能。</p><p style="margin:0px 0px 20px;padding:0px;">在这种情况下，我们可以写一个解释器，用来描述这个黑匣子的工作方式。黑匣子被作为一个普通的数据结构，输入解释器，然后我们从解释器得到它的结果。这貌似是万能的方式。</p><p style="margin:0px 0px 20px;padding:0px;">另外一种万能的方式是使用宏（macro）。宏可以把这个黑匣子的“语言描述”（也就是AST）拆散，然后组成一个用原来的语言元素组成的结构，并且把它插入到原来的程序里面。这就相当于把黑匣子“编译”成了我们已有的语言，然后“嵌入”。比如对于逻辑语言的黑匣子，当我们在调用它的时候，宏就会知道它的输入和输出的“方向”。一旦知道了这个方向，它的行为方式就会像一个函数，所以我们就可以以此把它编译成函数。在下一个调用的地方，输入输出的方向又有不同，所以就把它编译成另外一个函数。</p><p style="margin:0px 0px 20px;padding:0px;">所以，每一个宏其实就是一个编译器。你可以用 Lisp/Scheme 的宏来实现几乎任何语言结构。这种“嵌入式语言”通常被叫做 EDSL (Embedded Domain Specific Language)。</p><p style="margin:0px 0px 20px;padding:0px;">有些其它语言也提供一些构建 EDSL 的能力，比如 Haskell, Scala 等。然而它们构建 EDSL 的能力，却不能达到 Lisp/Scheme 宏的地步。它们往往使用“重载”的方式来定义一些操作符，比如&quot;+&quot;号，然后把这些操作符作用于这个 EDSL 的 AST 所特有的类型，从而让操作符“自动切换”到这个 EDSL 的语义。</p><p style="margin:0px 0px 20px;padding:0px;">Haskell 有一个 EDSL 叫 Accelerate 就是这样实现的，它使用 type class 来重载操作符，用于 GPU 的操作。然而我却发现使用它的时候，有时候我必须打进一些莫名其妙的，跟我想要表达的概念毫无关系东西。这是因为重载的能力是有限的，它并不能像宏一样，可以任意的拆解和拼装整个表达式。所以 Accelerate 在很多时候需要你写一些特定的东西，这样它才能避免歧义，实现正确的重载操作。到后来，我发现这些多余的符号成为了非常碍眼的东西，它们让我无法直接的看到我所要表达的概念。</p><p style="margin:0px 0px 20px;padding:0px;">所以我觉得 Lisp 和 Scheme 的宏是很重要的东西。然而我的观点是，宏一定要少用，要在非常有必要的时候才定义宏。否则你的语言里就会出现很多奇怪的结构，这些结构没法用函数调用的语义来理解。这样就造成了程序员之间交流的障碍。在 Common Lisp 里面有很多种 looping macro 就这样的例子，它们让 Common Lisp 的程序难以理解。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="882"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_a8f735" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">PySonar2 开源了</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">经过 Google 的许可，我现在将 <a href="http://yinwang0.wordpress.com/2010/09/12/pysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">PySonar</a> 第二版本开源，就叫 PySonar2 吧。代码可以在我的 GitHub 下载：</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="https://github.com/yinwang0/pysonar2" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">https://github.com/yinwang0/pysonar2</a></p> 
<p style="margin:0px 0px 20px;padding:0px;">经过一阵子考察之后，我发现 PySonar2 仍然是当今最先进的 Python 静态分析器。其分析的深度和准确程度其实超过了所有的 Python IDE （包括 PyCharm 3.0 在内）。PySonar2 做的是跨过程，具有精确控制流的分析，而现在最好的 Python IDE 仍然是局部过程分析。</p> 
<p style="margin:0px 0px 20px;padding:0px;">PySonar2 的工作原理却极其简单，说白了就是：写一个 Python 解释器，然后想办法让它“停机”。实际上这个简单的方法超过了一些程序语言研究者花几十年做出来的“艰深理论”。比如 Olin Shivers 及其学生们的 control-flow analysis 系列 20 多年来的成果，当我看他们的论文的时候，发现他们其实在解决一个自己（不小心）造出来的问题。我一开头什么都不知道，全凭自己感觉出发，所以就没有走上那条不归路 ;-)</p> 
<p style="margin:0px 0px 20px;padding:0px;">另外，其实给 Google 的代码里有一个很“严重”的 bug，导致算法成为指数时间复杂度，所以他们其实仍然在用第一版的代码 ;-) <a href="http://www.sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Sourcegraph.com</a> 使用的也是第一版的代码。在 Coverity 的时候，我从他们的代码里面也发现同样的问题，对某些 benchmark 运行时间太长。最后被我两行代码修好了（虽然找到这两行代码花了好几天）。</p> 
<p style="margin:0px 0px 20px;padding:0px;">最近重新燃起了对 PySonar 代码的兴趣。经过修改两行代码之后，这个性质与 Coverity 完全一样的 bug 被消灭掉了。然后又发现一些逻辑细节和数据结构性能上的问题，也逐渐修补了。现在它能够处理整个 Python 2.5, 2.6, 2.7 的标准库和类似 Django 的项目，只需要3分钟的样子。我惊喜的发现能够检索到的名字比第一版多很多。界面还算比较友好吧，但是有待提高。欢迎喜欢美工的人士参与合作。</p> 
<p style="margin:0px 0px 20px;padding:0px;">因为 Python 语言的复杂性，而且由于我其实不是 Python 程序员，我相信 PySonar2 里面肯定还有一些细节没有照顾到（虽然最主要的部分是没问题的）。如果发现问题，请开启 GitHub 的 issue。</p> 
<p style="margin:0px 0px 20px;padding:0px;">另外，同样的原理其实可以应用到所有的语言分析里面。在将来我希望开发出通用的代码分析器，能够处理多种语言。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="883"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_e08415" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">一个对 Dijkstra 的采访视频</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">　　一个对 Dijkstra 的采访视频</p> 
<p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.youtube.com/watch?v=RCCigccBzIU" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/dijkstra-interview.png" type="image/png" height="503" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="700"/></a></p> 
<p style="margin:0px 0px 20px;padding:0px;">（不能访问 <a href="http://www.youtube.com/watch?v=RCCigccBzIU" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">YouTube</a> 的人可以从这里下载 <a href="http://www.cs.utexas.edu/users/EWD/video-audio/NoorderlichtVideo.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">MPEG1</a>，300M）</p> 
<p style="margin:0px 0px 20px;padding:0px;">之前在微博上推荐了一个对 Dijkstra 的采访视频，看了两遍之后觉得实在很好，所以再正式推荐一下。如果你不清楚 Dijkstra 的贡献，那么就想一想自己用的程序语言里面司通见惯的“递归函数”是哪里来的。其实当年递归函数是 Dijsktra 和另一个人不顾委员会里众人的反对和怀疑，坚持要放进 Algol 60，所以后来才进入了 Pascal，C，Java 这样的语言的。那个时候 John McCarthy 不在场，不然的话就会有三个人支持了。</p> 
<p style="margin:0px 0px 20px;padding:0px;">现在看来，任何一个语言里面没有递归函数都是不可思议的事情，然而在1950-60年代的时候，居然很少有人知道它有什么用！所以你就发现，所谓的“主流”和“大多数人”一直都是比较愚蠢的。现在，同样的故事发生在 lambda 身上。多年以后，没有 lambda 的语言将是不可接受的。</p> 
<p style="margin:0px 0px 20px;padding:0px;">在这里只摘录他提到的几个要点。某些观点也许不是最好的办法，但我确信其中有非常值得学习的地方。</p> 
<ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">软件的版本号 2.6, 2.7, ... 都是胡扯。本来第1版就应该是最终的产品，可是软件公司总是先弄出来一个不完整的版本，骗大家买了，以后再慢慢“升级”。每次升级都要用户再次付钱。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">编程有多种流派，我喜欢把它们归类成“莫扎特 vs 贝多芬”。当莫扎特开始写乐谱时，作品就已经完成了。他的手稿一气呵成，书法也很好。贝多芬不一样，他总是在怀疑和挣扎。他的作品一般是还没有想好就开始写，然后就往上面贴纸条修改。有一次贝多芬改了9遍才把手稿完成，后来有人把这手稿一层层的撕开，发现第一版和最后一版是一摸一样的。这种改来改去的做法是 Anglo-Saxon 名族的传统，它贯穿了英国式的教育。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">作曲家的工作不是写乐谱，而是构思音乐。最早的时候人们编程都是用汇编语言的，就跟写乐谱差不多。后来他们发明了高级语言，就以为这些语言把编程的问题解决了。但是你仔细一瞧，发现它们只是把编程最微不足道的问题解决了，但是困难的问题仍然困难。这些高级语言与越来越大的野心加在一起，反而让程序员头脑的负担更重了。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">称职的程序员都知道自己头盖骨的尺寸是有限的，所以他们以谦逊的态度来对待工作，像回避瘟疫一样地回避小聪明。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">当我1970年在法国巴黎讲学如何编程的时候很成功，听众都非常积极。回家的路上我又在比利时布鲁塞尔的一个大软件公司进行了同样的演讲，结果非常失败。那恐怕是我一生中最失败的演讲。后来我发现了为什么：他们的管理层不喜欢无懈可击的程序，因为这公司是靠“维护软件”的合同来维持生存的。程序员对此也不感兴趣，因为最让他们兴奋的事情在于不知道自己在干什么。他们觉得如果清楚地知道自己在干什么，那就没有挑战性了，就是无聊的工作。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">研究物理的人如果遇到不理解的事情，总是可以责怪上帝，世界这么复杂不是你的错。但是如果你的程序有问题，那就找不到替罪羊了。0就是0，1就是1，就是你把它搞砸了。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">1969年，在阿波罗号登月之后不久，我在罗马的北约软件工程会议遇到了 Joel Aron，阿波罗计划的软件负责人。我知道每个阿波罗飞船上面的代码都会比前一个多4万行。我不知道“行”对于代码是个什么单位，但4万行肯定是很多了。我很惊讶他们能把这么多代码做对，所以我问 Joel：你们是怎么做到的？他说：做什么？我说：把那么多代码写正确。Joel 说：“正确？！其实在发射前仅仅五天，我从登月器计算轨道的代码里发现一个错误，这代码把月球的重力方向算反了。本来该吸引的，结果写成了排斥。是一个偶然的机会让我发现了这个错误。”我的脸都吓白了，说：这些家伙运气真好？Joel 说：“是的。”</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">软件测试可以确定软件里有 bug，但却不可能用来确定它们没有 bug。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">程序的优雅性不是可以或缺的奢侈品，而是决定成功还是失败的一个要素。优雅并不是一个美学的问题，也不是一个时尚品味的问题，优雅能够被翻译成可行的技术。牛津字典对 elegant 的解释是：<a href="http://www.oxforddictionaries.com/us/definition/american_english/elegant?q=elegant" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">pleasingly ingenious and simple</a>。如果你的程序真的优雅，那么它就会容易管理。第一是因为它比其它的方案都要短，第二是因为它的组件都可以被换成另外的方案而不会影响其它的部分。很奇怪的是，最优雅的程序往往也是最高效的。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">当没有计算机的时候，编程不是问题。当有了比较弱的计算机时，编程成了中等程度的问题。现在我们有了巨大的计算机，编程就成了巨大的问题。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">我最开头编程的日子跟现在很不一样，因为我是给一个还没有造出来的计算机写程序。造那台机器的人还没有完工，我在同样的时间给它做程序，所以没有办法测试我的代码。于是我发现自己做的东西必须要能放进自己的脑子里。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">我的母亲是一个优秀的数学家。有一次我问她几何难不难，她说一点也不难，只要你用“心”来理解所有的公式。如果你需要超过5行公式，那么你就走错路了。</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">为什么这么少的人追求优雅？这就是现实。如果说优雅也有缺点的话，那就是你需要艰巨的工作才能得到它，需要良好的教育才能欣赏它。</p></li> 
</ol> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="885"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_6e3d68" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">PySonar 的工作原理</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">2012年9月，我在 <a href="http://www.mathworks.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">MathWorks</a> 做了一个演讲，内容是关于之前在 Google 做的 Python 静态分析。现在把幻灯片的一部分公开在这里。里面含有一些这个静态分析器里面基本的原理。虽然可能不怎么能看懂，但是希望对希望了解静态分析的人有所帮助。</p><p style="margin:0px 0px 20px;padding:0px;">在下一篇博文里，我想讲一下静态分析的基本原理，以及如何利用这种原理写出“逻辑正确”的程序。以及它与定理证明和“<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.128.6414" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">supercompilation</a>”的关系。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="892"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_a8f731" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">PySonar 的第二个用户</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p> 
<p style="margin:0px 0px 20px;padding:0px;">湾区的世界真是机缘巧合众多。最近有人联系我，说他们做了一个代码搜索公司叫<a href="http://sourcegraph.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">sourcegraph.com</a>，其中的 Python 检索部分使用了 <a href="http://yinwang0.wordpress.com/2010/09/12/pysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">PySonar</a> 的<a href="http://hg.python.org/jython/file/11776cd9765b/src/org/python/indexer" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">第一版开源代码</a>。于是我很高兴的发现 PySonar 有了第二个用户（当然，Google 是第一个）。</p> 
<p style="margin:0px 0px 20px;padding:0px;">Sourcegraph 的两位创始人 Quinn 和 Beyang 告诉我，PySonar 是他们试过的最精确，也是最友好的 Python 静态分析。这虽然是意料当中的，但是我还是很高兴有人发现了这一点。其实在设计 PySonar 之前我试过十多个 Python 分析器和 IDE，发现它们并不能真正的分析 Python 的语义，所以才开始从头发明。而 PySonar 的第二版采用的我自己发明的 &quot;abstract interpretation&quot; 超越了现有的所有静态分析器（包括所有语言的分析器在内，比如 Coverity 和 PL 学术界的 control-flow analysis 技术）。PySonar 第二版已经很接近理论的极限，所以基本不大可能有其它工具可以超过它。那里面说去说来就那么点东西，但是我刚发现很多人其实都不理解 ;-)</p> 
<p style="margin:0px 0px 20px;padding:0px;">我也很欣赏 Quinn 和 Beyang 的聪明才智和雄心壮志。我希望 sourcegraph 发展壮大，成为世界上最优秀的代码搜索和分析网站。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="893"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_aad209" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">再见 Voxer，你好 Sourcegraph</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p> 
<p style="margin:0px 0px 20px;padding:0px;">话说离开 Coverity 之后，在 Coverity 创始人和 CTO Andy Chow 的介绍下，我加入了一家叫做 Voxer 的公司，成为了他们的第一个“Data Engineer”。尽管我讨厌 Coverity，但我不得不承认 Andy Chow 是个特别好的人。要是我直接在他手下做事，那可能不至于这么快离开 Coverity。可惜啊，似乎每个 startup 在外部资本介入之后，权力都不再集中在最初的 founder 手里，以至于可以出现“部门暴君”，连创始人都拿他没办法。到现在看来，离开 Coverity 还真是明智的决定，它拯救了我的身体，心情和不少的脑神经。我求上帝保佑仍然在 Coverity 工作的中国同事们。</p> 
<p style="margin:0px 0px 20px;padding:0px;">话说这个 Voxer，它是一种手机 app，作用相当于一个对讲机。跟很多类似的软件（比如微信，Heytell, Whatsapp）不同的地方是，Voxer 的语音传输有各种专利的设计，速度非常快。所以很多需要高效通信的机构（比如出租车公司，快递公司，机场）在使用这个 app。然而我在 Voxer 的工作不是设计这个 app，而是跟一位 data scientist 一起做“大数据”分析。这是跟我的专长非常不同的工作，但由于 Coverity 伤了我的神经，我想换换口味。后来我发现，我迅速的看透了这“大数据”里面的机要，并且设想出了更好的设计。</p> 
<p style="margin:0px 0px 20px;padding:0px;">跟我合作的 data scientist 名叫 TJ，他以前是个天体物理学家，在各大天文中心待过好多年，可谓是看饱了宇宙的奥秘，发表论文 100 多篇。TJ 就是我从小向往成为的那种人：科学家。我一直都非常尊敬 TJ，然而他却谦虚卑微得不得了。我不得不说，这个世界对真正的科学家是非常不公平的。TJ 也是看透了学术界的腐败，迫于美国政府削减天体物理开支的压力，才不得不放弃自己心爱的事业，转行做了 data scientist。曾经使用 Mathematica 和 IDL 的他，现在的主要工具是难用的不得了的 Hadoop，Pig 和 TSV 格式的数据文件，而且每天都有各种 marketing，sales 的人给他提出各种数据分析的要求。</p> 
<p style="margin:0px 0px 20px;padding:0px;">我忽然间发现，科学，对于消灭人类的愚昧和偏见，真是没有多大用处。科学家，其实是社会上的弱势群体。</p> 
<p style="margin:0px 0px 20px;padding:0px;">我和 TJ 愉快的合作了两个多月。我不得不说，Voxer 是一家跟 Coverity 气氛非常不同的公司。我没感觉到过任何压力，没有苛刻的任务时间限制，也没有遭遇到过自大狂。不过从工作的角度说来，我感觉这两个月真的只是散了一下心，没有干多少有创造性的事情。我大部分的时间花在了 “折腾”各种 graph database 上面，这让我感觉回到了写出《完全用 Linux 工作》的那个自己。人们都误以为“精通”某种工具的人很厉害，而抱怨某种工具“对用户不友好”的人就是菜鸟。然而从前的那个精通 Linux 的自己，却是现在最瞧不起我的那种人。他只知道如何转弯抹角的使用各种难用的工具，而不是设法让困难的事情变得简单和容易。自认为是高手，而其实是个没看透东西本质的菜鸟和暴君。</p> 
<p style="margin:0px 0px 20px;padding:0px;">TJ 从来不认为自己是写 Pig 和处理 TSV 文件的高手，所有的计算机工具对于他来说都是临时拿来凑合一下。他很希望有一种方便的工具，可以让他不需要再使用落后的文件来存放数据。再加上对“社交网络”进行分析的需求，我们就走上了探索和折腾各种 graph database 的道路。我们探索的第一个 graph database 是 Neo4j，使用它的原因是我们的 VP 对它非常推崇。开头我还很兴奋，因为我早就从本质上看到了关系式数据库的缺陷。我希望已经有人设计出简单好用的数据库，可以让我像操作内存数据结构一样简单而任意的操作磁盘数据。</p> 
<p style="margin:0px 0px 20px;padding:0px;">然而过了一段时间之后，我发现我的希望破灭了：Neo4j 跟我的目的是背道而驰的。Neo4j 的 Cypher 语言，完全是语言设计的门外汉用来练手的作品。不但表达力有严重缺陷，而且根本不能达到传说中的性能。在对 Neo4j 失望之后，我又测试了 OrientDB, Titan, InfiniteGraph, ... 最后发现它们没有一个能够达到我们的需求，甚至比 Neo4j 更差。不得已之下，我们花钱请来了一个 Neo4j 的 consultant，跟我们一起折腾了一天，结果最后得到的答案是：不要使用最新的 2.0 版本，要用 1.9.4，要减少数据量，让它可以完全放进内存，各种隐秘的“设置”搞了一堆，不要用 Cypher，因为优化做得还不好，并且还要自己用 Java 写“扩展”，才能达到我们所要的基本性能需求。这就是号称 &quot;the world's leading graph database&quot; 的 Neo4j。这跟以前看过的一个漫画里的“超级跳蚤药”的说明书有什么区别吗？这个说明书是这样的：</p> 
<ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">抓住跳蚤</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">把跳蚤的嘴掰开</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">把一粒药塞进跳蚤嘴里</p></li> 
 <li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">闭上跳蚤的嘴，等五分钟</p></li> 
</ol> 
<p style="margin:0px 0px 20px;padding:0px;">在 Voxer 的每一天都很轻松，因为 Neo4j 实在是太慢了，光是把数据导进去都要花一两天时间，错了还得重来。有时候从早到晚我就让 Neo4j 自己跑，然后就去喝茶。我已经看到很多人羡慕的目光 ;-) 然而，这还是我自己吗？我感觉到自己的理想正在离我而去，就像 TJ 的理想离他而去一样。我是世界上最优秀的计算机科学家和程序语言专家之一。我不应该把自己的才华浪费在折腾这些无能的数据库上面。我的目标之一应该是设计出全新的数据库系统，完全的改善人们使用数据的方式，而不是绞尽脑汁让一些无可救药的系统能够凑合工作。</p> 
<p style="margin:0px 0px 20px;padding:0px;">就在这个昏昏欲睡的时候，Quinn 和 Beyang 找到了我，告诉我他们采用了我在 Google 写的第一版 PySonar 代码，并且成立了一家叫做 Sourcegraph 的公司。他们想成为世界上最大最精确的代码“语义搜索”引擎，想请我加入他们。程序的语义检索网站，这是我在 Google 的小组试图要做的，然而现在却被这两个毛头小子先做了出来，我不得不佩服 Stanford 同学们的创业精神。随后，我们进行了好几轮的“面试”。从来面试都是别人考我，这次却是我对 Quinn 和 Beyang 提出各种刁钻问题。从技术到市场和投资，一一问了个清楚，甚至他们的天使投资人还给我打了电话。真可谓是三顾茅庐了。最后，我相信了 Quinn 和 Beyang 的实力和活力，看到了他们对于真正优秀的技术的向往，所以虽然工资比 Voxer 少了不少，我仍然决定了加入 sourcegraph，成为他们的 No. 4。那么 No. 3 是谁呢？是 Quinn 的 Mlton，一只会写编译器的大狗。</p> 
<p style="margin:0px 0px 20px;padding:0px;">人生的快乐真的不是钱能买得到的。能找到喜欢的事情做，找到合适的合作伙伴，才是最重要的。</p> 
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="894"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_d9f582" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">程序员的心理疾病</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　　程序员的心理疾病</p><p style="margin:0px 0px 20px;padding:0px;">由于程序员工作的性质，他们长期以来受到的所谓“黑客”式的“熏陶”，形成了一种行业性的心理疾病。这里我就简单的把我所观察到的一些症状总结一下。</p>
无自知之明
<p style="margin:0px 0px 20px;padding:0px;">由于程序员的工作最近几年比较容易找，工资还不错，所以很多程序员往往只看到自己的肚脐眼，看不到自己在整个社会里的位置其实并不是那么的关键和重要。很多程序员除了自己会的那点东西，几乎对其它领域和事情完全不感兴趣，看不起其他人。这就是为什么我的前同事 TJ 作为一个资深的天体物理学家，在一个软件公司里面那么卑微。貌似会写点 node.js，iOS 软件的人都可以对他趾高气昂的样子，而其实这些东西的价值哪里可能跟 TJ 知道的物理知识相提并论。很多科学家其实都 可以轻而易举的掌握程序员知道的东西，有人却认定了他们不是这个专业的，不懂我们的东西，或者故意把问题搞复杂，让他们弄不明白。让人感觉是在阴沟里翻了船被老鼠欺负。</p><p style="margin:0px 0px 20px;padding:0px;">如果力学工程师犯了错误，飞机会坠毁；如果结构工程师犯了错误，大桥会垮塌；可是如果软件工程师犯了错误，大不了网站挂掉一小时，重启一下貌似又好了。所以所谓“软件工程师”，由于门槛太低，他们的工作严谨程度，其实是根本没法和力学工程，结构工程等真正的工程师相提并论的。实际上“软件工程”这个名词根本就是扯淡的，软件工程师也根本不能被叫做“工程师”。跟其他的工程不一样，软件工程并不是建立在科学的基础上的，计算机科学也根本不是科学。</p>
垃圾当宝贝
<p style="margin:0px 0px 20px;padding:0px;">按照 Dijkstra 的说法，“软件工程”是穷途末路的领域，因为它的目标是：如果我不会写程序的话，怎么样才能写出程序？</p><p style="margin:0px 0px 20px;padding:0px;">为了达到这个愚蠢的目的，很多人开始兜售各种像减肥药一样的东西。面向对象方法，软件“重用”，设计模式，关系式数据库，NoSQL，大数据…… 没完没了。只要是有钱人发布的东西，神马垃圾都能被吹捧上天。Facebook 给 PHP 做了个编译器，可以编译成 C++，还做了个 VM，多么了不起啊！其实那种东西就是我们在 Indiana 第一堂课就写过的，只不过我们是把比 PHP 好很多的语言翻译成 C。我们根本不想给 PHP 那么垃圾的语言做什么编译器，让垃圾继续存活下去并不能证明我们的价值。</p><p style="margin:0px 0px 20px;padding:0px;">其实软件里面有少数永恒的珍宝，可惜很少有人理解和尊重它们的价值。这在其它的工程领域看来是不可思议的，然而这却是事实。由于没有科学作为理论的基础，没有实验作为检验它们的标准，软件行业的很多东西就像现代艺术一样，丑陋无比的垃圾还能摆在外表堂皇的“现代艺术博物馆”里面，被人当成传世大作一样膜拜。</p><p style="margin:0px 0px 20px;padding:0px;">为了凸显自己根本不存在的价值，又提出一些新的“理念”，就像有些现代艺术家一样，说“艺术的目的不是为了美，而是为了自由。”哦，这就是为什么你们可以自由地把那些让人反胃的东西放在博物馆里，还要买门票才能参观？</p>
宗教斗争
<p style="margin:0px 0px 20px;padding:0px;">当然了因为没有实质的技术，为了争夺市场和利益，各种软件的理念就开始互相倾轧。一会儿说软件危机啦，面向对象方法来拯救你们！一会儿又提出设计模式。过了一会儿又有人说这些设计模式里面有些模式是“反模式”，然后又有人把函数式编程包装起来，说是面向对象编程的克星，一会儿是关系式数据库，一会儿是 NoSQL，一会儿是 web，一会儿是 cloud，一会儿又是 mobile…… 每个东西都喜欢把自己说成是未来的希望。</p><p style="margin:0px 0px 20px;padding:0px;">这就是为什么有人说在软件行业里需要不停地“学习”，因为不断地有人为了制造新的理念而制造新的理念。在这样一个行业里，你会很难找到一个只把程序语言或者技术当成是工具的人。如果有人问你对某个语言或者技术的评价，是非常尴尬甚至危险的事情，所以最可靠的办法就是不做评论，什么都不要说。</p>
引难为豪
<p style="margin:0px 0px 20px;padding:0px;">在 IT 行业里批评一个技术难用，是一件非常容易伤自尊的事情，因为立马会有人噼里啪啦打出一些稀奇古怪的命令或者一大篇代码，说：就是这么简单！然后你就发现，这些人完全不明白什么叫做设计，他们以自己能用最快的速度绕过各种前人的设计失误为豪，很多程序员甚至以自己打字快为豪。</p><p style="margin:0px 0px 20px;padding:0px;">当遇到这样的人，我的经验是，千万不要恭维他们。你必须大声地嘲笑这些东西的设计，并且指出它们的失误之处，否则你不但助长了这些人的气焰，而且将来自己的自尊也难保了。很可惜的是不是每个人都有这种勇气把这些话说出来，这就造成了今天的局面，纷繁复杂的垃圾充斥着世界。爱因斯坦说，你需要很多的天才和非常大的勇气，才能追求到简单。</p><p style="margin:0px 0px 20px;padding:0px;">非常大的勇气…… 也许就是这个意思。</p>
去读文档！
<p style="margin:0px 0px 20px;padding:0px;">不知从什么时候开始，人们开始引用 Eric Raymond 的一篇叫做《提问的艺术》的文章，这篇文章后来就成为了对提问者没礼貌的借口。由于这篇文章的误导，当你希望同事能给你一个手把手的演示的时候，他们往往会丢给你一篇不知道什么时候写的文档，让你自己去读，仿佛文档就可以代替人之间的直接互动。况且不说这文档可能已经过时，里面有很多地方已经不符合最新的设计，而这意味着在潜意识里，他们觉得高你一等。他们甚至会对你说，如果每个新人来了我们都花这么多时间去指导他们入门，哪里还有时间干正事呢？然后你就意识到了，你在他们心里的地位，其实是如此的卑微和低下。</p><p style="margin:0px 0px 20px;padding:0px;">有的人稍微委婉一点，当你提问的时候，他们会二话不说打开一个浏览器窗口，在里面用 Google 搜索，然后指给你：看，就是这样。貌似比较礼貌，但那其实意味着他们在教训你：Google 一下就找到了的，自己不动脑筋！有谁不会用 Google 呢？提问的人恐怕是想得到 Google 不能给他的答案。真正有礼貌的人在不知道答案的时候是不会当面去帮你搜索的，他会对你说：“这个我也不知道…… 要不你搜索一下？”</p><p style="margin:0px 0px 20px;padding:0px;">在 IRC 的聊天室里，由于隔着网络的屏障，这种对提问者没礼貌的现象就更加嚣张。我曾经有几次去 Java 的聊天室问一些貌似基础，而其实很深入的语言设计问题，结果没有一次不是以收到像“去读 API！”这样的回答而结束。API 谁不会读，然而我需要的是一个有血有肉的人对此的理解。所以后来我根本不去 IRC 这种地方了，因为那里面对你打字的基本上已经不是人类了。他们觉得你问问题浪费了他们的时间，好像他们一天到晚泡在 IRC 里面就是在做什么正事似的。不想回答问题，不开口还不行吗。后来你发现，原来在 IRC 里面训斥新手就是这些人唯一的乐趣，所以其实他们是非开口说话不可的。然而这次他们遇到的却不是个新手，而是一个可以把 Java 整个造出来的人。</p><p style="margin:0px 0px 20px;padding:0px;">像 Haskell 之类的聊天室貌似稍微友好一点，然而后来你发现他们显得友好是有所企图的。因为当时 Haskell 还没有很多人用，他们需要吸引新手，所以竭尽所能的诱导他们。而一旦它用户稍微多了一点，有声势了，那些积极分子就成了专家一样的人物。他们就开始写书，然后就开始牛气哄哄的了。然后你就会发现当对 Haskell 的设计提出异议的时候，这些“id”们是多么的不友好，有理也说不清。所以最后你发现，其实所有语言的所谓“社区”都一个德行。如果 Haskell 有一天像 Java 一样如日中天（当然不大可能），肯定对大部分问题的答案也就是“去读API！”其实它已经在向这一步发展了。</p><p style="margin:0px 0px 20px;padding:0px;">不得不指出，《提问的艺术》等介绍“黑客文化”的文章对于这种现象的出现有着极大的责任。说穿了，写这些文章的人一般都是 Unix 的跟屁虫。这种文章试图抹去人类文明几千年来传承的文化，而重新给“礼貌”做出定义。其结果是，人类的文明因为这些文章，在程序员的世界里倒退了几十甚至几百年。很多外行人人不喜欢跟程序员说话，叫他们是 nerd，就是这个原因。</p>
不要提问，不要谦虚，不要恭维
<p style="margin:0px 0px 20px;padding:0px;">跟上面的症状相似，程序员世界里的一条重要的潜规则是：只有菜鸟才会问问题。所以如果你有任何机会可以自己得到答案，就不要试图向人“请教”，尤其不要显得好奇，否则你就会被认为是菜鸟。我有几次不耻下问的经历，最后导致了我被人当成菜鸟。我只是觉得那问题有趣，也许能够启发我设计自己的东西，所以吃饭时觉得是个话题可以说一下，结果呢就有人忙着鄙视你，那么小的问题都没搞清楚。正确的态度应该是诚实，直接，见惯不惊，那有什么大不了的，我什么没见过，我很怀疑。</p><p style="margin:0px 0px 20px;padding:0px;">随之而来的引论就是：不要谦虚！那些“职场经验”之类的文章告诉你的进入新的公司工作，要谦虚好问，对 IT 公司这种不讲美德的地方是不管用的。有的大 IT 公司有所谓的“文化”，比如叫你要“Googley”，要“humble”，其实只是用来贬低你价值的借口。他们要你向他们“学习”，但其实他们没有什么值得学习的地方。他们只是想让你安于“本分”，做一些微不足道，不能发挥你才能的工作。看看那些叫你要 humble 的人，他们 humble 吗？所以跟江湖一样，在 IT 公司里面一件很重要的事情是，亮出自己的宝剑和绝招，给人下马威。介绍自己的东西一定要自豪，这就是世界上最好的，无敌的，没有其他人能做到！不能有任何保留。不要像科学家一样介绍自己技术的局限性，否则随之而来的就是有些人对你价值的怀疑和对你自信心的打击。</p><p style="margin:0px 0px 20px;padding:0px;">另外要注意的是对于别人介绍的东西，不要轻易地表扬或者点头，否则有人就更有气势了。你要问这样的问题：这里面有什么新的东西吗？这个事情，另外一种技术早就能做了啊，没觉得有什么了不起。</p><p style="margin:0px 0px 20px;padding:0px;">哎，总之这样还是很累，所以最好是能不跟程序员讲话就不讲。</p>
以语言取人
<p style="margin:0px 0px 20px;padding:0px;">你的软件是什么语言写的，告诉别人的时候是千万要小心的，不到万不得已最好不要说。因为十有八九，对方会立即在心里对你的软件的价值做出判断，光凭你用的是什么语言。</p><p style="margin:0px 0px 20px;padding:0px;">很多程序员都以自己会用最近流行的一些新语言为豪，以为有了它们自己就成了更好的程序员。他们看不到，用新的语言并不能让他们成为更好的程序员。其实最厉害的程序员无论用什么语言都能写出很好的代码。在他们的头脑里其实只有一种很简单的语言，他们首先用这种语言把问题建模出来，然后根据实际需要“翻译”成最后的代码。这种在头脑里的建模过程的价值，是很难用他最后用语言的优劣来衡量的。有时候高明的程序员用一个语言并不是因为他只会用那种语言，而是其他的原因。他们的头脑里有着万变不离其宗的理念，可以让他们立即掌握几乎任何语言或者工具，所以他们对所谓的“新语言”都不以为然。可是很多人误以为他们不愿意学习“新东西”，从而从心里鄙视他们。其实计算机的世界里哪里有很多新的东西，只不过是有人给同样的东西起了很多不同的名字而已。如果连这样的程序员都不能理解你的技术，就说明你的技术设计有问题，而不是他们有问题。就像 Seymour Cray 说的，我只能理解简单的东西，如果它太复杂了，我是不能理解的。</p><p style="margin:0px 0px 20px;padding:0px;">早些年的时候，大家都认为招募某种特定语言的程序员是一种浮浅的做法，很多公司看重的都是解决问题的能力。可是近些年我发现这些浮浅的做法越来越普遍。可以说现在像 Google 这样的公司面试员工的方式和态度，其实还不如八年前我的第一份国内工作。很可笑的是，我离开 Coverity 之后那段时间面试的所有声称使用 Python 的公司，最后都认定了我是 Python 的菜鸟。然而如果你知道 PySonar 的技术含量就会明白，这样的东西需要水平高过 Python 的创造者 Guido van Rossum 很多的人才能造出来。在制造了 PySonar 之后，他对程序语言的理解，他的每一个错误都被我看得清清楚楚。当然，Ruby 就更烂了，我可以说，Matz 这人其实根本不知道他在干什么。</p><p style="margin:0px 0px 20px;padding:0px;">说到这些的时候，我很惊讶的发现有人来信告诉我，还是等你做出了什么“成就”再来说这些话吧。从这里我看到了“竞争”和“攀比”的思想在有些人心里是多么的根深蒂固，我也看出了这些“大牛”在他们心里是个什么地位。然而他们是激将不到我的，因为我根本没有跟别人“比”的意思。说实话吧，就算你打死我，我也做不出有那么多毛病的语言来。我两个小时之内设计个语言都比 Python, Ruby, JavaScript 要好很多。我不可能以“超过 Python 和 Ruby”这么肤浅的目的为动机，来达到别人所认同的“成就”。打个比方，我有什么必要证明我比 Justin Bieber 或者 Lady Gaga 强呢？我根本不明白这些人到底有什么成就，也完全没有必要向他们的粉丝证明我的价值。在这几次有伤自尊的面试之后，我再也不会给任何使用 Python 作为主要语言的公司工作。</p>
跟屁虫
<p style="margin:0px 0px 20px;padding:0px;">有些程序员对新手和同事是那么的不友好，然而对大牛们拍马屁的功夫可真是出类拔萃。我刚到旧金山的几个月有时候参加一些程序语言的“meetup”，后来我发现这种 meetup 都是宗教气氛非常浓厚的地方，跟传销大会差不多。Scala 的 meetup 里面的人几乎全都对 Scala 和 Martin Odersky 顶礼膜拜，甚至把 Rod Johnson 请来说一堆胡话。Clojure 的，当然基本上把 Rich Hickey 当成神，甚至称他为“二十一世纪最重要的思想家之一”。各种 talk 总是宣扬，哇，我们用 Scala/Clojure 做出了多么了不起的东西云云，其实只不过是在向你兜售减肥药。</p><p style="margin:0px 0px 20px;padding:0px;">很多人喜欢做这些新的语言和技术的“evangelist”，尽显各种马屁神功，然后就开始写书，写 blog，…… 目的就是成为这个“领域”的第一批专家。这就难怪了，再垃圾的语言也有一大批人来鼓吹。因为这些没真本事的人，随便把一个东西捧上天都有自己的好处。</p><p style="margin:0px 0px 20px;padding:0px;">由于受到这些“先知”的影响，有些人开始在他们自己的公司里“布道”。比如有人在 Python 的 meetup 集会时告诉我，他试图在自己的小组里推 Python，可是一些老顽固一定要用 Java，认为 Java 才是王道。很鄙夷不高兴的样子。我并不认为 Java 是很好的语言，然而 Python 也好不到哪去。它们在我眼里只不过是临时拿来用一下的工具，可是我仍然能用它们写出一流的代码。</p><p style="margin:0px 0px 20px;padding:0px;">看到这些宗教性质的聚会，我终于理解了一些地区是如何被从一个国家分裂出去，最后沦落为另外一个国家殖民地的。最早的时候，一般是派传教士过去“传经”，然后就煽动一小部分人起来造反。到后来就可以名正言顺的以“保护传教士”，“保护宗教自由”，“维持和平”等理由把军舰开到别人家门口……</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="905"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4cbe28" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">西雅图不眠夜</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ivwz&amp;amp;amp;url=http://s11.sinaimg.cn/orignal/5d90e82fgd78c3e6c4e2a" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd78c3e6c4e2a&690.png" type="image/png" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><br/>
西雅图不眠夜，多么熟悉的名字。这名字在耳边绕了这么多年，仿佛成了一种口头禅。曾经在西雅图住了长达半年之久，也曾在那里有过不眠之夜，却今天才第一次明白“西雅图不眠夜”的含义。
<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">一个朋友告诉我一个小窍门：如果不知道一部电影好不好看，就给它10分钟的机会。如果10分钟之内你还可以走开，那么这电影就不值得看。西雅图不眠夜，就是一部在5分钟之内就吸引住我的电影。悬念不很多，零碎的言语之中却含有至情和真理。像一只音调相当的琴弦，引起强烈的共鸣，完了还有余音绕梁的余地。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这样的电影真是不可多得。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="911"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4cbe1f" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">谈语法</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">使用和研究过这么多程序语言之后，我觉得几乎不包含多余功能的语言，只有一个：Scheme。所以我觉得它是学习程序设计最好的入手点和进阶工具。当然 Scheme 也有少数的问题，而且缺少一些我想要的功能，但这些都瑕不掩瑜。在用了很多其它的语言之后，我觉得 Scheme 真的是非常优美的语言。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">要想指出 Scheme 所有的优点，并且跟其它语言比较，恐怕要写一本书才讲的清楚。所以在这篇文章里，我只提其中一个最简单，却又几乎被所有人忽视的方面：语法。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其它的 Lisp “方言”也有跟 Scheme 类似的语法（都是基于“S表达式”），所以在这篇（仅限这篇）文章里我所指出的“Scheme 的优点”，其实也可以作用于其它的 Lisp 方言。从现在开始，“Scheme”和“Lisp”这两个词基本上含义相同。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我觉得 Scheme （Lisp） 的基于“S表达式”（S-expression）的语法，是世界上最完美的设计。其实我希望它能更简单一点，但是在现存的语言中，我没有找到第二种能与它比美。也许在读过这篇文章之后，你会发现这种语法设计的合理性，已经接近理论允许的最大值。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为什么我喜欢这样一个“全是括号，前缀表达式”的语言呢？这是出于对语言结构本质的考虑。其实，我觉得语法是完全不应该存在的东西。即使存在，也应该非常的简单。因为语法其实只是对语言的本质结构，“抽象语法树”（abstract syntax tree，AST），的一种编码。一个良好的编码，应该极度简单，不引起歧义，而且应该容易解码。在程序语言里，这个“解码”的过程叫做“语法分析”（parse）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为什么我们却又需要语法呢？因为受到现有工具（操作系统，文本编辑器）的限制，到目前为止，几乎所有语言的程序都是用字符串的形式存放在文件里的。为了让字符串能够表示“树”这种结构，人们才给程序语言设计了“语法”这种东西。但是人们喜欢耍小聪明，在有了基本的语法之后，他们开始在这上面大做文章，使得简单的问题变得无比复杂。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Lisp （Scheme 的前身）是世界上第二老的程序语言。最老的是 Fortran。Fortran 的程序，最早的时候都是用打孔机打在卡片上的，所以它其实是几乎没有语法可言的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101irad&amp;amp;amp;url=http://s15.sinaimg.cn/orignal/5d90e82fgd7612352d73e" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd7612352d73e&690.gif" type="image/gif" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a><br/><br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">显然，这样写程序很痛苦。但是它却比现代的很多语言有一个优点：它没有歧义，没有复杂的 parse 过程。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在 Lisp 诞生的时候，它的设计者们一下子没能想出一种好的语法，所以他们决定干脆先用括号把这语法树的结构全都括起来，一个不漏。等想到更好的语法再换。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">自己想一下，如果要表达一颗“树”，最简单的编码方式是什么？就是用括号把每个节点的“数据”和“子节点”都括起来放在一起。Lisp 的设计者们就是这样想的。他们把这种完全用括号括起来的表达式，叫做“S表达式”（S 代表 &quot;symbolic&quot;）。这貌似很“粗糙”的设计，甚至根本谈不上“设计”。奇怪的是，在用过一段时间之后，他们发现自己已经爱上了这个东西，再也不想设计更加复杂的语法。于是S表达式就沿用至今。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在使用过 Scheme，Haskell，ML，和常见的 Java，C，C++，Python，Perl，…… 之后，我也惊讶的发现， Scheme 的语法，不但是最简单，而且是最好看的一个。这不是我情人眼里出西施，而是有一定理论依据的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">首先，把所有的结构都用括号括起来，轻松地避免了别的语言里面可能发生的“歧义”。程序员不再需要记忆任何“运算符优先级”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其次，把“操作符”全都放在表达式的最前面，使得基本算术操作和函数调用，在语法上发生完美的统一，而且使得程序员可以使用几乎任何符号作为函数名。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在其他的语言里，函数调用看起来像这个样子：f(1)，而算术操作看起来是这样：1+2。在 Lisp 里面，函数调用看起来是这样（f 1），而算术操作看起来也是这样（+ 1 2）。你发现有什么共同点吗？那就是 f 和 + 在位置上的对应。实际上，加法在本质也是一个函数。这样做的好处，不但是突出了加法的这一本质，而且它让人可以用跟定义函数一模一样的方式，来定义“运算符”！这比起 C++ 的“运算符重载”强大很多，却又极其简单。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">关于“前缀表达式”与“中缀表达式”，我有一个很独到的见解：我觉得“中缀表达式”其实是一种过时的，来源于传统数学的历史遗留产物。几百年以来，人们都在用 x+y 这样的符号来表示加法。之所以这样写，而不是 (+ x y)，是因为在没有计算机以前，数学公式都得写在纸上，写 x+y 显然比 (+ x y) 方便简洁。但是，中缀表达式却是容易出现歧义的。如果你有多个操作符，比如 1+2*3。那么它表示的是 (+ 1 (* 2 3)) 呢，还是 (* (+ 1 2) 3)？所以才出现了“运算符优先级”这种东西。看见没有，S表达式已经在这里显示出它没有歧义的优点。你不需要知道 + 和 * 的优先级，就能明白 (+ 1 (* 2 3)) 和 (* (+ 1 2) 3) 的区别。第一个先乘后加，而第二个先加后乘。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">对于四则运算，这些优先级还算简单。可是一旦有了更多的操作，就容易出现混淆。这就是为什么数学（以及逻辑学）的书籍难以看懂。 实际上，那些看似复杂的公式，符号，不过是在表示一些程序里的“数据结构”，“对象”以及“函数”。大部分读数学书的时间，其实是浪费在琢磨这些公式：它们到底要表达的什么样一个“数据结构”或者“操作”！这个“琢磨”的过程，其实就是程序语言里所谓的“语法分析”（parse）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这种问题在微积分里面就更加明显。微积分难学，很大部分原因，就是因为微积分的那些传统的运算符，其实不是很好的设计。如果你想了解更好的设计，可以参考一下 Mathematica 的公式设计。试试在 Mathematica 里面输入“单行”的微积分运算（而不使用它传统的“2D语法”）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实 Lisp 已经可以轻松地表示这种公式，比如对 x^2 进行微分，可以表示成 </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">          (D ‘(^ x 2) ‘x)</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">看到了吗？微分不过是一个用于处理符号的函数 D，输入一个表达式和另一个符号，输出一个新的表达式。</p><br/><p style="margin:0px 0px 20px;padding:0px;">同样的公式，传统的数学符号是这个样子：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101irad&amp;amp;amp;url=http://s7.sinaimg.cn/orignal/5d90e82fgd761ed71c386" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd761ed71c386&690.png" type="image/png" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这是什么玩意啊？d 除以 dx，然后乘以 x 的平方？</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/E___6702EN00SIGG.gif" type="image/gif" height="22" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="22"/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在 Lisp 里，你其实可以比较轻松地实现符号微分的计算。SICP里貌似有一节就是教你写个符号微分程序。做微积分这种无聊的事情，就是应该交给电脑去做。总之，这从一方面显示了，Lisp 的语法其实超越了传统的数学。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实我一直都在想，如果把数学看成是一种程序语言，它也许就是世界上语法最糟糕的语言。数学里的“变量”，几乎总是没有明确定义的作用域（scope）。也就是说他们只有“全局变量”。上一段话的 x，跟下一段话的 x，经常指的不是同一个东西。所以训练有素的数学家，总是避免使用同一个符号来表示两种不同的东西。很快他们就发现所有的拉丁字母都用光了，于是乎开始用希腊字母。大写的，小写的，粗体的，斜体的，花体的，…… 而其实，他们只不过是想实现 C++ 里的 “namespace”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可惜的是，很多程序语言的设计者没能摆脱数学的思想束缚，对数学和逻辑有盲目崇拜的倾向。所以他们继续在新的语言里使用中缀表达法。Haskell，ML，Coq，Agda，这些“超高级”的语言设计，其实都中了这个圈套。在 Coq 和 Agda 里面，你不但可以使用中缀表达式，还可以定义所谓的 &quot;mixfix&quot; 表达式。这样其实是把简单的问题复杂化。想让自己看起来像“数学”，很神秘的样子，其实是学会了数学的糟粕，自讨苦吃。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">最后，从美学的角度上讲，S表达式是很美观的设计。所有的符号都用括号括起来，这形成一种“流线型”的轮廓。而且由于可以自由的换行排版，你可以轻松地对齐相关的部分。在 Haskell 里，你经常会发现一些很蹩脚，很难看的地方。这是因为中缀表达式的“操作符”，经常不能对在一起。比如，如果你有像这样一个 case 表达式：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">case x</p><p style="margin:0px 0px 20px;padding:0px;">  Short _ -&gt; 1</p><p style="margin:0px 0px 20px;padding:0px;">  VeryLooooooooooooooooooooooooog _ -&gt; 2</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为了美观，很多 Haskell 程序员喜欢把那两个箭头对齐。结果就成了这样：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">case x</p><p style="margin:0px 0px 20px;padding:0px;">  Short _                           -&gt; 1</p><p style="margin:0px 0px 20px;padding:0px;">  VeryLooooooooooooooooooooooooog _ -&gt; 2</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">作为一个菜鸟级摄影师，你不觉得第一行中间太“空”了一点吗？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">再来看看S表达式如何表达这东西：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(case x</p><p style="margin:0px 0px 20px;padding:0px;">  (-&gt; (Short _) 1)</p><p style="margin:0px 0px 20px;padding:0px;">  (-&gt; (VeryLooooooooooooooooooooooooog _) 2))</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">发现“操作符总在最前”的好处了吗？不但容易看清楚，而且容易对齐，而且没有多余的间隙。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实我们还可以更进一步。因为箭头的两边全都用括号括起来了，所以其实我们并不需要那两个箭头就能区分“左”和“右”。所以我们可以把它简化为：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(case x</p><p style="margin:0px 0px 20px;padding:0px;">  ((Short _) 1)</p><p style="margin:0px 0px 20px;padding:0px;">  ((VeryLooooooooooooooooooooooooog _) 2))</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">最后我们发现，这个表达式“进化”成了 Lisp 的 case 表达式。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Lisp 的很多其它的设计，比如“垃圾回收”，后来被很多现代语言（比如 Java）所借鉴。可是人们遗漏了一个很重要的东西：Lisp 的语法，其实才是世界上最好的语法。</p></div></div></div><div style="margin: 0px; padding: 10px 0px 0px; zoom: 1;"><div style="text-align: left; margin: 0px auto; padding: 10px 0px 30px; zoom: 1; width: 300px; border-bottom-width: 3px; border-bottom-style: solid; border-top-color: rgb(240, 240, 240); border-right-color: rgb(240, 240, 240); border-bottom-color: rgb(240, 240, 240); border-left-color: rgb(240, 240, 240);"><font color="#020202"><span style="font-size: 14px; line-height: 26px;"><br/></span></font></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="919"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><a href="http://yinwang0.lofter.com/post/183ec2_4f630e" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">LOST</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ji2d&amp;amp;amp;url=http://s3.sinaimg.cn/orignal/5d90e82fgd87dce575b92" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd87dce575b92&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><br/><br/><p style="margin:0px 0px 20px;padding:0px;">花了一整个周末，看完了 LOST 的第一季。自认为不会对电视剧上瘾的我，这次彻底的服了。从来没见过这样的电视剧，可以演完一季25集，每集40多分钟，让你完全不明白到底发生了什么事，却让你可以从头看到尾。真是名副其实，让人非常 LOST，却又非常吸引人。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">LOST 的主题，让我想起了（恶搞了）一段很有名的话：“我们来自五湖四海，为了一个共同的革命目标，坐上了同一架飞机，坠落在一个神秘的小岛上……” 剧中的人物来自世界各地，各自都有着稀奇古怪的生活经历。偶然丧父的医生，单身的孕妇，伊拉克的士兵，有爱心的杀人犯，弹吉他的瘾君子，想去野外探险的残疾人，中了彩票之后就天天倒霉的大胖子，…… 这些问题人物，坐上同一架飞机，坠毁在南半球一个荒无人烟的小岛上而幸免于难，居然并非机缘巧合，而是冥冥中另有安排。谁是好人，谁是坏人，让你总是猜不对，模棱两可。到底是什么神秘的力量存在于这个小岛，到底它想要干什么，到最后也没猜得出来。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很可惜的是，LOST 像所有的电视剧一样，晚节不保。第一季看完，就像是吃饱了满汉全席，对剧中人物的背景，以及他们的未来，充满了好奇。然而第二季一开头，就堕入了常规的“电视剧公式”。你用直觉就能感到它在故弄玄虚，故意浪费你的时间。第一季让人颇有好感的一些剧中人物，也变得矫揉造作，故作深沉，却又在言语之中显露出肤浅。这感觉就好像把刚吃进去的营养美味，全都拉了出来，冲进了厕所。可惜啊可惜……</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以看电视剧，还是见好就收，停止在第一季为妙。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="924"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4cbdfa" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">解密“设计模式”</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">有些人问我，你说学习操作系统的最好办法是学习程序设计。那我们是不是应该学习一些“设计模式”（design patterns）。这是一个我很早就有定论，而且经过实践检验的问题，所以想在这里做一个总结。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">总的来说，如果光从字面上讲，程序里确实是有一些“模式”可以发掘的。因为你总是可以借鉴以前的经验，用来构造新的程序。你可以把这种经验叫做“模式”。可是自从《<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">设计模式</a>》（通常叫做 GoF，“Gang of Four”，“四人帮”）这本书在 1994 年发表以来，“设计模式”这个词有了新的，扭曲的含义。它变成了一种教条，带来了公司里程序的严重复杂化以及效率低下。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ipap&amp;amp;amp;url=http://s4.sinaimg.cn/orignal/5d90e82fgd74c8ef24e13" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd74c8ef24e13&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">GoF 借鉴的是一个叫 Christopher Alexander 的建筑师的做法。Alexander 给一些建筑学里的“设计模式”起了名字，试图让建筑师们有一些“共同语言”。可惜的是，Alexander 后来自己都承认，他的实验失败了。因为这些固定的模式，并没能有效地传递精髓的知识，没能让新手成长为出色的建筑师。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">照搬模式东拼西凑，而不能抓住事物的本质，没有“灵感”，其实是设计不出好东西的。这就像照搬“模版”把作文写得再好，也成不了作家一样。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我孤陋寡闻，当听说这本书的时候，我已经学会了函数式编程，正在 Cornell 读 PhD，专攻程序语言设计。有一天由于好奇这书为什么名气这么大，我从图书馆借了一本回来看。我很快的发现，其实这本书的作者只是给早已经存在的编程方法起了一些新的名字而已。当时我就拿起一张纸，把所有的20来个设计模式跟我常用的编程概念做了一个映射。这个映射居然是“多对一”（many-to-one）的。也就是说，多个 GoF 设计模式，居然只对应同一个我每天都用的概念。有些概念是如此的不值一提，以至于我根本不需要一个名字来描述它，更不要说多个名字！</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其中极少数值得一提的“模式”，也许是 visitor 和 interpreter。很可惜的是，只有很少的人明白如何使用它们。所谓的 visitor，本质上就是函数式语言里的含有“模式匹配”（pattern matching）的递归函数。在函数式语言里，这是多么轻松的事情。可是因为 Java 没有模式匹配，所以很多需要类似功能的人就得使用 visitor pattern。为了所谓的“通用性”，他们往往把 visitor pattern 搞出多层继承关系，让你转几道弯也搞不清楚到底哪个 visitor 才是干实事的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实，函数式语言的研究者们早就知道 visitor pattern 是怎么得来的。如果你想知道如何从无到有，一步一步“发明”出 Java 的 visitor pattern，可以参考 <a href="http://blog.sina.com.cn/s/blog_5d90e82f010177qx.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Dan Friedman</a> 跟他的学生 Matthias Felleisen 合写的的另一本“小人书”《A Little Java, A Few Patterns》（发表于 1997 年）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ipap&amp;amp;amp;url=http://s13.sinaimg.cn/orignal/5d90e82fg7bee03d9944c" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fg7bee03d9944c&690.png" type="image/png" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a><br/><br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">而 interpreter （解释器）模式呢？看了作者们写的例子程序之后，我发现他们其实并不会写解释器，或者说他们不知道如何写出优雅的，正确的解释器。如果你想知道如何写出好的解释器，可以参考我的博文《<a href="http://blog.sina.com.cn/s/blog_5d90e82f01018ge9.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">怎样写一个解释器</a>》。</p><p style="margin:0px 0px 20px;padding:0px;">你说我在贬低这本书的真正价值，因为 GoF 说了：“我们的贡献，就是给这些编程方式起名字。这样让广大程序员有共同的语言。” 如果这也叫贡献的话，我就可以写本书，给“空气”，“水”，“猪肉”这些东西全都起个新名字，让大家有“共同的语言”。这不是搞笑吗。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这不是我的一家之言，Peter Norvig 在 1998 年就做了一个<a href="http://norvig.com/design-patterns/ppframe.htm" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">演讲</a>，指出在“动态语言”里面，GoF 的20几个模式，其中绝大部分都“透明”了。也就是说，你根本感觉不到它们的存在。这就像我刚才告诉你的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://norvig.com/design-patterns/ppframe.htm" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd74d36b097cc&690.png" type="image/png" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这里 Norvig 的观点是正确的，不过需要小心一个概念错误。Norvig 对“静态语言”的概念是有局限性的。有的静态语言其实也能传递函数作为参数，而且不像 Java 那样什么都得放进 class 里。这样的静态语言，其实也可以避免大部分 GoF 设计模式。而“动态语言”这个概念，在程序语言的理论里面，其实是没有明确的定义的。“动态语言”其实也能进行某些“静态类型检查”。不过在 1998 年，我还是个啥都不懂的屁孩，所以这里就不跟 Norvig 大叔计较了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">既然老人们都有历史局限性，那么为啥我还跟 GoF 找茬？本来这本书很老了，如果没有人再被它误导的话，这篇博文也就不必存在了。可是当我在 Google 实习的时候，我发现几乎每个程序员的书架上都有一本 GoF！我在 Google 实习了两次，第一次的时候代码全都是我一个人写的，所以没有使用任何 GoF 设计模式。代码直接，精巧而简单。当我第二次回到 Google，发现我的代码里已经被加入了各种 factory，visitor，…… 其实啥好事也没做，只不过让我的代码弯了几道弯，让人难以理解。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可见一本坏书，毁掉的不只是一代程序员。鉴于如此，特发此文。各位新手，希望你们敲响警钟，不要再走上这条老路，写出代码来让大家痛苦。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">至于如何学会写真正好的代码，我在另一篇博文里再讲。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="933"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c5636" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">一种新的操作系统设计</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我一直在试图利用程序语言的设计原理，设计一种超越“Unix 哲学”的操作系统。这里是我的设想：</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">这种系统里面的程序间通信不使用无结构的字符串，而是使用带有类型和结构的数据。在这样的系统里面，“程序”的概念基本上完全消失。系统由一个个的“函数”组成，每个函数都可以调用另外一个函数，通过参数传递数据。每个函数都可以并发执行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于参数是一个数据结构，而不是字符串，这避免了程序间通信繁琐的“编码”和“解码”过程。使得“进程间通信”变得轻而易举。任何函数都可以调用另一个函数来处理特定类型的数据，这使得像 “OLE 嵌入”这样的机制变得极其简单。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">所有函数由同一种先进的高级程序语言写成，所以函数间的调用完全不需要“翻译”。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于这种语言不允许应用程序使用“指针运算”，应用程序不可能产生 segfault 一类愚蠢的错误。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于没有指针运算，系统不再需要现代处理器提供的“内存映射”机制，以及 TLB。这使得内存访问效率大幅提高。而且简化了处理器的设计。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">操作系统使用与应用程序相同的高级语言写成（可能需要支持一些“特权操作”），至于“系统调用”，只不过是调用另外一个函数。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">操作系统的“shell”，不过是一个这种高级语言的 REPL。用户可以在终端输入各种函数调用，从而启动进程的运行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">系统不需要 SQL，不需要关系式数据库。所有的数据都作为“对象”，保存在一个分布式的数据空间。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">系统不需要“文件系统”。所有的数据，包括“进程上下文”自动被“版本控制”，在合适的时候作为对象同步到磁盘。所以即使在机器掉电的情况，绝大部分的数据和进程能够在电源恢复后自动继续运行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">程序员和用户完全不需要知道“数据库”或者“文件系统”的存在。程序假设自己拥有无穷大的空间，可以任意的构造数据。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">为了减少数据的移动，系统根据数据的位置，选择： 1）迁移数据，或者 2）迁移处理数据的“进程”。程序员不需要使用 MapReduce，Hadoop 等，就能进行大规模并行计算。 这个操作系统是如此的“一致”，以至于所有的用户和程序员，只需要学会一种很简单的程序语言。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;">我曾经以为我是第一个想到这个做法的人。可惜的是，调查之后发现，很多人早就已经做出了类似的系统（虽然缺少对把它用于分布式计算的设想）。Lisp Machine 似乎是其中最接近的一个。Oberon 是另外一个。我只能说，英雄所见略同。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="937"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bfb7" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">怎样写一个解释器</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">这是一篇解释器的入门教程。虽然我试图从最基本的原理讲起，尽量让这篇文章不依赖于其它知识，但是这篇教程并不是针对编程的入门知识，所以我假设你已经学会了最基本的 Scheme 和函数式编程。我不是很推崇函数式编程，但它里面确实包含了很重要的一些方法。如果你完全不了解这些，可以读一下 <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">SICP</a> 的第一，二章（或者接下去读 <a href="http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">The Little Schemer</a>)。当然你也可以继续读这篇文章，有不懂的地方再去查资料。我在这里也会讲递归和模式匹配的原理。如果你已经了解这些东西，这里的内容也许可以加深你的理解。<br/><br/>
解释器是一种简单却又深奥的东西，以至于好多人都不会写，或者自认为会写却又不真正的会写。在这个领域里有一些历史遗留下来的误解，以至于很少有人真正的知道如何写出正确的解释器。很多“语言专家”或者“逻辑学家”的解释器代码里面有各种各样的错误，却又以谬传谬，搞得无比复杂。这误解的渊源之深，真是一言难尽。</p><p style="margin:0px 0px 20px;padding:0px;">你必须从最简单的语言开始，逐步增加语言的复杂度，才能构造出正确的解释器。这篇文章就是告诉你如何写出一个最简单的语言 (lambda calculus) 的解释器，并且带有基本的的算术功能，可以作为一个高级计算器来使用。<br/><br/>
一般的程序语言课程往往从语法分析(parsing)开始，折腾 lex 和 yacc 等麻烦却不中用的工具，解决一些根本不需要存在的问题。Parsing 的作用其实只是把字符串解码成程序的语法树（AST）结构。麻烦好久得到了 AST 之后，真正的困难才开始！而很多人在写完 parser 之后就已经倒下了。鉴于这个原因，这里我用所谓的“S-expression”来表示程序的语法树（AST）结构。S-expression （加上 Lisp 对它发自“本能”的处理能力）让我们可以直接跳过 parse 的步骤，进入关键的主题：语义(semantics)。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
这里用的 Scheme 实现是 <a href="http://racket-lang.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Racket</a>。为了让程序简洁，我使用了 Racket 的<a href="http://docs.racket-lang.org/reference/match.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">模式匹配</a>（pattern matching）。我对 Racket 没有特别的好感。但它安装比较方便，而且是免费的。如果你用其它的 Scheme 实现的话，恐怕要自己做一些调整。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">解释器是什么</strong><br/><br/>
首先我们来谈一下解释器是什么。说白了解释器跟计算器差不多。它们都接受一个“表达式”，输出一个 “结果”。比如，得到 '(+ 1 2) 之后就输出 3。不过解释器的表达式要比计算器的表达式复杂一些。解释器接受的表达式叫做“程序”，而不只是简单的算术表达式。从本质上讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p>
需要注意的是，我们的解释器接受的参数是一个表达式的“数据结构”，而不是一个字符串。这里我们用一种叫“S-expression”的数据结构来表示表达式。比如表达式 '(+ 1 2) 里面的内容是三个符号：'+, '1 和 '2，而不是字符串“(+ 1 2)”。从结构化的数据里面提取信息很方便，而从字符串里提取信息很麻烦，而且容易出错。
<p style="margin:0px 0px 20px;padding:0px;">从广义上讲，解释器是一个通用的概念。计算器实际上是解释器的一种形式，只不过它处理的语言比程序的解释器简单很多。也许你会发现，CPU 和人脑，从本质上来讲也是解释器，因为解释器的本质实际上是“任何用于处理语言的机器”。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">递归定义 (recursive definition)</strong><br/><br/>
解释器一般都是“递归程序”。之所以是递归的原因，在于它处理的数据结构（程序）本身是“递归定义”的结构。算术表达式就是一个这样的结构，比如：'(* (+ 1 2) (* (- 9 6) 4))。每一个表达式里面可以含有子表达式，子表达式里面还可以有子表达式，如此无穷无尽的嵌套。看似很复杂，其实它的定义不过是：<br/><br/>
“算术表达式”有两种形式：<br/>
  1) 一个数<br/>
  2) 一个 '(op e1 e2) 这样的结构（其中 e1 和 e2 是两个“算术表达式”）<br/><br/>
看出来哪里在“递归”了吗？我们本来在定义“算术表达式”这个概念，而它的定义里面用到了“算术表达式”这个概念本身！这就构造了一个“回路”，让我们可以生成任意深度的表达式。<br/><br/>
很多其它的数据，包括自然数，都是可以用递归来定义的。比如常见的对自然数的定义是：<br/><br/>
“自然数”有两种形式：<br/>
  1) 零<br/>
  2) 某个“自然数”的后继<br/><br/>
看到了吗？“自然数”的定义里面出现了它自己！这就是为什么我们有无穷多个自然数。<br/><br/>
所以可以说递归是无所不在的，甚至有人说递归就是自然界的终极原理。递归的数据总是需要递归的程序来处理。虽然递归有时候表现为另外的形式，比如循环(loop)，但是“递归”这个概念比“循环”更广泛一些。有很多递归程序不能用循环来表达，比如我们今天要写的解释器就是一个递归程序，它就不能用循环来表达。所以写出正确的递归程序，对于设计任何系统都是至关重要的。其实递归的概念不限于程序设计。在数学证明里面有个概念叫“归纳法”(induction)，比如“数学归纳法”(mathematical induction)。其实归纳法跟递归完全是一回事。<br/><br/>
我们今天的解释器就是一个递归程序。它接受一个表达式，递归的调用它自己来处理各个子表达式，然后把各个递归的结果组合在一起，形成最后的结果。这有点像二叉树遍历，只不过我们的数据结构（程序）比二叉树复杂一些。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">模式匹配和递归：一个简单的计算器</strong><br/><br/>
既然计算器是一种最简单的解释器，那么我们为何不从计算器开始写？下面就是一个计算器，它可以计算四则运算的表达式。这些表达式可以任意的嵌套，比如 '(* (+ 1 2) (+ 3 4))。我想从这个简单的例子来讲一下模式匹配(pattern matching) 和递归 (recursion) 的原理。<br/><br/>
下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果，正如上一节所示。<br/><br/>
(define calc<br/>
  (lambda (exp)<br/>
    (match exp                                ; 匹配表达式的两种情况<br/>
      [(? number? x) x]                       ; 是数字，直接返回<br/>
      [`(,op ,e1 ,e2)                         ; 匹配并且提取出操作符 op 和两个操作数 e1, e2<br/>
       (let ([v1 (calc e1)]                   ; 递归调用 calc 自己，得到 e1 的值<br/>
             [v2 (calc e2)])                  ; 递归调用 calc 自己，得到 e2 的值<br/>
         (match op                            ; 分支：处理操作符 op 的 4 种情况<br/>
           ['+ (+ v1 v2)]                     ; 如果是加号，输出结果为 (+ v1 v2)<br/>
           ['- (- v1 v2)]                     ; 如果是减号，乘号，除号，相似的处理<br/>
           ['* (* v1 v2)]<br/>
           ['/ (/ v1 v2)]))])))<br/><br/><br/>
这里的 match 语句是一个模式匹配。它的形式是这样：<br/><br/>
(match exp<br/>
  [模式 结果]<br/>
  [模式 结果]<br/>
   ...   ...<br/>
)<br/><br/>
它根据表达式 exp 的“结构”来进行“分支”操作。每一个分支由两部分组成，左边的是一个“模式”，右边的是一个结果。左边的模式在匹配之后可能会绑定一些变量，它们可以在右边的表达式里面使用。<strong style="font-style:normal;font-weight:bold;font-size:100%;"><br/><br/>
一般说来，数据的“定义”有多少种情况，用来处理它的“模式”就有多少情况。</strong>比如算术表达式有两种情况，数字或者 (op e1 e2)。所以用来处理它的 match 语句就有两种模式。“你所有的情况，我都能处理”，这就是“穷举法”。穷举的思想非常重要，你漏掉的任何一种情况，都非常有可能带来麻烦。所谓的“数学归纳法”，就是这种穷举法在自然数的递归定义上面的表现。因为你穷举了所有的自然数可能被构造的两种形式，所以你能确保定理对“任意自然数”成立。<br/><br/>
那么模式是如何工作的呢？比如 '(,op ,e1 ,e2) 就是一个模式（pattern），它被用来匹配输入的 exp。模式匹配基本的原理就是匹配与它“结构相同”的数据。比如，如果 exp 是 '(+ 1 2)，那么 '(,op ,e1 ,e2) 就会把 op 绑定到 '+，把 e1 绑定到 '1，把 e2 绑定到 '2。这是因为它们结构相同：<br/><br/>
'(,op ,e1 ,e2)<br/>
'( +   1   2)<br/><br/>
说白了，模式就是一个可以含有“名字”（像 op, e1 和 e2）的“数据结构”，像 '(,op ,e1 ,e2)。我们拿这个带有名字的结构去“匹配”实际的数据（像 '(+ 1 2))。当它们一一对应之后，这些名字就自动被绑定到实际数据里相应位置的值。模式里面不但可以含有名字，也可以含有具体的数据。比如你可以构造一个模式 '(,op ,e1 42)，用来匹配第二个操作数固定为 42 的那些表达式。</p><p style="margin:0px 0px 20px;padding:0px;">看见左边的模式，你就像直接“看见”了输入数据的形态，然后对里面的元素进行操作。它可以让我们一次性的“拆散”(destruct) 数据结构，把各个部件（域）的值绑定到多个变量，而不需要使用多个访问函数。所以模式匹配是非常直观的编程方式，值得每种语言借鉴。很多函数式语言里都有类似的功能，比如 ML 和 Haskell。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
注意这里 e1 和 e2 里面的操作数还不是值，它们是表达式。我们递归的调用 interp1 自己，分别得到 e1 和 e2 的值 v1 和 v2。它们应该是数字。<br/><br/>
你注意到我们在什么地方使用了递归吗？如果你再看一下“算术表达式”的定义：<br/><br/>
“算术表达式”有两种形式：<br/>
  1) 一个数<br/>
  2) 一个 '(op e1 e2) 这样的结构（其中 e1 和 e2 是两个“算术表达式”）<br/><br/>
你就会发现这个定义里面“递归”的地方就是 e1 和 e2，所以 calc 在 e1 和 e2 上面递归的调用自己。如果你在数据定义的每个递归处都进行递归，那么你的递归程序就会穷举所有的情况。<br/><br/>
之后，我们根据操作符 op 的不同，对这两个值 v1 和 v2 分别进行操作。如果 op 是加号 '+，我们就调用 Scheme 的加法操作，作用于 v1 和 v2，并且返回运算所得的值。如果是减号，乘号，除号，我们也进行相应的操作，返回它们的值。<br/><br/>
所以你就可以得到如下的测试结果：<br/><br/>
(calc '(+ 1 2))<br/>
;; =&gt; 3<br/><br/>
(calc '(* 2 3))<br/>
;; =&gt; 6<br/><br/>
(calc '(* (+ 1 2) (+ 3 4)))<br/>
;; =&gt; 21<br/><br/>
一个计算器就是这么简单。你可以试试这些例子，然后自己再做一些新的例子。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">什么是 lambda calculus？</strong><br/><br/>
现在让我们过渡到一种更强大的语言：lambda calculus。它虽然名字看起来很吓人，但是其实非常简单。它的三个元素分别是是：变量，函数，调用。用传统的表达法，它们看起来就是：<br/><br/>
变量：x<br/>
函数：λx.t<br/>
调用：t1 t2<br/><br/>
每个程序语言里面都有这三个元素，只不过具体的语法不同，所以你其实每天都在使用 lambda calculus。用 Scheme 作为例子，这三个元素看起来就像：<br/><br/>
变量：x<br/>
函数：(lambda (x) e)<br/>
调用：(e1 e2)<br/><br/>
一般的程序语言还有很多其它的结构，可是这三个元素却是缺一不可的。所以构建解释器的最关键步骤就是把这三个东西搞清楚。构造任何一个语言的解释器一般都是从这三个元素开始，在确保它们完全正确之后才慢慢加入其它的元素。</p><p style="margin:0px 0px 20px;padding:0px;">有一个很简单的思维方式可以让你直接看到这三元素的本质。记得我说过，每个程序都是一个“机器的描述”吗？所以每个 lambda calculus 的表达式也是一个机器的描述。这种机器跟电子线路非常相似。lambda calculus 的程序和机器有这样的一一对应关系：一个变量就是一根导线。一个函数就是某种电子器件的“样板”，有它自己的输入和输出端子，自己的逻辑。一个调用都是在设计中插入一个电子器件的“实例”，把它的输入端子连接到某些已有的导线，这些导线被叫做“参数”。所以一个 lambda calculus 的解释器实际上就是一个电子线路的模拟器。所以如果你听说有些芯片公司开始用类似 Haskell 的语言（比如 Bluespec System Verilog）来设计硬件，也就不奇怪了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
需要注意的是，跟一般语言不同，lambda calculus 的函数只有一个参数。这其实不是一个严重的限制，因为 lambda calculus 的函数可以被作为值传递 (这叫 first-class function)，所以你可以用嵌套的函数定义来表示两个以上参数的函数。比如，(lambda (x) (lambda (y) y)) 就可以表示一个两个参数的函数，它返回第二个参数。不过当它被调用的时候，你需要两层调用，就像这样：<br/><br/>
(((lambda (x) (lambda (y) y)) 1) 2)<br/>
;; =&gt; 2<br/><br/>
虽然看起来丑一点，但是它让我们的解释器达到终极的简单。简单对于设计程序语言的人是至关重要的。一开头就追求复杂的设计，往往导致一堆纠缠不清的问题。<br/><br/>
lambda calculus 不同于普通语言的另外一个特点就是它没有数字等基本的数据类型，所以你不能直接用 lambda calculus 来计算像 (+ 1 2) 这样的表达式。但是有意思的是，数字却可以被 lambda calculus 的三个基本元素“编码”(encoding) 出来。这种编码可以用来表示自然数，布尔类型，pair，list，以至于所有的数据结构。它还可以表示 if 条件语句等复杂的语法结构。常见的一种这样的编码叫做 <a href="http://en.wikipedia.org/wiki/Church_encoding" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Church encoding</a>。所以 lambda calculus 其实可以产生出几乎所有程序语言的功能。中国的古话“三生万物”，也许就是这个意思。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">求值顺序，call-by-name, call-by-value</strong><br/><br/>
当解释一个程序的时候，我们可以有好几种不同的“求值顺序”(evaluation order)。这有点像遍历二叉树有好几种不同的顺序一样（中序，前序，后序）。只不过这里的顺序更加复杂一些。比如下面的程序：<br/><br/>
((lambda (x) (* x x)) (+ 1 2))<br/><br/>
我们可以先执行最外层的调用，把 (+ 1 2) 传递进入函数，得到 (* (+ 1 2) (+ 1 2))。所以求值顺序是：<br/><br/>
((lambda (x) (* x x)) (+ 1 2))<br/>
=&gt; (* (+ 1 2) (+ 1 2))<br/>
=&gt; (* 3 (+ 1 2))<br/>
=&gt; (* 3 3)<br/>
=&gt; 9<br/><br/>
但是我们也可以先算出 (+ 1 2) 的结果，然后再把它传进这个函数。所以求值顺序是：<br/><br/>
((lambda (x) (* x x)) (+ 1 2))<br/>
=&gt; ((lambda (x) (* x x)) 3)<br/>
=&gt; (* 3 3)<br/>
=&gt; 9<br/><br/>
我们把第一种方式叫做 call-by-name (CBN)，因为它把参数的“名字”（也就是表达式自己）传进函数。我们把第二种方式叫做 call-by-value (CBV)，因为它先把参数的名字进行解释，得到它们的“值”之后，才把它们传进函数。<br/><br/>
这两种解释方式的效率是不一样的。从上面的例子，你可以看出 CBN 比 CBV 多出了一步。为什么呢？因为函数 (lambda (x) (* x x)) 里面有两个 x，所以 (+ 1 2) 被传进函数的时候被复制了一份。之后我们需要对它的每一拷贝都进行一次解释，所以 (+ 1 2) 被计算了两次！<br/><br/>
鉴于这个原因，几乎所有的程序语言都采用 CBV，而不是 CBN。CBV 常常被叫做“strict”或者“applicative order”。虽然 CBN 效率低下，与它等价的一种顺序 call-by-need 却没有这个问题。call-by-need 的基本原理是对 CBN 中被拷贝的表达式进行“共享”和“记忆”。当一个表达式的一个拷贝被计算过了之后，其它的拷贝自动得到它的值，从而避免重复求值。call-by-need 也叫“lazy evaluation”，它是 Haskell 语言所用的语义。<br/><br/>
求值顺序不只停留于 call-by-name, call-by-value, call-by-need。人们还设计了很多种其它的求值顺序，虽然它们大部分都不能像 call-by-value 和 call-by-need 这么实用。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">完整的 lambda calculus 解释器<br/><br/></strong>下面是我们今天要完成的解释器，它只有39行（不包括空行和注释）。你可以先留意一下各个部分的注释，它们标注各个部件的名称，并且有少许讲解。这个解释器实现的是 CBV 顺序的 lambda calculus，外加基本的算术。加入基本算术的原因是为了可以让初学者写出比较有趣一点的程序，不至于一开头就被迫去学 Church encoding。<br/><br/><br/>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br/><br/>
;;; 以下三个定义 env0, ent-env, lookup 是对环境（environment）的基本操作：<br/><br/>
;; 空环境<br/>
(define env0 '())<br/><br/>
;; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境<br/>
(define ext-env<br/>
  (lambda (x v env)<br/>
    (cons `(,x . ,v) env)))<br/><br/>
;; 查找。在环境中 env 中查找 x 的值<br/>
(define lookup<br/>
  (lambda (x env)<br/>
    (let ([p (assq x env)])<br/>
      (cond<br/>
       [(not p) x]<br/>
       [else (cdr p)]))))<br/><br/>
;; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境<br/>
(struct Closure (f env))<br/><br/>
;; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）<br/>
;; 共 5 种情况（变量，函数，调用，数字，算术表达式）<br/>
(define interp1<br/>
  (lambda (exp env)<br/>
    (match exp                                          ; 模式匹配 exp 的以下情况（分支）<br/>
      [(? symbol? x) (lookup x env)]                    ; 变量<br/>
      [(? number? x) x]                                 ; 数字<br/>
      [`(lambda (,x) ,e)                                ; 函数<br/>
       (Closure exp env)]<br/>
      [`(,e1 ,e2)                                       ; 调用<br/>
       (let ([v1 (interp1 e1 env)]<br/>
             [v2 (interp1 e2 env)])<br/>
         (match v1<br/>
           [(Closure `(lambda (,x) ,e) env1)<br/>
            (interp1 e (ext-env x v2 env1))]))]<br/>
      [`(,op ,e1 ,e2)                                   ; 算术表达式<br/>
       (let ([v1 (interp1 e1 env)]<br/>
             [v2 (interp1 e2 env)])<br/>
         (match op<br/>
           ['+ (+ v1 v2)]<br/>
           ['- (- v1 v2)]<br/>
           ['* (* v1 v2)]<br/>
           ['/ (/ v1 v2)]))])))<br/><br/>
;; 解释器的“用户界面”函数。它把 interp1 包装起来，掩盖第二个参数，初始值为 env0</p><p style="margin:0px 0px 20px;padding:0px;">(define interp<br/>
  (lambda (exp)<br/>
    (interp1 exp env0)))<br/><br/>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br/><br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">测试例子</strong><br/><br/>
这里有一些测试的例子。你最好先玩一下再继续往下看，或者自己写一些新的例子。学习程序的最好办法就是玩弄这个程序，给它一些输入，观察它的行为。有时候这比任何语言的描述都要直观和清晰。<br/><br/>
(interp '(+ 1 2))<br/>
;; =&gt; 3<br/><br/>
(interp '(* 2 3))<br/>
;; =&gt; 6<br/><br/>
(interp '(* 2 (+ 3 4)))<br/>
;; =&gt; 14<br/><br/>
(interp '(* (+ 1 2) (+ 3 4)))<br/>
;; =&gt; 21<br/><br/>
(interp '(((lambda (x) (lambda (y) (* x y))) 2) 3))<br/>
;; =&gt; 6<br/><br/>
(interp '((lambda (x) (* 2 x)) 3))<br/>
;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">(interp '((lambda (y) (((lambda (y) (lambda (x) (* y 2))) 3) 0)) 4))<br/>
;; =&gt; 6<br/><br/>
;; (interp '(1 2))<br/>
;; =&gt; match: no matching clause for 1<br/><br/><br/>
在接下来的几节，我们来看看这个解释器里主要的分支（match）表达式的各种情况。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;"><br/><br/>
对基本算术操作的解释</strong><br/><br/>
算术操作在解释器里是最简单也是最“基础”的东西，因为它们不能再被细分为更小的元素了。所以在接触函数，调用等复杂的结构之前，我们来看一看对算术操作的处理。以下就是这个解释器里处理基本算术的部分，它是 interp1 的最后一个分支。<br/><br/>
    (match exp<br/>
      ... ...<br/>
      [`(,op ,e1 ,e2)<br/>
       (let ([v1 (interp1 e1 env)]            ; 递归调用 interp1 自己，得到 e1 的值<br/>
             [v2 (interp1 e2 env)])           ; 递归调用 interp1 自己，得到 e2 的值<br/>
         (match op                            ; 分支：处理操作符 op 的 4 种情况<br/>
           ['+ (+ v1 v2)]                     ; 如果是加号，输出结果为 (+ v1 v2)<br/>
           ['- (- v1 v2)]                     ; 如果是减号，乘号，除号，相似的处理<br/>
           ['* (* v1 v2)]<br/>
           ['/ (/ v1 v2)]))])<br/><br/>
你可以看到它几乎跟刚才写的计算器一模一样，不过现在 interp1 的调用多了一个参数 env 而已。这个 env 是什么，我们下面很快就讲。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">变量和函数</strong><br/><br/>
我想用两个小节来简单介绍一下变量，函数和环境。稍后的几节我们再来看它们是如何实现的。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">变量</strong>(variable)的产生是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使得<strong style="font-style:normal;font-weight:bold;font-size:100%;">函数</strong>的实现成为可能。比如数学函数 f(x) = x * 2，其中 x 是一个变量，它把输入的值传递到函数的主体“x * 2”里面。如果没有变量，函数就不可能实现。<br/><br/>
对变量的最基本的操作是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 f(x) 作为例子吧。当 x 等于 1 的时候，f(x) 的值是 2，而当 x 等于 2 的时候，f(x) 的值是 4。在上面的句子里，我们对 x 进行了两次绑定。第一次 x 被绑定到了 1，第二次被绑定到了 2。你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 f(x) 里面的那个 x，而 x * 2 里面的 x，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该几乎相等。有点跑题了…… 反正只要记住一点：绑定就是插进插座的那个“动作”。<br/><br/>
那么“取值”呢？再想一下前面的例子，当我们用伏特表测电线另外一端的电压的时候，我们就是在对这个变量进行取值。有时候这种取值的过程不是那么明显，比如电流如果驱动了风扇的电动机。虽然电线的另外一头没有显示电压，其实电流已经作用于电动机的输入端子，进入线圈。所以你也可以说其实是电动机在对变量进行取值。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">环境</strong><br/><br/>
我们的解释器是一个挺笨的程序，它只能一步一步的做事情。比如，当它需要求 f(1) 的值的时候，它做以下两步操作：1) 把 x 绑定到 1; 2) 进入 f 的函数体对 x * 2 进行求值。这就像一个人做出这两个动作：1)把插头插进插座，2) 走到电线的另外一头测量它的电压，并且把结果乘以 2。在第一步和第二步之间，我们如何记住 x 的值呢？它必须被传递到那个用来处理函数体的递归解释器里面。这就是为什么我们需要“<strong style="font-style:normal;font-weight:bold;font-size:100%;">环境</strong>”，也就是 interp1 的第二个参数 env。<br/><br/>
环境记录变量的值，并且把它们传递到它们的“可见区域”，用术语说就叫做“作用域”(scope)。通常作用域是整个函数体，但是有一个例外，就是当函数体内有嵌套的函数定义的时候，内部的那个函数如果有同样的参数名，那么外层的参数名就会被“屏蔽”（shadow）掉。这样内部的函数体就看不到外层的参数了，只看到它自己的。比如 (lambda (x) (lambda (x) (* x 2)))，里面的那个 x 看到的就是内层函数的 x，而不是外层的。<br/><br/>
在我们的解释器里，用于处理环境的主要部件如下：<br/><br/>
;; 空环境<br/>
(define env0 '())<br/><br/>
;; 对环境 env 进行扩展，把 x 映射到 v<br/>
(define ext-env<br/>
  (lambda (x v env)<br/>
    (cons `(,x . ,v) env)))<br/><br/>
;; 取值。在环境中 env 中查找 x 的值<br/>
(define lookup<br/>
  (lambda (x env)<br/>
    (let ([p (assq x env)])<br/>
      (cond<br/>
       [(not p) x]<br/>
       [else (cdr p)]))))<br/><br/>
这里我们用的是 Scheme 的 association list 来表示环境。Association list 看起来像这个样子：((x . 1) (y . 2) (z . 5))。也就是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写的直观一点就是：</p><p style="margin:0px 0px 20px;padding:0px;">((x . 1)</p><p style="margin:0px 0px 20px;padding:0px;"> (y . 2)</p><p style="margin:0px 0px 20px;padding:0px;"> (z . 5))</p><p style="margin:0px 0px 20px;padding:0px;">查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？</p><br/><p style="margin:0px 0px 20px;padding:0px;">ext-env 扩展一个环境。比如，如果原来的环境是 ((y . 2) (z . 5)) 那么 (ext-env x 1 ((y . 2) (z . 5)))，就会得到 ((x . 1) (y . 2) (z . 5))。也就是把 (x . 1) 放到最前面去。值得注意的一点是，环境被扩展以后其实是形成了一个新的环境，原来的环境并没有被“改变”。比如上面红色的部分就是原来的数据结构，只不过它被放到另一个更大的结构里面了。这叫做“函数式数据结构”。这个性质在我们的解释器里是至关重要的，因为当我们扩展了一个环境之后，其它部分的代码仍然可以原封不动的访问扩展前的那个旧的环境。当我们讲到调用的时候也许你就会发现这个性质的用处。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你也可以用另外的，更高效的数据结构（比如 splay tree）来表示环境。你甚至可以用函数来表示环境。唯一的要求就是，它是变量到值的“映射”(map)。你把 x 映射到 1，待会儿查询 x 的值，它应该仍然是 1，而不会消失掉或者别的值。也就是说，这几个函数要满足这样的一种“界面约定”：如果 e 是 (ext-env 'x 1 env) 返回的环境，那么 (lookup 'x e) 应该返回 1。只要满足这样的界面约定的函数都可以被叫做 ext-env 和 lookup，以至于可以它们用来完全替代这里的函数而不会导致其它代码的修改。这叫做“抽象”，也就是“面向对象语言”的精髓所在。<br/><br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对变量的解释</strong><br/><br/>
了解了变量，函数和环境，让我们来看看解释器对变量的操作，也就是 interp1 的 match 的第一种情况。它非常简单，就是在环境中查找变量的值。这里的 (? symbol? x) 是一个特殊的模式，它使用 Scheme 函数 symbol? 来判断输入是否匹配，如果是的就把它绑定到 x，查找它的值，然后返回这个值。<br/><br/>
      [(? symbol? x) (lookup x env)]<br/><br/>
注意由于我们的解释器是递归的，所以这个值也许会被返回到更高层的表达式，比如 (* x 2)。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对数字的解释</strong><br/><br/>
对数字的解释也很简单。由于在 Scheme 里面名字 '2 就是数字 2（我认为这是 Scheme 设计上的一个小错误），所以我们不需要对数字的名字做特殊的处理，把它们原封不动的返回。<br/><br/>
[(? number? x) x]<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对函数的解释</strong><br/><br/>
对函数的解释是一个比较难说清楚的问题。由于函数体内也许会含有外层函数的参数，比如 (lambda (y)(lambda (x) (* <strong style="font-style:normal;font-weight:bold;font-size:100%;">y</strong> 2))) 里面的 y 是外层函数的参数，却出现在内层函数定义中。如果内层函数被作为值返回，那么 (* y 2) 就会跑到 y 的作用域以外。所以我们必须把函数做成“<strong style="font-style:normal;font-weight:bold;font-size:100%;">闭包</strong>”(closure)。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。所以我们对 (lambda (x) e) 这样一个函数的解释就是这样：<br/><br/>
      [`(lambda (,x) ,e)<br/>
       (Closure exp env)]<br/><br/>
注意这里的 exp 就是 `(lambda (,x) ,e) 自己。我们只是把它包装了一下，把它与当前的环境一起放到一个数据结构(闭包)里，并不进行任何复杂的运算。这里我们的闭包用的是一个 Racket 的 struct 结构，也就是一个记录类型(record)。你也可以用其它形式来表示闭包，比如有些解释器教程提倡用函数来表示闭包。其实用什么形式都无所谓，只要能存储 exp 和 env 的值。我比较喜欢使用 struct，因为它的界面简单清晰。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
为什么需要保存当前的环境呢？因为当这个函数被作为一个值返回的时候，我们必须记住里面的外层函数的参数的绑定。比如，(lambda (y) (lambda (x) (* y 2)))。当它被作用于 1 之后，我们会得到内层的函数 (lambda (x) (* y 2))。当这个函数被经过一阵周折之后再被调用的时候，y 应该等于几呢？正确的做法应该是等于1。这种把外层参数的值记录在内层函数的闭包里的做法，叫做“lexical scoping”或者“static scoping”。<br/><br/>
如果你不做闭包，而是把函数体直接返回，那么在 (lambda (x) (* y 2)) 被调用的位置，你可能会另外找到一个 y，从而使用它的值。在调用的时候“动态”解析变量的做法，叫做“dynamic scoping”。事实证明 dynamic scoping 的做法是严重错误的，它导致了早期语言里面出现的各种很难发现的bug。很多早期的语言是 dynamic scoping，就是因为它们只保存了函数的代码，而没有保存它定义处的环境。这样要简单一些，但是带来太多的麻烦。早期的 Lisp，现在的 Emacs Lisp 和 TeX 就是使用 dynamic scoping 的语言。</p><p style="margin:0px 0px 20px;padding:0px;">为了演示 lexical scoping 和 dynamic scoping 的区别。你可以在我们的解释器里执行以下代码：</p><p style="margin:0px 0px 20px;padding:0px;">(interp '((lambda (y) (((lambda (y) (lambda (x) (* y 2))) 3) 0)) 4))</p><p style="margin:0px 0px 20px;padding:0px;">其中红色的部分就是上面提到的例子。在这里，(* y 2) 里的 y，其实是最里面的那个 (lambda (y) ...) 里的。当红色部分被作用于 3 之后。 (lambda (x) (* y 2)) 被作为一个值返回。然后它被作用于 0（x 被绑定到 0，被忽略），所以 (* y 2) 应该等于 6。但是如果我们的解释器是 dynamic scoping，那么最后的结果就会等于 8。这是因为最外层的 y 开头被绑定到了 4，而 dynamic scoping 没有记住内层的 y 的值，所以使用了外层那个 y 的值。<br/><br/>
为什么 Lexical scoping 更好呢？你可以从很简单的直觉来理解。当你构造一个“内部函数”的时候，如果它引用了外面的变量，比如这个例子里的 y，那么从外层的 y 到这个函数的内部，出现了一条“信道”（channel）。你可以把这个内部函数想象成一个电路元件，它的内部有一个节点 y 连接到一根从外部来的电线 y。当这个元件被返回，就像这个元件被挖出来送到别的地方去用。但是在它被使用的地方（调用），这个 y 节点应该从哪里得到输入呢？显然你不应该使用调用处的某个 y，因为这个 y 和之前的那个 y，虽然都叫 y，却不是“同一个 y”，也就是同名异义。它们甚至可以代表不同的类型的东西。所以这个 y 应该仍然连接原来的那根 y 电线。当这个内部元件移动的时候，就像这跟电线被无限的延长，但是它始终连接到原来的节点。<br/><br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对函数调用的解释</strong><br/><br/>
好，我们终于到了最后的关头，函数调用。函数调用都是 (e1 e2) 这样的形式，所以我们需要先分别求出 e1 和 e2 的值。这跟基本运算的时候需要先求出两个操作数的值相似。<br/><br/>
函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 (lambda (x) (* x 2)) 被作用于 1 时，我们把 x 绑定到 1，然后解释它的函数体 (* x 2)。但是这里有一个问题，如果函数体内有未绑定的变量，它应该取什么值呢？从上面闭包的讨论，你已经知道了，其实操作数 e1 被求值之后应该是一个闭包，所以它的里面应该有未绑定变量的值。所以，我们就把这个闭包中保存的环境(env1)取出来，扩展它，把 x 绑定到 v2，然后用这个扩展后的环境来解释函数体。<br/><br/>
所以函数调用的代码如下：<br/><br/>
      [`(,e1 ,e2)                                            <br/>
       (let ([v1 (interp1 e1 env)]<br/>
             [v2 (interp1 e2 env)])<br/>
         (match v1<br/>
           [(Closure `(lambda (,x) ,e) env1)   ; 用模式匹配的方式取出闭包里的各个子结构<br/>
            (interp1 e (ext-env x v2 env1))]   ; 在<strong style="font-style:normal;font-weight:bold;font-size:100%;">闭包的环境</strong>中把 x 绑定到 v2，解释函数体<br/>
           ))]<br/><br/>
你可能会奇怪，那么解释器的环境 env 难道这里就不用了吗？是的。我们通过 env 来计算 e1 和 e2 的值，是因为 e1 和 e2 里面的变量存在于“当前环境”。我们把 e1 里面的环境 env1 取出来用于计算函数体，是因为函数体并不是在当前环境定义的，它的代码在别的地方。如果我们用 env 来解释函数体，那就成了 dynamic scoping。<br/><br/>
实验：你可以把 (interp1 e (ext-env x v2 env1)) 里面的 env1 改成 env，再试试我们之前讨论过的代码，它的输出就会是 8：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(interp '((lambda (y) (((lambda (y) (lambda (x) (* y 2))) 3) 0)) 4))</p><br/>
另外在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下几乎不可能有效的控制。每一次当我使用赋值操作来修改环境，最后都会出现意想不到的麻烦。所以在写解释器，编译器的时候，我都只使用函数式数据结构来表示环境。
<p style="margin:0px 0px 20px;padding:0px;"><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">下一步</strong><br/><br/>
在懂得了这里讲述的基本的解释器构造之后，下一步可以做什么呢？其实从这个基本的解释器原型，你可以进一步发展出很多内容，比如：</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">在这个解释器里加一些构造，比如递归和状态，你就可以得到一个完整的程序语言的解释器，比如 Scheme 或者 Python。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">对这个解释器进行“抽象”，你就可以对程序进行类型推导。感兴趣的话可以参考我实现的这个 <a href="https://github.com/yinwang0/magic/blob/master/infer.ss" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Hindley-Milner系统</a>，或者 <a href="https://github.com/yinwang0/mini-pysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Python 类型推导</a>。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">对这个解释器进行一些改变，就可以得到一个非常强大的 online partial evaluator，可以用于编译器优化。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><span>如果有问题的话，欢迎跟我联系: <a href="http://yinwang0.lofter.com/post/183ec2_47bfb7mailto:shredderyin@gmail.com%E3%80%82%E5%8F%A6%E5%A4%96%E9%9C%80%E8%A6%81%E6%8C%87%E5%87%BA%E7%9A%84%E6%98%AF%EF%BC%8C%E5%AD%A6%E4%BC%9A%E8%BF%99%E4%B8%AA%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B9%B6%E4%B8%8D%E7%AD%89%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%90%86%E8%AE%BA%E3%80%82%E6%89%80%E4%BB%A5%E5%9C%A8%E5%AD%A6%E4%BC%9A%E4%BA%86%E8%BF%99%E4%BA%9B%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%98%E6%98%AF%E8%A6%81%E7%9C%8B%E4%B8%80%E4%BA%9B%E8%AF%AD%E4%B9%89%E5%AD%A6%E7%9A%84%E4%B9%A6%EF%BC%8C%E5%B0%B1%E5%83%8F%E6%88%91%E8%BF%99%E7%AF%87" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">shredderyin@gmail.com。另外需要指出的是，学会这个解释器并不等于理解了程序语言的理论。所以在学会了这些之后，还是要看一些语义学的书，就像我这篇</a></span><a href="http://blog.sina.com.cn/s/blog_5d90e82f010184hx.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博客</a>里推荐的那本。</p></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="941"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c08c" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">好话只说一遍</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　在<a href="http://news.cnblogs.com/n/162799/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">上一番博文</a>然后又收笔之后，收到一些朋友的反馈和鼓励。在此表示感谢。停止写博客其实是我自己的决定，我并没有受到很多的指责，而且这些指责根本不足以对我产生压力。不过一个人的博客一旦被很多人关注，必然带来一定的压力。什么话该说，什么不该说，真的很难判断。</p><p style="margin:0px 0px 20px;padding:0px;">　　科学研究和程序设计都很像艺术。到了一定的境界之后，什么是好的，什么是不好的，跟人是说不清楚的。不真正懂艺术的人往往附庸风雅，言必称“毕加索”。当他遇到一个对毕加索嗤之以鼻的人的时候，当然难以理解，以为他是疯子。所以如果你现在知道某些领域的“头号专家”在我头脑里面的地位，肯定也会以为我是疯子。所以我就懒得评论别人了。我不讨厌这些人，我只是停止赞美或者仰慕他们。</p><p style="margin:0px 0px 20px;padding:0px;">　　我有什么资格说话呢？如果你要了解我的本事，真的很简单：我最精要的代码都放在 <a href="https://github.com/yinwang0/gems" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">GitHub</a> 上了。但是除非接受过专门的训练，你绝对不会理解它们的价值。你会很难想象，这样一片普通人看起来像是玩具的 40 行<a href="https://github.com/yinwang0/gems/blob/master/cps.ss" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">代码</a>，融入了我一个星期的日日夜夜的心血，数以几十计的推翻重写。这段代码，曾经耗费了一些顶尖专家十多年的研究。一个教授告诉我，光是想看懂他们的论文就需要不止一个月。而它却被我在一个星期之内闷头写出来了。我是在说大话吗？代码就摆在那里，自己去看看不就知道了。当我死后，如果有人想要知道什么是我上半生最重要的“杰作”，也就是这 40 行代码了。它蕴含的美，超越我给任何公司写的成千上万行的代码。</p><p style="margin:0px 0px 20px;padding:0px;">　　不说那些了。</p><p style="margin:0px 0px 20px;padding:0px;">　　很多人希望我多“分享”一些东西。我曾经试图大公无私的公开我的知识。但是后来发现，这种好心其实是没有好报的。为什么要把靠自己努力得来的精髓知识不计回报的分享给别人呢？容易得到的东西，往往被当成屎。所以最精华的东西，我还是留下来作为秘密武器比较好。自古以来，武林高手传授弟子都要留一手，里面就有这个原因吧。</p><p style="margin:0px 0px 20px;padding:0px;">　　不过我又想了一下，确实应该分享一些好东西和看法。不然这个世界上就越来越少人知道到底什么是好东西，什么是不好的。他们的头脑里就会充满各种乌七八糟的理论，却自以为了不起，以至于让我找不到可以说话的人。所以我决定，还是不时的写点东西，给这个混沌的世界一点点微弱的阳光。但我不会再像推销员一样那么耐心和“循循善诱”了。从现在开始，我的原则是：好话只说一遍。</p><p style="margin:0px 0px 20px;padding:0px;">　　我一直记得中学的时候，几个同学办了一个小报。头版上写着：“我们想办报，所以我们就办了。你们爱看就看，不看就算了。” 不爱看的人，鄙视我的人，还故意要来看我说什么，那就是心理有问题了，不是吗？很多中国人都有这毛病，厌恶和鄙视别人，却又喜欢关注他们，谈论他们。以至于国内的网络里充满了各种恶毒的言论和坏消息。我就从来不看我不尊敬的人的言论。我只是忽略他们，忘记他们的存在。所以如果你鄙视我，就不要来这里讨气了，去追寻另外一些你认为美好的东西吧。</p></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="946"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c5634" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Markdown 的一些问题</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">把我之前的博文基本上转换成了 markdown 格式。我发现 markdown 虽然在编辑器里看起来比 HTML 清晰一些，但也有一些不足。</p><p style="margin:0px 0px 20px;padding:0px;">这些 markup 语言的格式都有点像我本科的时候给我爸做的一种“<a href="http://www.yinwang.org/blog-cn/2013/04/14/standard-exam-language" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">标准化试卷标记语言</a>”（因为他是中学英语老师）。当时我写了一个1000来行的 Perl 脚本，可以把这种简单的标记语言转换成美观的 LaTeX 格式文档，并且带有友好的 Tk 图形界面。现在回想起来，我那时候的设计就已经相当先进了。跟我的语言相比，这些 blog 用的 markup 语言真是小巫见大巫了，而且问题多多。有点跑题了，还是回头来看看 markdown 的问题吧。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">Markdown 实际上采用的是类似 Python 和 Haskell 的 layout 语法。</p><p style="margin:0px 0px 20px;padding:0px;">我已经在一篇<a href="http://en.yinwang.org/blog-en/2011/05/08/layout" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">英文博文</a>里提到了 layout 语法的多种问题。因为空格的数量决定了文档的结构，这种文档格式相当的“脆弱”。稍微少打一两个空格，就会出现不可预测的结果。这种现象在“itemize”内部的代码块最容易出现。因为每个 item 带来了缩进，所以内部的代码必须比 item 的缩进多4个空格，才能被排到正确的位置。比如我转换博文的时候多次出现以下的情况：</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/markdown-mistake.png" type="image/png" height="451" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="675"/></p><p style="margin:0px 0px 20px;padding:0px;">这里的问题是，代码里的第一行 helloworld z = let x = 1 因为缩进不够，被放到了代码块外面。但是为了准确的缩进所耗费的精力，其实比直接打 &lt;pre&gt; 这样的 tag 还要多。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">特殊字符的选择不合理</p><p style="margin:0px 0px 20px;padding:0px;">markdown 对特殊字符的使用不大合理。我多次发现文档段落整段的变成斜体，就是因为原来的文档里出现了 x*y 这样的表达式。在程序员的世界里，“乘法”显然比“强调”更加频繁。把 * 用于标记“强调”，实际上把一个非常有用的字符用在了很不频繁的用途。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">表达力相当有限</p><p style="margin:0px 0px 20px;padding:0px;">在很多细节上，markdown 并不能表达我想要的格式。比如它不能正确的插入断行&lt;br&gt;。如果你有两块紧接在一起的代码，但你不想把它们连在一起，markdown 非要给你连在一起…… 于是我就发现自己加入了越来越多的 HTML。</p><p style="margin:0px 0px 20px;padding:0px;">这在图片的语法上就更加明显，markdown 引入了 ![alt](image url) 这样的格式，其实比起 HTML 还要难看和不一致。比如现在它仍然无法表达图片的大小，这是相当重要的信息。所以我觉得 markdown 的语法已经显示出了它的弱点，如果它要表达更复杂的信息，就会变得比 HTML 还要难记，难看。所以对于图片，我觉得还不如直接用 HTML 的 &lt;img&gt; 。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;">所以总的感觉是 markdown 引入了太多的“语法”，以至于稍微复杂一点的信息表达起来还不如 HTML 来的直接。现在就这样先凑合着吧。也许过段时间自己设计一个格式。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="948"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/><a href="http://yinwang0.lofter.com/post/183ec2_5c55ed" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">对函数式语言的误解</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很早的时候，“函数式语言”对于我来说就是 Lisp，因为 Lisp 可以在程序的几乎任何位置定义函数，并且把它们作为值来传递（这叫做 first-class function）。后来有人告诉我，Lisp 其实不算是“函数式语言”，因为 Lisp 的函数并不“纯”（pure）。所谓“纯函数”的意思，就是像数学的函数一样，如果你给它同样的输入，它就给你同样的输出。然后你就发现在这种定义下，几乎所有程序语言里面常见的随机数函数（random），其实都不是“纯函数”。因为每一次调用 random()，你都会得到不同的随机数。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这种害怕自己所用的语言“不纯”的恐慌之下，我开始接触 Haskell，一种号称“纯函数式”的语言。Haskell 的社区喜欢在他们的概念里省掉“纯”这个字，把 Haskell 叫做“函数式语言”。他们喜欢“纠正”别人的概念。他们告诉人们，“不纯”的函数式语言，其实都不配叫做“函数式语言”。在他们的这种定义下，Lisp 这么老牌的函数式语言，居然都不能叫“函数式语言”了。但是看完这篇文章你就会发现，其实他们的这种定义是狭隘和错误的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在 Haskell 里面，你不能使用通常语言里面都有的赋值语句，比如 Pascal 里的 x:=1，C 和 Java 里的 x=1，或者 Scheme 里的 (set! x 1)，Common Lisp 里的 (setq x 1）。这样一来，你就不可能保留“状态”（state）。所谓“状态”，就是指“随机数种子”那样的东西，其实本质上就是“全局变量”。比如，在 C 语言里定义 random() 函数，你可以这么做：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">int random()</p><p style="margin:0px 0px 20px;padding:0px;">{</p><p style="margin:0px 0px 20px;padding:0px;">  static int seed = 0;</p><p style="margin:0px 0px 20px;padding:0px;">  seed = next_random(seed);</p><p style="margin:0px 0px 20px;padding:0px;">  return seed;</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这里的 seed 是一个“static 变量”，其本质就是一个全局变量，只不过这个全局变量只能被 random 这一个函数访问。每次调用 random()，它都会使用 next_random(seed) 生成下一个随机数，并且把 seed 的值更新为这个新的随机数。在 random() 的执行结束之后，seed 会一直保存这个值。下一次调用 random()，它就会根据 seed 保存的值，算出下一个随机数，然后再次更新 seed，如此继续。这就是为什么每一次调用 random()，你都会得到不同的随机数。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可是在 Haskell 里面情况就很不一样了。由于 Haskell 不能保留状态，所以同一个“变量”在它作用域的任何位置都具有相同的值。每一个函数只要输入相同，就会输出同样的结果。所以在 Haskell 里面，你不能轻松的表达 random 这样的“不纯函数”。为了让 random 在每次调用得到不同的输出，你必须给它“不同的输入”。那怎么才能给它不同的输入呢？Haskell 采用的办法，就是把“种子”作为输入，然后返回两个值：新的随机数和新的种子，然后想办法把这个新的种子传递给下一次的 random 调用。所以 Haskell 的 random 的“线路”看起来像这个样子：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  （旧种子）---&gt; （新随机数，新种子）</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在问题来了。得到的这个新种子，必须被准确无误的传递到下一个使用 random 的地方，否则你就没法生成下一个随机数。因为没有地方可以让你“暂存”这个种子，所以为了把种子传递到下一个使用它的地方，你经常需要让种子“穿过”一系列的函数，才能到达目的地。种子经过的“路径”上的所有函数，必须增加一个参数（旧种子），并且增加一个返回值（新种子）。这就像是用一根吸管扎穿这个函数，两头通风，这样种子就可以不受干扰的通过。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以你看到了，为了达到“纯函数”的目标，我们需要做很多“管道工”的工作，这增加了程序的复杂性和工作量。如果我们可以把种子存放在一个全局变量里，到需要的时候才去取，那就根本不需要把它传来传去的。除 random() 之外的代码，都不需要知道种子的存在。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为了减轻视觉负担和维护这些进进出出的“状态”，Haskell 引入了一种叫 monad 的概念。它的本质是使用类型系统的“重载”（overloading），把这些多出来的参数和返回值，掩盖在类型里面。这就像把乱七八糟的电线塞进了接线盒似的，虽然表面上看起来清爽了一些，底下的复杂性却是不可能消除的。有时候我很纳闷，在其它语言里易如反掌的事情，为什么到 Haskell 里面就变成了“研究性问题”，很多时候就是 monad 这东西在捣鬼。特别是当你有多个“状态”的时候，你就需要使用像 monad transformer 这样的东西。而 monad transformer 在本质上其实是一个丑陋的 hack，它并不能从根本上解决问题，却可以让你伤透脑筋也写不出来。有些人以为会用 monad 和 monad transformer 就说明他水平高，其实这根本就是自己跟自己过不去而已。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当谈到 monad 的时候，我喜欢打这样一个比方：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">    使用含有 monad 的“纯函数式语言”，就像生活在一个没有电磁波的世界。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这个世界里面没有收音机，没有手机，没有卫星电视，没有无线网，甚至没有光！这个世界里的所有东西都是“有线”的。你需要绞尽脑汁，把这些电线准确无误的通过特殊的“接线器”（monad）连接起来，才能让你的各种信息处理设备能够正常工作，才能让你自己能够看见东西。如果你想生活在这样的世界里的话，那就请继续使用 Haskell。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实要达到纯函数式语言的这种“纯”的效果，你根本不需要使用像 Haskell 这样完全排斥“赋值语句”的语言。你甚至不需要使用 Lisp 这样的“非纯”函数式语言。你完全可以用 C 语言，甚至汇编语言，达到同样的效果。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我只举一个非常简单的例子，在 C 语言里面定义如下的函数。虽然函数体里面含有赋值语句，它却是一个真正意义上的“纯函数”：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">int f(int x) {</p><p style="margin:0px 0px 20px;padding:0px;">    int y = 0;</p><p style="margin:0px 0px 20px;padding:0px;">    int z = 0;</p><p style="margin:0px 0px 20px;padding:0px;">    y = 2 * x;</p><p style="margin:0px 0px 20px;padding:0px;">    z = y + 1;</p><p style="margin:0px 0px 20px;padding:0px;">    return z / 3;</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这是为什么呢？因为它计算的是数学函数 f(x) = (2x+1)/3 。你给它同样的输入，肯定会得到同样的输出。函数里虽然对 y 和 z 进行了赋值，但这种赋值都是“局部”的，它们不会留下“状态”。所以这个函数虽然使用了被“纯函数程序员”们唾弃的赋值语句，却仍然完全的符合“纯函数”的定义。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">如果你研究过编译器，就会理解其中的道理。因为这个函数里的 y 和 z，不过是函数的“数据流”里的一些“中间节点”，它们的用途是用来暂存一些“中间结果”。这些局部的赋值操作，跟函数调用时的“参数传递”没有本质的区别，它们不过都是把信息传送到指定的节点而已。如果你不相信的话，我现在就可以把这些赋值语句全都改写成函数调用：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">int f(int x) {</p><p style="margin:0px 0px 20px;padding:0px;">    return g(2 * x);</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">int g(int y) {</p><p style="margin:0px 0px 20px;padding:0px;">    return h(y + 1);</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">int h(int z) {</p><p style="margin:0px 0px 20px;padding:0px;">    return z/3;</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很显然，这两个 f 的定义是完全等价的，然而第二个定义却没有任何赋值语句。第一个函数里对 y 和 z 的“赋值语句”，被转换成了等价的“参数传递”。这两个程序如果经过我写的编译器，会生成一模一样的机器代码。所以如果你说赋值语句是错误的话，那么函数调用也应该是错误的了。那我们还要不要写程序了？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">盲目的排斥赋值语句，来自于对“纯函数”这个概念的片面理解。很多研究像 Haskell，ML 一类语言的专家，其实并不明白我上面讲的道理。他们仿佛觉得如果使用了赋值，函数就肯定不“纯”了似的。CMU 的教授 Robert Harper 就是这样一个极端。他在一篇<a href="http://existentialtype.wordpress.com/2012/02/01/words-matter/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>里指出，人们不应该把程序里的“变量”叫做“变量”，因为它跟数学和逻辑学里所谓的“变量”不是一回事，它可以被赋值。然而，其果真如他所说的那样吗？如果你理解了我对上面的例子的分析，你就会发现其实程序里的“变量”，跟数学和逻辑学里面的“变量”相比，其实并没有本质的不同。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">程序里的变量甚至更加严格一些。如果你把数学看作一种程序语言的话，恐怕没有一本数学书可以编译通过。因为它们里面充满了变量名冲突，未定义变量，类型错误等程序设计的低级错误。你只需要注意概率论里表示随机数的大写变量（比如 X），就会发现数学所谓的“变量”其实是多么的不严谨。这变量 X 根本不需要被赋值，它自己身上就带“副作用”！实际上，90%以上的数学家都写不出像样的程序来。所以拿数学的“变量”来衡量程序语言的“变量”，其实是颠倒了。我们应该用程序的“变量”来衡量数学的“变量”，这样数学的语言才会有所改善。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">对数学和逻辑学的盲目崇拜，导致了 Harper 做出盲目的判断。这也许不能完全怪他。如果你知道他是 Alonzo Church 的第三代“学术后裔”（Alozon Church --&gt; Stephen Kleene --&gt; Robert Constable --&gt; Robert Harper）并且以此为豪，你就会发现根深蒂固的逻辑学传统，阻碍了他从另外一个角度看问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">逻辑学家虽然有他们的价值，但他们并不是先知，并不总是对的。由于沉迷于对符号的热爱，他们经常看不到事物的本质。虽然他们理解很多符号公式和推理规则，但他们却经常不明白这些符号和推理规则，到底代表着自然界中的什么物体，所以有时候他们连最基本的问题都会搞错（比如他们有时候会混淆“全称量词”∀的作用域）。逻辑学家们的教条主义和崇古作风，也许就是图灵当年在 Church 手下做学生那么孤立，那么痛苦的原因。也就是这个图灵，在某种程度上超越了 Church，把一部分人从逻辑学的死板思维模式下解放了出来，变成了“计算机科学家”。当然其中某些计算机科学家堕入了另外一种极端，他们对逻辑学已有的精华一无所知，所以搞出一些完全没有原则的设计，然而这不是这篇文章的主题。</p><p style="margin:0px 0px 20px;padding:0px;">所以综上所述，我们完全没有必要追求什么“纯函数式语言”，因为我们可以在不引起混淆的前提下使用赋值语句，而写出真正的“纯函数”来。可以自由的对变量进行赋值的语言，其实超越了通常的数理逻辑的表达能力。如果你不相信这一点，就请想一想，数理逻辑的公式有没有能力推断出明天的天气？为什么天气预报都是用程序算出来的，而不是用逻辑公式推出来的？所以我认为，程序其实在某种程度上已经成为比数理逻辑更加强大的逻辑。完全用数理逻辑的思维方式来对程序语言做出评价，其实是很片面的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">说了这么多，对于“函数式语言”这一概念的误解，应该消除得差不多了。其实“函数式语言”唯一的要求，应该是能够在任意位置定义函数，并且能够把函数作为值传递，不管这函数是“纯”的还是“不纯”的。所以像 Lisp 和 ML 这样的语言，其实完全符合“函数式语言”这一称号。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="952"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c5618" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">我为什么离开 Cornell</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人都知道，我曾经在 Cornell 博士就读，两年之后转学到了 Indiana 大学。几乎所有人，包括 Indiana 大学的人都感觉奇怪，为什么会有人从 Cornell 这样的“牛校”转学到 Indiana。我曾经在之前的博文里提到 Cornell 的情况，比如学生一上课就忙着抄笔记，作业压得喘不过气，等等。那些都是实际的情况，所以我没什么必要为我的“母校”说好话。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">离开 Cornell 之后，看到有人在 facebook 上成立了一个“Cornell 痛恨者协会”。其中一个人写到：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“Cornell 说要教你游泳，就把你推进池塘里，任凭你扑腾挣扎。等你快扑腾到岸边的时候，它忽然拿起一块大石头砸在你头上，然后继续等着你上岸。当你再次接近岸边的时候，它又拿起一个榔头敲在你头上，这样你就可以死了，可是 Cornell 仍然继续等着你游上岸边……”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这就是一个非常形象的，对我在 Cornell 的两年的总结。现在看看我在 Indiana 学到了什么，而 Cornell 教会了我什么，感觉简直一个天上一个地下。Dan Friedman 和 R. Kent Dybvig，他们的教育真的像是爱因斯坦所说的，像是珍贵的礼物，而不是沉重的负担。他们教会我的东西，让我不再在乎任何“牛校”的博士学位甚至教授职位，不管是 Cornell, Stanford, Berkeley, MIT 还是 Harvard, ……</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所谓的“牛校”，恐怕都是这样吧。学生对于它们只是一种成为“牛校”的工具。你拼着命要进来，好我让你进来。但是我不教你，我让你拼死的做作业。如果你做出来了，我就拿最偏最扯淡的试卷来考你。如果你通过了所有这些，那我就给你一个学位。你得到了这样的“荣誉”，自然就会说“我的学校很牛”。你不敢说它不牛，因为那样就是说你也不牛了。所以这样的学校其实什么也不用干，你能学会东西能毕业，全都是靠你自己，到时候你却要把功劳都归到学校头上。天底下就是有这样好的生意。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">曾经有一个 Cornell 的校友跟我是朋友。当我提到 Cornell 的一些事，他总是像个老师一样，上气不接下气地“教育”我，也就是说类似家丑不可外扬的意思吧。“牛校”就是一种传染病，在你还没进去之前就已经埋下病种，当你进去之后它就开始蔓延，等你毕业很多年，它仍然与你同在。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="953"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47a18a" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">从工具的奴隶到工具的主人</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">当我高中毕业进入大学计算机系的时候，辅导员对我们说：“你们不要只学书本知识，也要多见识一下业界的动态，比如去电脑城看看人家怎么装机。”当然他说我们要多动手，多长见识，这是对的。不过如果成天就研究怎么“装机”，研究哪种主板配哪种 CPU 之类的东西，你恐怕以后就只有去电脑城卖电脑了。</p><p style="margin:0px 0px 20px;padding:0px;">本科的时候，我经常发现一些同学不来上数学课。后来却发现他们在宿舍自己写程序，对MFC之类的东西津津乐道，引以为豪。当然会用MFC没有什么不好，可是如果你完全沉迷于这些东西，恐怕就完全局限于Windows的一些表面现象了。</p><p style="margin:0px 0px 20px;padding:0px;">所以我在大学的时候就开始折腾Linux，因为它貌似让我能够“深入”到计算机内部。那个时候，书店里只有一本 Linux 的书，封面非常简陋。这是一本非常古老的书，它教的是怎样得到Slackware Linux，然后把它从二三十张软盘装到电脑上。总之，我就是这样开始使用Linux的。后来我就走火入魔了，有时候上课居然在看GCC的内部结构文档。后来我又开始折腾TeX，把TeXbook都看了两遍，恁是用它写了我的本科毕业论文。</p><p style="margin:0px 0px 20px;padding:0px;">后来进了清华，因为不满意有人嘲笑我用Linux这种“像DOS的东西”，以及国内网站都对Windows和IE进行“优化”的情况，就写了个“完全用Linux工作”。确实，会Linux的人现在更容易找到工作，更容易被人当成高手。但是那些工具同样的奴役了我，经常以一些雕虫小技而自豪，让我看不到如何才能设计出新的，更好的东西。当它们的设计改变的时候，我就会像奴隶一样被牵着鼻子走。</p><p style="margin:0px 0px 20px;padding:0px;">这也许就是为什么我在清华的图书馆发现《SICP》的时候如此的欣喜。那本书是崭新的，后面的借书记录几乎是空白的。这些看似简单的东西教会我的，却比那些大部头和各种 HOWTO 教会我的更多，因为它们教会我的是WHY，而不只是HOW。当时我就发现，虽然自认为是一个“资深”的研究生，学过那么多种程序语言，各种系统工具甚至内核实现，可是相对于SICP的认识深度，我其实几乎完全不会写程序！在第三章，SICP 教会了我如何实现一个面向对象系统。这是我第一次感觉到自己真正的在开始认识和控制自己所用的工具。</p><p style="margin:0px 0px 20px;padding:0px;">因为通常人们认为Scheme不是一个“实用”的语言，没有很多“库”可以用，效率也不高，而Common Lisp是“工业标准”，再加上Paul Graham文章的怂恿，所以我就开始了解Common Lisp。在那段时间，我看了Paul Graham的《On Lisp》和Peter Norvig的 《Paradigms of Artificial Intelligence Programming》。怎么说呢？当时我以为自己学到很多，可是现在看来，它们教会我的并没有《SICP》的东西那么精髓和深刻。开头以为一山还有一山高，最后回头望去，其实复杂的东西并不比简单的好。现在当我再看Paul Graham和Peter Norvig的文章，就觉得相当幼稚了，而且有很大的宗教成分。</p><p style="margin:0px 0px 20px;padding:0px;">进入Cornell之后，因为Cornell的程序语言课是用SML的，我才真正的开始学习“静态类型”的函数式语言。之前在清华的时候，有个同学建议我试试ML和Haskell，可是因为我对Lisp 的执着，把他的话当成了耳边风。当然现在用上SML就免不了发现ML的类型系统的一些挠人的问题，所以我就开始了解Haskell，并且由于它看似优美的设计，我把“终极语言”的希望寄托于它。我开始着迷一些像monads，type class，lazy evaluation 一类的东西，看Simon Peyton Jones的一些关于函数式语言编译器的书。以至于走火入魔，对其它一切“常规”语言都持鄙视态度，看到什么都说“那只不过是个monad”。虽然有些语言被鄙视是合理的，有些却是被错怪了的。后来我也发现monad, type class, lazy evaluation这些东西其实并不是什么包治百病的灵丹妙药。</p><p style="margin:0px 0px 20px;padding:0px;">但是我很不喜欢Cornell的压抑气氛，所以最后决定离开。在不知何去何从的时候，我发了一封email给曾经给过我fellowship的IU教授Doug Hofstadter（《GEB》的作者）。我说我不知道该怎么办，后悔来了 Cornell，我现在对函数式语言感兴趣。他跟我说，IU的Dan Friedman就是做函数式语言的啊，你跟他联系一下，就说是我介绍你来的。我开头看过一点The Little Schemer，跟小人书似的，所以还以为Friedman是个年轻小伙。当我联系上Friedman的时候，他貌似早就认识我了一样。他说当年你的申请材料非常impressive，可惜你最后没有选择我们。你要知道，世界上最重要的不是名气，而是找到赏识你，能够跟你融洽共事的人。你的材料都还在，我会请委员会重新考虑你的申请。IU 的名气实在不大，而Friedman 实在是太谦虚了，所以连跟他打电话都没有明确表态想来IU，只是说“我考虑一下……”这就是我怎么进入IU的。</p><p style="margin:0px 0px 20px;padding:0px;">Friedman的教学真的有一手。虽然每个人对他看法不同，但是有几个最重要的地方他的指点是帮了我大忙的。有人可能想象不到，在Scheme这种动态类型语言的“老槽”，其实有人对“静态类型系统”的理解如此深刻。也就是在Friedman的指点下，我发现类型推导系统不过是一种“抽象解释”，而各种所谓的“typing rule”，不过是抽象解释器里面的分支语句。我后来就通过这个“直觉”，再加上Friedman的逻辑语言miniKanren里面对逻辑变量和unification的实现，做出了一个Hindley-Milner类型推导系统（HM 系统），也就是ML和 Haskell的类型系统。虽然我在Cornell的课程作业里实现过一个HM系统，但是直到Friedman的提点，我才明白了它“为什么”是那个样子，以至于达到更加优美的实现。后来经他一句话点拨，我又写出了一个lazy evaluation的解释器（也就是Haskell的语义），才发现原来SPJ的书里所谓的“graph reduction”，不过就是如此简单的思想。只不过在SPJ的书里，细节掩盖了本质。后来我在之前的HM系统之上做了一个非常小的改动，就实现了type class的功能，并且比Haskell的实现更加灵活。所以，就此我基本上掌握了ML和Haskell的理论精髓。</p><p style="margin:0px 0px 20px;padding:0px;">可是类型系统却貌似一个无止境的东西。在ML的系统之上，还有System F，Fw，MLF，Martin Lof Type Theory，CIC，……怎么没完没了？我一直觉得这些东西过度复杂，有那个必要吗？直到Amal Ahmed来到IU，我才相信了自己的感觉。然而，这却是以一种“反面”的方式达到的。</p><p style="margin:0px 0px 20px;padding:0px;">Amal是著名的Andrew Appel（“虎书”的作者）的学生，在类型系统和编译器的逻辑验证方面做过很多工作。可是她比较让人受不了，她总是显得好像自己是这里唯一懂得类型的人，而其他人都是类型白痴。她不时的提到跟Bob Harper, Benjamin Pierce等类型大牛一起合作的事情。如果你问她什么问题，她经常会回答你：“Bob Harper说……”她提到一个术语的时候总是把它说得无比神奇，把它的提出者的名字叫得异常响亮。有一次她上课给我们讲System F，我问她，为什么这个系统有两个“binder”，貌似太复杂了，为什么不能只用一个？她没有正面回答，而是嘲讽似的说：“不是你说可以就可以的。它就是这个样子的。”后来我却发现其实有另外一个系统，它只有一个binder，而且设计得更加简洁。后来我又在课程的 ailing list 了一个问题，质疑一个编译器验证方面的概念。本来是纯粹的学术讨论，却发现这封email根本没有发到全班同学信箱里，被Amal给moderate掉了！</p><p style="margin:0px 0px 20px;padding:0px;">看到这种种诡异的行为，我才意识到原来学术界存在各种“帮派”。即使一些人的理论完全被更简单的理论超越，他们也会为“自己人”的理论说话，让你搞不清到底什么好，什么不好。所以后来我对一些类型系统，以及Hoare Logic一类的“程序逻辑”产生了怀疑。我的课程project报告，就是指出Hoare Logic和Separation Logic所能完成的功能，其实用“符号执行”或者“model checking”就能完成。而这些程序逻辑所做的事情，不过是把程序翻译成了等价的逻辑表达式而已。到时候你要得知这些逻辑表达式的真伪，又必须经过一个类似程序分析的过程，所以这些逻辑只不过让你白走了一些弯路。当Amal听完我的报告，勉强的笑着说：“你告诉了我们这个结论，可是你能用它来做什么呢？”我才发现原来透彻的看法，并不一定能带来认同。人们都太喜欢“发明”东西，却不喜欢“归并”和“简化”东西。</p><p style="margin:0px 0px 20px;padding:0px;">可是这类型系统的迷雾却始终没有散去，像一座大山压在我头上。我不满意Haskell和ML的类型系统，又觉得System F等过于复杂。可是由于它们的“理论性”和它们创造者的“权威”，我不敢断定自己的看法就不是偏颇的。对付疑惑和恐惧的办法就是面对它们，看透它们，消灭它们。于是，我利用一个independent study的时间，独立实现了一个类型系统。我试图让它极度的简单，却又“包罗万象”。经过一番努力，这个类型系统“涵盖”了System F, MLF 以及另外一些类似系统的推导功能，却不直接“实现”他们。后来我就开始试图让它涵盖一种非常强大的类型系统，叫做intersection types。这种类型系统的研究已经进行了20多年，它不需要程序员写任何类型标记，却可以给任何“停机”的程序以类型。著名的Benjamin Pierce当年的博士论文，就是有关intersection types的。没几天，我就对自己的系统稍作改动，让它涵盖了一种最强大的intersection type系统（System I）的所有功能。然而我却很快发现这个系统是不能实用的，因为它在进行类型推导的时候相当于是在运行这个程序，这样类型推导的计算复杂度就会跟这个程序一样。这肯定是完全不能接受的。后来我才发现，原来已经有人指出了 System I 的这个问题。但是由于我事先实现了这个系统，所以我直接的看到了这个结论，而不需要通过繁琐的证明。</p><p style="margin:0px 0px 20px;padding:0px;">所以，我对类型推导的探索就这样到达了一个终点。我的类型系统是如此的简单，以至于我看到了类型推导的本质，而不需要记住复杂的符号和推理规则。我的系统在去掉了intersection type之后，仍然比System F和MLF都要强大。我也看到了Hindley-Milner系统里面的一个严重问题，它导致了这几十年来很多对于相关类型系统的研究，其实是在解决一个根本不存在的问题。而自动定理证明的研究者们，却直接的“绕过”了这个问题。这也就是我为什么开始对自动定理证明开始感兴趣。</p><p style="margin:0px 0px 20px;padding:0px;">后来对自动定理证明，Partial Evaluation 和 supercompilation的探索，让我看到那些看似高深的Martin Lof Type Theory, Linear Logic等概念，其实不过也就是用不同的说法来重复相同的话题。具体的内容我现在还不想谈，但是我清楚的看到在“形式化”的美丽外衣下，其实有很多等价的，重复的，无聊的东西。与其继续“钻研”它们，反复的叨咕差不多的内容，还不如用它们的“精髓”来做点有用的事情。</p><p style="margin:0px 0px 20px;padding:0px;">所以到现在，我已经基本上摆脱了几乎所有程序语言，编译器，类型系统，操作系统，逻辑推理系统给我设置的思维障碍。它们对我来说不再是什么神物，它们的设计者对我来说也不再是高不可攀的权威。我很开心，经过这段漫长的探索，让我自己的思想得到了解放，翻身成为了这些工具的主人。虽然我看到某些理论工具的研究恐怕早就已经到达路的尽头，然而它们里面隐含的美却是无价和永恒的。这种美让我对这个世界的许多其它方面有了焕然一新的看法。一个工具的价值不在于它自己，而在于你如何利用它创造出对人有益的东西，以及如何让更多的人掌握它。这就是我打算现在去做的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="954"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c04e" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">名称和本质</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">我很喜欢 Richard Feynman 写的 《What Do You Care What Other People Think》。在最开头 Feynman 讲到他小时后的故事。他的父亲经常带他到外面散步，给他讲很多有趣的故事。他受到启发，后来成为了一名科学家。有一次，他们走到一个地方看见一只鸟。父亲说……<br/></p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/5d90e82fgc07d2225ac88&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“See that bird? It's a Spencer's warbler. (I knew he didn't know the real name.) &quot;Well, in Italian, it's a Chutto Lapittida. In Portuguese, it's a Bom da Peida. In Chinese it's a Chung-Iong-tah, and in Japanese it's a Katano Takeda. You can know the name of the bird in all the languages of the world, but when you're finished, you'll know absolutely nothing whatever about the bird. You'll only know about humans in different places, and what they call the bird. So let's look at the birds and see what it's doing - that's what counts!”</p><p style="margin:0px 0px 20px;padding:0px;">“看见那只鸟了吗？那是一只 Spencer's warbler。（他其实不知道那只鸟的名字）嗯，在意大利语里它叫 Chutto Lapittida。在葡萄牙语里它叫 Bom da Peida。在中文里它叫 Chung-long-tah。在日语里它叫 Katano Takeda。你可以知道这种鸟在全世界所有语言里的名字，但是到了最后，你却对它一无所知。你只知道不同地方的人，以及他们如何称呼这种鸟。所以我们来看看它会做哪些事情。那才是重要的！”</p><p style="margin:0px 0px 20px;padding:0px;">所以，何必在乎一个东西叫什么名字。我们需要的，不过是观察所有这些东西，看它们会做哪些事情，然后思考它们为什么是那样，从而得知事物的本质。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="961"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47bf37" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">不再推荐Haskell</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　　在之前的一篇<a href="http://news.cnblogs.com/n/153825/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>里，我推荐从函数式语言入手掌握程序语言。推荐的两种语言是 Scheme 和 Haskell。可是出于多种原因，我必须告诉大家，我已经不再推荐 Haskell。这里的原因比较深入，可能不容易说清楚，所以只简述一下。如果有异议的话，可以来信跟我讨论，这样也可以帮我理清思路。</p><p style="margin:0px 0px 20px;padding:0px;">　　先说说之前推荐 Haskell 的原因吧。推荐它其实是因为是它的类型关系较 Scheme 清晰，并且有模式匹配等方便的功能。可是类型系统和模式匹配，却不是 Haskell 所专有的。其它的一些语言，比如 OCaml 和 Racket 也有很方便的模式匹配和能力相近的类型系统。</p><p style="margin:0px 0px 20px;padding:0px;">　　现在停止推荐 Haskell，其实是出于很多原因的积累：</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">1. 类型系统过于复杂</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　最开头的时候，Haskell 使用的是普通的 Hindley-Milner 类型系统（HM 系统）。使用这种类型系统的原因是因为程序员不需要写任何类型标记（typeannotation）就可以“静态”的确保类型的正确。可是这样做的代价是，这个类型系统表达能力太弱。很多程序需要拐弯抹角的绕过这个类型系统的种种限制才写得出来。比如，Haskell 的 sum type 导致 constructor 的非常麻烦的多重嵌套，这我已经在一篇英文<a href="http://yinwang0.wordpress.com/2011/08/28/sum" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>里面比较隐晦的批评了一下。显然 HM 系统灵活性太差，所以 Haskell 内部后来引进了 SystemFw。可是这些系统发展了好多年，还是不能解决问题。到现在，你仍然会在 Haskell 里面遇到莫名其妙的限制。你觉得程序应该编译通过，可是它就是编译不过（比如我这篇英文<a href="http://yinwang0.wordpress.com/2012/03/05/ghc-type" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博客</a>所述）。究其原因，其实是类型系统有问题，而不是程序员的思路有问题。</p><p style="margin:0px 0px 20px;padding:0px;">　　有的 Haskell 程序员可能会反驳，说是因为我不能理解 Haskell 的类型系统。那么我可以告诉你，我不但实现了 Haskell 和 ML 所用的 HM 系统，而且实现了比 HM 还要强大的 MLF, intersection type 等类型系统。Haskell 推导不出来的类型，我的系统可以推导出来。所以我说的话其实是出自第一手的依据。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">2. 参数和返回值的类型标记很有必要</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　与 Haskell 同门的 SML 和 OCaml 的类型系统也有类似的问题，甚至更加严重（比如 ML 有 <a href="http://cs.au.dk/~hosc/local/LaSC-8-4-pp343-355.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">value restriction</a>，导致不必要的约束和困惑）。但是很多“常规语言”，特别是像 Java,C++ 等需要类型标记的语言，却没有这个问题。很多人喜欢 Haskell 都是因为用它可以“不写类型标记”，可是现在呢，最好的 Haskell 程序员都是先把类型写下来，才开始写函数。一来这样思路清晰，你知道这函数要处理哪些类型的数据，你就明确的把它写下来，以后再来看，或者给其他人看，都一目了然。二来是因为 Haskell 的类型系统由于加入的一些“不可判定”（undecidable）的扩展功能，有时候已经无法推导出类型了。而给函数的参数和返回值加上类型标记之后，就可以轻松推导出类型。所以你看到，给参数和返回值加上类型标记，不管是对人还是对机器，都有好处。所以经过我一学期的研究得出的结论是，HM 系统的类型推导，其实是多此一举。</p><p style="margin:0px 0px 20px;padding:0px;">　　不过需要注意的是，函数的局部变量，其实是不需要类型标记的。比如在 Java 程序里常见的：</p><p style="margin:0px 0px 20px;padding:0px;">　　List&lt;String&gt; ls = newArrayList&lt;String&gt;();</p><p style="margin:0px 0px 20px;padding:0px;">　　这样的赋值语句，其实是没必要在左边加一个类型标记的，因为右边的类型我们知道。在这一点上C++11 的 &quot;auto&quot; 是一个正确的方向。比如在 C++11 里，你可以写：</p><p style="margin:0px 0px 20px;padding:0px;">　　auto ls =newArrayList&lt;String&gt;();</p><p style="margin:0px 0px 20px;padding:0px;">　　这种类型推导不难做，基本就是一个抽象解释器。我给 Python 做的 <a href="http://yinwang0.wordpress.com/2010/09/12/pysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">PySonar</a> 类型推导系统里面就实现了这样的功能。</p><p style="margin:0px 0px 20px;padding:0px;">　　对任何语言，具体是哪些地方有必要加上类型标记呢？其实有一个很简单的方法来判断：观察信息进出函数的“接口”，把这些接口都做上标记。直观一点说，函数就像是一个电路模块，只要我们知道输入和输出是什么，那么中间的导线里面是什么，我们其实都可以推出来。类型推导的过程，就像是模拟这个电路的运行。这里函数的输入就是参数，输出就是返回值，所以基本上把这两者加上类型标记，里面的局部变量的类型都可以推出来。另外需要注意的是，如果函数使用了全局变量，那么全局变量就是函数的一个“隐性”的输入，所以如果程序有全局变量，都需要加上类型标记。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">3. “纯函数式”并不是好主意</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　我最近常常跟同学开玩笑，说“纯函数式”语言是什么意思。“纯函数式”语言是用来描述这样一个世界的，在这个世界里，所有的东西都是“有线”的（wired）。不存在 3G，4G，不存在 wifi，收音机，卫星电视…… 所谓的 monads，其实就是这个布满电缆的世界里的“接线盒”。</p><p style="margin:0px 0px 20px;padding:0px;">　　Haskell 编程之麻烦，就是因为这些电缆。你必须小心翼翼的把它们接在一起，安排好，否则就会有各种问题，甚至绊到脚。连生成随机数这么简单的事情，你都得学会使用各种各样的“随机数 monads”。这是因为我们需要记录随机数发生器的“状态”，所以随机数 monad 输入一个随机数发生器，返回一个随机数以及一个新的随机数发生器！想一想，在 C 语言里面，你只需要一个全局变量或者函数内部的 static 变量来记录随机数发生器的状态。到底是谁简单，谁复杂？我想你可能已经意识到，全局变量其实就是 wifi！</p><p style="margin:0px 0px 20px;padding:0px;">　　Haskell 的支持者常说，纯函数的语言容易“推理”，容易确保程序的正确。因为它的程序就像“数学的函数”，给同一个输入，就会得到同一个输出。这叫做“referentialtransparency”。可是这种性质，真的可以让程序容易“推理”吗？如果 Haskell 的函数使用了 monads，比如“状态”（statemonad），那么这个函数的“输入”，就几乎永远不会相同。因为那个状态每次都可能变化，所以你实际上还是没法知道那里面是什么！</p><p style="margin:0px 0px 20px;padding:0px;">　　记住这一点：世界上没有包治百病的神药。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">4. 惰性求值（lazyevaluation）不是好主意</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　关于惰性求值，我基本同意 <a href="http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Robert Harper 的观点</a>。惰性求值让类型变得混乱，让程序的时间和空间复杂度难以分析，而且跟并行计算的原则有根本性的矛盾。而惰性求值的功能，却不是经常有用的。即使需要，在普通的语言里也可以通过 thunk 来实现。所以，惰性求值带来的问题恐怕比它解决的问题还要多。</p><p style="margin:0px 0px 20px;padding:0px;">　　很多自称“从 Haskell 衍生”的语言，很多其实都只是有其形，而无其实。一个例子就是 <a href="http://www.bluespec.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Bluespec</a>，一种硬件描述语言。它虽然自称是从 Haskell 演变来的，看起来像 Haskell，但是它却不是惰性的，类型系统也很简单，所以基本上它已经不是 Haskell。打着 Haskell 的旗号，恐怕是想借助 Haskell 的名声来抬高自己，或者是因为 Bluespec 的创造者 Lennart Augustsson 最早的时候是 Haskell 的主要发起人之一。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">5. 思想局限</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　所以综上所述，Haskell 自称的“特性”几乎被实践一一推翻。可是 Haskell 程序员往往炫耀自己的“函数式编程”水平，其实经常陷入一些很难理解的“设计模式”，无法自拔。鉴于这个原因，我停止向大家推荐 Haskell。</p><p style="margin:0px 0px 20px;padding:0px;">　　另外需要申明一下的是，我停止推荐 Haskell 并不是因为我想力推 Scheme。实际上 Scheme 也有自己的问题，但是相对来说，它更加简单易懂，符合学习的需要。另外，以前对 C 和 C++ 的批评也许过于偏激。最近为了在 LLVM 上做一些事情，开始重新理解C++，发现它做的好些事情其实是挺不错的，甚至超过好些最炫的，带有“dependenttype”的函数式语言。所以现在我觉得，其实世界上的语言并没有什么绝对的标准。在一段时间认为是错的东西，可能却是对的。所以不用盲目的排斥一些语言，把它们都拿来看一下，互相对比，才会知道到底什么是好的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="962"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_4cbd97" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">TeXmacs：一个真正“所见即所得”的排版系统</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101bejj&amp;url=http://s13.sinaimg.cn/orignal/5d90e82fgc9eef5cd7b0c" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgc9eef5cd7b0c&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">好久没有推荐过自己喜欢的软件了，现在推荐一款我在美国做数学作业的私家法宝：<a href="http://texmacs.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">TeXmacs</a>。我恐怕不可能跟以前那么有闲心写个长篇的 TeXmacs 说明文档了，不过这东西如此的简单好用，所以基本上不用我写什么文档了。鉴于知道的人很少，不理解它的人很多，这里只是帮它打个广告，吊一下胃口。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">TeXmacs 的主要特点是：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">跟 Lyx 等不同，它不是一个 TeX 的“前端”，而是一个完全独立，超越 TeX 的系统。TeXmacs 拥有跟 TeX 相同，甚至更好的排版美观程度。这是因为它采用跟 TeX 一样的排版算法，并且用 C++ 重新实现。据说分页的算法比 TeX 的还要好些。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">拥有超越 Word （或者任何一款字处理软件）的，真正的“所见即所得” (WYSIWYG)。Word 所谓的“所见即所得”，其实是假的。所见即所得的含义，应该是，屏幕上显示的内容，跟打印下来的完全一样。可是 Word 能做到吗？打印一个文档出来你就发现跟屏幕上显示的有很大区别。一些 TeX 的前端，比如 Lyx, Scientific Workspace 等都不能达到这种效果。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">直接可在屏幕文档里绘图。完全可视化的表格，公式编辑环境。这些都是比 TeX 方便高效很多的方式。需要当心的是，用过 TeXmacs 一段时间之后，你会发现你再也不想回到 TeX 的公式编辑方式。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">非常人性化的按键设计。比如，在数学公式环境下，你按任意一个字符，然后就可以用多次 TAB 键相继选择“拓扑相同”的字符。举个例子，如果你按 @，然后再按几下 TAB，就会发现这个字符变成各种各样的圆圈形的字符。如果你按 &gt;，再按 =，就会出现大于等于号，之后再按 TAB，就会相继出现大于等于号的各种变体。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">在直观的同时不失去对底层结构的控制。比如，（见上图）窗口右下角的状态栏，显示出当前光标位置的“上下文”是“proof eqnarry* (1,1) start”，这表示的是这是在一个 proof 环境里的 eqnarry 的坐标 (1,1) 的开始处。当你使用 Ctrl-Backspace，最靠近光标的那层“环境”会被删除。比如，如果你现在的字体是斜体，那么在 Ctrl-Backspace 之后，字体就立即还原成正体。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">结构化的浏览功能。比如，按 Ctrl-PgUp, Ctrl-PgDn 就可以在“相同类型”的结构里上下跳转。比如，如果你在小节标题里按这个键，就可以迅速的浏览所有的小节标题。如果你在数学公式里按这个键，就可以迅速浏览所有的数学公式。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">与交互式程序接口。支持很多种计算机代数系统，和交互式软件，比如 MAXIMA，Octave，…… 这些系统返回的数学公式会直接被 TeXmacs 显示为“TeX 效果”。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">使用 Scheme 作为嵌入式语言，并且可以使用它来扩展系统。这比起 TeX 的语言是非常大的进步。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">目前由于 TeX 的“垄断地位”，以及由于 TeXmacs 是法国人做的，这个系统在美国还不是很流行，很多人都没听说过有这种东西存在。学术圈的很多人由于受到某种错误思想的“洗脑”，都不理解这种图形化编辑软件的价值。希望中国人民和法国人民一样，后来居上，超越美国。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">想要迅速的掌握 TeXmacs 的基本用法，可以参考我绘制的 <a href="http://www.mindomo.com/view?m=b207992c90c046bdbe4053cbdf88b5d5" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">TeXmacs 脑图</a>。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="964"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_4cbd98" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Braid: 一个发人深思的游戏</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://braid-game.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd70ffb1718c1&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/>我已经很久很久没有打游戏了（如果不算 Angry Birds 之类用来打发时间的游戏的话）。我的最后一个真正意义上的游戏机，是 PlayStation 1。在那上面，我真正欣赏的最后一个游戏，是 <a href="http://en.wikipedia.org/wiki/Metal_Gear_Solid" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Metal Gear Solid</a> (1)。<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我曾经是一个游戏迷，可是进入了计算机专业的学习之后，我就开始失去对游戏的兴趣，基本上每玩一个都让我失望一次，不管别人把它吹的多么“经典”。不知道为什么，别人玩得津津有味的游戏，我玩一会儿就把它里面的“公式”都看透了。我清楚地知道这游戏的设计者是怎么在“耍我”，在如何想方设法浪费我的时间。同样的，别人看得津津有味的小说和电影，我经常一看开头就能猜到它要怎么发展，以至于一路猜到结局，索然无味。所以我基本上不去影院看最新的电影。我宁愿在网上看一些几十年前的老电影。我貌似只喜欢那些能让我“猜不透”的东西。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Braid，就是这样一个让我没猜得透的游戏。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这是一个同事推荐的。本来已经对电玩完全失望的我，破例的从 App Store 买了来。玩过之后觉得真的很不错，有一种所谓的“mind blowing”的感觉。以至于我花了两整天时间，废寝忘食，把它给打通关了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Braid 的主体结构，和最古老的“超级玛丽”没什么两样。一个小人，可以跑，可以跳。一些小怪物，跑来跑去的。你可以跳起来踩它们。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">最终的目标，是收集到所有的拼图，然后把它们组合成图片。组合图片是很容易的事情。游戏的难度其实在于如何拿到这些拼图。它们有可能被挂在很高的地方，或者被门挡住。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可是这有什么值得一提的呢？这游戏很不一样的地方是，它给你提供了几种绝无仅有的“超能力”，而且把它们与谜题结合得几乎天衣无缝。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你有三种超能力：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1. 逆转时间的能力</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在任何时候按下 Shift 键，游戏的时间就会逆转，“undo”之前的所有动作。即使你死了，都是可以复活的。死去的小怪物们也会复活。可是就算这样，有些拼图还是很难拿到。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">值得一提的是，时间逆转的时候，画面是流畅无缺损的，连爆炸场面都会“收缩”。更令人赞叹的是，游戏的背景音乐也会同步逆转。如果在时间逆转的时候按“上”，“下”键，就可以调整时间“快退”和“快进”的速度。当然，此时的场景就像录像机在快退或者快进。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">2. 产生“多重现实”的能力</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ijy5&amp;url=http://s2.sinaimg.cn/orignal/5d90e82fgd710ae234861" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd710ae234861&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在某些章节，你可以实现“多重现实”。做一个动作，然后按 Shift 键让时间逆转，当你停止逆转的时候，你的影子就会开始“redo”刚才的那段“历史”。而这个时候你可以做一些不同于以前的事情。这就好像有两个世界，一新一旧，从“历史的分叉点”开始，同步交汇。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你必须掌握好时间才能跟影子合作，因为影子的行动速度是不受你的“现场控制”的，它只是按部就班的重演你 undo 掉的历史。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">3. 扭曲时间的指环</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ijy5&amp;url=http://s5.sinaimg.cn/orignal/5d90e82fgd710c1d330a4" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd710c1d330a4&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在某些章节，你会有机会使用一个魔法指环。把这个指环放在地上之后，它会在附近的球状空间中形成时间的“扭曲”。这有点像黑洞的原理。越是靠近指环的位置，时间流动越慢。而当你远离指环，时间就逐渐恢复正常。指环的巧妙使用，是解决这些章节谜题的关键。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">同样的，音乐与指环的特异功能是完美配合的。当你靠近指环的时候，背景音乐就会出现相应程度的扭曲。有点像录音机卡带的感觉  :)</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在解决了所有的谜题之后，我回味了一下，自己为什么欣赏 Braid。这也许是因为它符合一个优秀的，非低级趣味的游戏设计：屈指可数的简单规则，却可以组合起来，制造出许许多多的变化。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你只有3种超能力，但是如何利用和“组合”这些超能力，却形成了解决谜题的关键。有些题目很有点难度，以至于你会希望有第4种超能力出现，或者希望捡到别的什么“法宝”。可是它们是不存在的。你必须使用那仅有的3种能力，加上巧妙的思索，细心的观察，才能达到目的。在解决了一个很难的谜题之后，你往往会一拍脑袋：哇，我怎么一开头没想到！</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="968"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f63c9" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是“黑客”</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠 发表时间：2012年7月2日<br/></p><p style="margin:0px 0px 20px;padding:0px;">很多程序员自豪的把自己叫做“黑客”（hacker），把编程叫做 hack。可是殊不知，其实在最高级的程序员眼里，“黑客”其实是一个贬义词。他们更愿意被叫做“程序员”(programmer)，或者计算机科学家（computer scientist）。当然，你有可能以一个 hack 从“世界一流大学”拿到一个 PhD。但是 PhD 其实不说明任何问题，世界上有太多的人拥有 PhD，其中绝大部分都是 hack。hack 的本质是不会变的——它是低级的工作。<br/>
hack 的意思本来是这样的：当你没法改变一个东西的时候，如何绕过它的毛病达到目的。所以 hack 这个行为本身就包含了妥协和丑陋。偶尔做一些 hack 无所谓，可是被叫做“hacker”，就表示这个人不能从根本上解决问题，而只是知道如何 hack。比如，绕过某种语言的莫名其妙的毛病，实现一些在别的语言里早就可以轻松办到的事情。很多顶级的程序语言专家有能力设计新的语言，从而从根本上解决问题，而不是受到现有技术和语言的限制，所以他们对于“hacker”这个词有另外的看法。<br/>
当然我并不是歧视 hacker。实际上每个程序员在某些时候都需要 hack。但是我想说的是，我们不应该以 hacker 来称呼自己并且引以为豪，或者歧视那些不明白这些 hack 的人，因为这些 hack 其实是不需要存在的东西。所以何不自嘲一下：“我做的事情虽然有用，但是其实就是个 ugly hack。”</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="972"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/><a href="http://yinwang0.lofter.com/post/183ec2_47bdcf" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">unix的缺陷</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">我想通过这篇文章解释一下我对 Unix 哲学本质的理解。我虽然指出 Unix 的一个设计问题，但目的并不是打击人们对 Unix 的兴趣。虽然 Unix 在基础概念上有一个挺严重的问题，但是经过多年的发展之后，这个问题恐怕已经被各种别的因素所弥补（比如大量的人力）。但是如果开始正视这个问题，我们也许就可以缓慢的改善系统的结构，从而使得它用起来更加高效，方便和安全，那又未尝不可。同时也希望这里对 Unix 命令本质的阐述能帮助人迅速的掌握 Unix，灵活的应用它的潜力，避免它的缺点。<br/><br/>
通常所说的“<a href="http://en.wikipedia.org/wiki/Unix_philosophy" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Unix哲学</a>”包括以下三条原则[Mcllroy]：<br/><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">一个程序只做一件事情，并且把它做好。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">程序之间能够协同工作。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">程序处理文本流，因为它是一个通用的接口。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
这三条原则当中，前两条其实早于 Unix 就已经存在，它们描述的其实是程序设计最基本的原则——模块化原则。任何一个具有函数和调用的程序语言都具有这两条原则。简言之，第一条针对函数，第二条针对调用。所谓“程序”，其实是一个叫 &quot;main&quot; 的函数（详见下文）。</p><p style="margin:0px 0px 20px;padding:0px;">所以只有第三条（用文本流做接口）是 Unix 所特有的。下文的“Unix哲学”如果不加修饰，就特指这第三条原则。但是许多的事实已经显示出，这第三条原则其实包含了实质性的错误。它不但一直在给我们制造无需有的问题，并且在很大程度上破坏前两条原则的实施。然而，这条原则却被很多人奉为神圣。许多程序员在他们自己的程序和协议里大量的使用文本流来表示数据，引发了各种头痛的问题，却对此视而不见。<br/><br/>
Linux 有它优于 Unix 的革新之处，但是我们必须看到，它其实还是继承了 Unix 的这条哲学。Linux 系统的命令行，配置文件，各种工具之间都通过非标准化的文本流传递数据。这造成了信息格式的不一致和程序间协作的困难。然而，我这样说并不等于 Windows 或者 Mac 就做得好很多，虽然它们对此有所改进。实际上，几乎所有常见的操作系统都受到 Unix 哲学潜移默化的影响，以至于它们身上或多或少都存在它的阴影。<br/><br/>
Unix 哲学的影响是多方面的。从命令行到程序语言，到数据库，Web…… 计算机和网络系统的方方面面无不显示出它的影子。在这里，我会把众多的问题与它们的根源——Unix哲学相关联。现在我就从最简单的命令行开始吧，希望你能从这些最简单例子里看到 Unix 执行命令的过程，以及其中存在的问题。（文本流的实质就是字符串，所以在下文里这两个名词通用。）<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">一个 Linux 命令运行的基本过程</strong></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;"><br/></strong>几乎每个 Linux 用户都为它的命令行困惑过。很多人（包括我在内）用了好几年 Linux 也没有完全的掌握命令行的用法。虽然看文档看书以为都看透了，到时候还是会出现莫名其妙的问题，有时甚至会耗费大半天的时间在上面。其实如果看透了命令行的本质，你就会发现很多问题其实不是用户的错。Linux 遗传了 Unix 的“哲学”，用文本流来表示数据和参数，才导致了命令行难学难用。<br/><br/>
我们首先来分析一下 Linux 命令行的工作原理吧。下图是一个很简单的 Linux 命令运行的过程。当然这不是全过程,但是更具体的细节跟我现在要说的主题无关。<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://s12.sinaimg.cn/orignal/5d90e82fgc0b32a056b6b" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgc0b32a056b6b&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">从上图我们可以看到，在 ls 命令运行的整个过程中，发生了如下的事情：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">shell（在这个例子里是bash）从终端得到输入的字符串 &quot;ls -l *.c&quot;。然后 shell 以空白字符为界，切分这个字符串，得到 &quot;ls&quot;, &quot;-l&quot; 和 &quot;*.c&quot; 三个字符串。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">shell 发现第二个字符串是通配符 &quot;*.c&quot;，于是在当前目录下寻找与这个通配符匹配的文件。它找到两个文件： foo.c 和 bar.c。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">shell 把这两个文件的名字和其余的字符串一起做成一个字符串数组 {&quot;ls&quot;, &quot;-l&quot;, &quot;bar.c&quot;, &quot;foo.c&quot;}. 它的长度是 4.</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">shell 生成一个新的进程，在里面执行一个名叫 &quot;ls&quot; 的程序，并且把字符串数组 {&quot;ls&quot;, &quot;-l&quot;, &quot;bar.c&quot;, &quot;foo.c&quot;}和它的长度4，作为ls的main函数的参数。main函数是C语言程序的“入口”，这个你可能已经知道。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">ls 程序启动并且得到的这两个参数（argv，argc）后，对它们做一些分析，提取其中的有用信息。比如 ls 发现字符串数组 argv 的第二个元素 &quot;-l&quot; 以 &quot;-&quot; 开头，就知道那是一个选项——用户想列出文件详细的信息，于是它设置一个布尔变量表示这个信息，以便以后决定输出文件信息的格式。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">ls 列出 foo.c 和 bar.c 两个文件的“长格式”信息之后退出。以整数0作为返回值。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">shell 得知 ls 已经退出，返回值是 0。在 shell 看来，0 表示成功，而其它值（不管正数负数）都表示失败。于是 shell 知道 ls 运行成功了。由于没有别的命令需要运行，shell 向屏幕打印出提示符，开始等待新的终端输入……</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
从上面的命令运行的过程中，我们可以看到文本流（字符串）在命令行中的普遍存在：<br/><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">用户在终端输入是字符串。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">shell 从终端得到的是字符串，分解之后得到 3 个字符串，展开通配符后得到 4 个字符串。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">ls 程序从参数得到那 4 个字符串，看到字符串 &quot;-l&quot; 的时候，就决定使用长格式进行输出。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">接下来你会看到这样的做法引起的问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">冰山一角</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
在《Unix 痛恨者手册》(<a href="http://simson.net/ref/ugh.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">The Unix-Hater's Handbook</a>, 以下简称 UHH)这本书开头，作者列举了 Unix 命令行用户界面的一系列罪状，咋一看还以为是脾气不好的初学者在谩骂。可是仔细看看，你会发现虽然态度不好，他们某些人的话里面有非常深刻的道理。我们总是可以从骂我们的人身上学到一些东西，所以仔细看了一下，发现其实这些命令行问题的根源就是“Unix 哲学”——用文本流（字符串）来表示参数和数据。很多人都没有意识到，文本流的过度使用，引发了太多问题。我会在后面列出这些问题，不过我现在先举一些最简单的例子来解释一下这个问题的本质，你现在就可以自己动手试一下。<br/><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">在你的 Linux 终端里执行如下命令（依次输入：大于号，减号，小写字母l）。这会在目录下建立一个叫 &quot;-l&quot; 的文件。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;">$ &gt;-l</blockquote></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">执行命令 ls * （你的意图是以短格式列出目录下的所有文件）。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
你看到什么了呢？你没有给 ls 任何选项，文件却出人意料的以“长格式”列了出来，而这个列表里面却没有你刚刚建立的那个名叫 &quot;-l&quot; 的文件。比如我得到如下输出：<br/><br/></p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;">-rw-r--r-- 1 wy wy 0 2011-05-22 23:03 bar.c<br/><br/>
-rw-r--r-- 1 wy wy 0 2011-05-22 23:03 foo.c</blockquote><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
到底发生了什么呢？重温一下上面的示意图吧，特别注意第二步。原来 shell 在调用 ls 之前，把通配符 * 展开成了目录下的所有文件，那就是 &quot;foo.c&quot;, &quot;bar.c&quot;, 和一个名叫 &quot;-l&quot; 的文件。它把这 3 个字符串加上 ls 自己的名字，放进一个字符串数组 {&quot;ls&quot;, &quot;bar.c&quot;, &quot;foo.c&quot;, &quot;-l&quot;}，交给 ls。接下来发生的是，ls 拿到这个字符串数组，发现里面有个字符串是 &quot;-l&quot;，就以为那是一个选项：用户想用“长格式”输出文件信息。因为 &quot;-l&quot; 被认为是选项，就没有被列出来。于是我就得到上面的结果：长格式，还少了一个文件！<br/><br/>
这说明了什么问题呢？是用户的错吗？高手们也许会笑，怎么有人会这么傻，在目录里建立一个叫 &quot;-l&quot; 的文件。但是就是这样的态度，导致了我们对错误视而不见，甚至让它发扬光大。其实撇除心里的优越感，从理性的观点看一看，我们就发现这一切都是系统设计的问题，而不是用户的错误。如果用户要上法庭状告 Linux，他可以这样写：<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">起诉状</p><p style="margin:0px 0px 20px;padding:0px;">原告：用户 luser<br/><br/>
被告：Linux 操作系统<br/><br/>
事由：合同纠纷</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">被告的文件系统给用户提供了机制建立这样一个叫 &quot;-l&quot; 的文件，这表示原告有权使用这个文件名。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">既然 &quot;-l&quot; 是一个合法的文件名，而 &quot;*&quot; 通配符表示匹配“任何文件”，那么在原告使用 &quot;ls *&quot; 命令的时候，被告就应该像原告所期望的那样，以正常的方式列出目录下所有的文件，包括 &quot;-l&quot; 在内。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">但是实际上原告没有达到他认为理所当然的结果。&quot;-l&quot; 被 ls 命令认为是一个命令行选项，而不是一个文件。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">原告认为自己的合法权益受到侵犯。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
我觉得为了免去责任，一个系统必须提供切实的保障措施，而不只是口头上的约定来要求用户“小心”。就像如果你在街上挖个大洞施工，必须放上路障和警示灯。你不能只插一面小旗子在那里，用一行小字写着: “前方施工，后果自负。”我想每一个正常人都会判定是施工者的错误。<br/><br/>
可是 Unix 对于它的用户却一直是像这样的施工者，它要求用户：“仔细看 man page，否则后果自负。”其实不是用户想偷懒，而是这些条款太多，根本没有人能记得住。而且没被咬过之前，谁会去看那些偏僻的内容啊。但是一被咬，就后悔都来不及。完成一个简单的任务都需要知道这么多可能的陷阱，那更加复杂的任务可怎么办。其实 Unix 的这些小问题累加起来，不知道让人耗费了多少宝贵的时间。<br/><br/>
如果你想更加确信这个问题的危险性，可以试试如下的做法。在这之前，请新建一个测试用的目录，以免丢失你的文件！ <br/><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">在新目录里，我们首先建立两个文件夹 dir-a, dir-b 和三个普通文件 file1，file2 和 &quot;-rf&quot;。然后我们运行 &quot;rm *&quot;，意图是删除所有普通文件，而不删掉目录。</p><p style="margin:0px 0px 20px;padding:0px;">$ mkdir dir-a dir-b<br/><br/>
$ touch file1 file2<br/><br/>
$ &gt; -rf<br/><br/>
$ rm *</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">然后用 ls 查看目录。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
你会发现最后只剩下一个文件: &quot;-rf&quot;。本来 &quot;rm *&quot; 只能删除普通文件，现在由于目录里存在一个叫 &quot;-rf&quot; 的文件。rm 以为那是叫它进行强制递归删除的选项，所以它把目录里所有的文件连同目录全都删掉了（除了 &quot;-rf&quot;）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">表面解决方案</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
难道这说明我们应该禁止任何以 &quot;-&quot; 开头的文件名的存在，因为这样会让程序分不清选项和文件名？可是不幸的是，由于 Unix 给程序员的“灵活性”，并不是每个程序都认为以 &quot;-&quot; 开头的参数是选项。比如，Linux 下的 tar，ps 等命令就是例外。所以这个方案不大可行。<br/><br/>
从上面的例子我们可以看出，问题的来源似乎是因为 ls 根本不知道通配符 * 的存在。是 shell 把通配符展开以后给 ls。其实 ls 得到的是文件名和选项混合在一起的字符串数组。所以 UHH 的作者提出的一个看法：“shell 根本不应该展开通配符。通配符应该直接被送给程序，由程序自己调用一个库函数来展开。”<br/><br/>
这个方案确实可行：如果 shell 把通配符直接给 ls，那么 ls 会只看到 &quot;*&quot; 一个参数。它会调用库函数在文件系统里去寻找当前目录下的所有文件，它会很清楚的知道 &quot;-l&quot; 是一个文件，而不是一个选项，因为它根本没有从 shell 那里得到任何选项(它只得到一个参数：&quot;*&quot;)。所以问题貌似就解决了。<br/><br/>
但是这样每一个命令都自己检查通配符的存在，然后去调用库函数来解释它，大大增加了程序员的工作量和出错的概率。况且 shell 不但展开通配符，还有环境变量，花括号展开，~展开，命令替换，算术运算展开…… 这些让每个程序都自己去做？这恰恰违反了第一条 Unix 哲学——模块化原则。而且这个方法并不是一劳永逸的，它只能解决这一个问题。我们还将遇到文本流引起的更多的问题，它们没法用这个方法解决。下面就是一个这样的例子。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">冰山又一角</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
这些看似微不足道的问题里面其实包含了 Unix 本质的问题。如果不能正确认识到它，我们跳出了一个问题，还会进入另一个。我讲一个自己的亲身经历吧。我前年夏天在 Google 实习快结束的时候发生了这样一件事情……<br/><br/>
由于我的项目对一个开源项目的依赖关系，我必须在 Google 的 Perforce 代码库中提交这个开源项目的所有文件。这个开源项目里面有 9000 多个文件，而 Perforce 是如此之慢，在提交进行到一个小时的时候，突然报错退出了，说有两个文件找不到。又试了两次（顺便出去喝了咖啡，打了台球），还是失败，这样一天就快过去了。于是我搜索了一下这两个文件，确实不存在。怎么会呢？我是用公司手册上的命令行把项目的文件导入到 Perforce 的呀，怎么会无中生有？这条命令是这样：<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">find -name *.java -print | xargs p4 add</p><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
它的工作原理是，find 命令在目录树下找到所有的以 &quot;.java&quot; 结尾的文件，把它们用空格符隔开做成一个字符串，然后交给 xargs。之后 xargs 以空格符把这个字符串拆开成多个字符串，放在 &quot;p4 add&quot; 后面，组合成一条命令，然后执行它。基本上你可以把 find 想象成 Lisp 里的 &quot;filter&quot;，而 xargs 就是 &quot;map&quot;。所以这条命令转换成 Lisp 样式的伪码就是:<br/><br/>
(map (lambda (x) (p4 add x))<br/>
     (filter (lambda (x) (regexp-match? &quot;*.java&quot; x))<br/>
             (files-in-current-dir)))<br/><br/>
问题出在哪里呢？经过一下午的困惑之后我终于发现，原来这个开源项目里某个目录下，有一个叫做 &quot;App Launcher.java&quot; 的文件。由于它的名字里面含有一个空格，被 xargs 拆开成了两个字符串： &quot;App&quot; 和 &quot;Launcher.java&quot;。当然这两个文件都不存在了！所以 Perforce 在提交的时候抱怨找不到它们。我告诉组里的负责人这个发现后，他说：“这些家伙，怎么能给 Java 程序起这样一个名字？也太菜了吧！”<br/><br/>
但是我却不认为是这个开源项目的程序员的错误，这其实显示了 Unix 的问题。这个问题的根源是因为 Unix 的命令 (find, xargs) 把文件名以字符串的形式传递，它们默认的“协议”是“以空格符隔开文件名”。而这个项目里恰恰有一个文件的名字里面有空格符，所以导致了歧义的产生。该怪谁呢？既然 Linux 允许文件名里面有空格，那么用户就有权使用这个功能。到头来因此出了问题，用户却被叫做菜鸟，为什么自己不小心，不看 man page。<br/><br/>
后来我仔细看了一下 find 和 xargs 的 man page，发现其实它们的设计者其实已经意识到这个问题。所以 find 和 xargs 各有一个选项：&quot;-print0&quot; 和 &quot;-0&quot;。它们可以让 find 和 xargs 不用空格符，而用 &quot;NULL&quot;（ASCII字符 0）作为文件名的分隔符，这样就可以避免文件名里有空格导致的问题。可是，似乎每次遇到这样的问题总是过后方知。难道用户真的需要知道这么多，小心翼翼，才能有效的使用 Unix 吗？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">文本流不是可靠的接口</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
这些例子其实从不同的侧面显示了同一个本质的问题：用文本流来传递数据有严重的问题。是的，文本流是一个“通用”的接口，但是它却不是一个“可靠”或者“方便”的接口。Unix 命令的工作原理基本是这样： </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">从标准输入得到文本流，处理，向标准输出打印文本流。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">程序之间用管道进行通信，让文本流可以在程序间传递。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/>
这其中主要有两个过程：<br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">程序向标准输出“打印”的时候，数据被转换成文本。这是一个编码过程。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">文本通过管道（或者文件）进入另一个程序，这个程序需要从文本里面提取它需要的信息。这是一个解码过程。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">编码的貌似很简单，你只需要随便设计一个“语法”，比如“用空格隔开”，就能输出了。可是编码的设计远远不是想象的那么容易。要是编码格式没有设计好，解码的人就麻烦了，轻则需要正则表达式才能提取出文本里的信息，遇到复杂一点的编码（比如程序文本），就得用 parser。最严重的问题是，由于鼓励使用文本流，很多程序员很随意的设计他们的编码方式而不经过严密思考。这就造成了 Unix 的几乎每个程序都有各自不同的输出格式，使得解码成为非常头痛的问题，经常出现歧义和混淆。<br/><br/>
上面 find/xargs 的问题就是因为 find 编码的分隔符（空格）和文件名里可能存在的空格相混淆——此空格非彼空格也。而之前的 ls 和 rm 的问题就是因为 shell 把文件名和选项都“编码”为“字符串”，所以 ls 程序无法通过解码来辨别它们的到底是文件名还是选项——此字符串非彼字符串也！<br/><br/>
如果你使用过 Java 或者函数式语言（Haskell 或者 ML），你可能会了解一些类型理论(type theory)。在类型理论里，数据的类型是多样的，Integer, String, Boolean, List, record…… 程序之间传递的所谓“数据”，只不过就是这些类型的数据结构。然而按照 Unix 的设计，所有的类型都得被转化成 String 之后在程序间传递。这样带来一个问题：由于无结构的 String 没有足够的表达力来区分其它的数据类型，所以经常会出现歧义。相比之下，如果用 Haskell 来表示命令行参数，它应该是这样：<br/><br/>
data Parameter = Option String | File String | ...<br/><br/>
虽然两种东西的实质都是 String，但是 Haskell 会给它们加上“标签”以区分 Option 还是 File。这样当 ls 接收到参数列表的时候，它就从标签判断哪个是选项，哪个是参数，而不是通过字符串的内容来瞎猜。<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">文本流带来太多的问题</strong><br/></p><p style="margin:0px 0px 20px;padding:0px;">综上所述，文本流的问题在于，本来简单明了的信息，被编码成为文本流之后，就变得难以提取，甚至丢失。前面说的都是小问题，其实文本流的带来的严重问题很多，它甚至创造了整个的研究领域。文本流的思想影响了太多的设计。比如：<br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">配置文件</strong>：几乎每一个都用不同的文本格式保存数据。想想吧：.bashrc, .Xdefaults, .screenrc, .fvwm, .emacs, .vimrc, /etc目录下那系列！这样用户需要了解太多的格式，然而它们并没有什么本质区别。为了整理好这些文件，花费了大量的人力物力。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">程序文本</strong>：这个以后我会专门讲。程序被作为文本文件，所以我们才需要 parser。这导致了整个编译器领域花费大量人力物力研究 parsing。其实程序完全可以被作为 parse tree 直接存储，这样编译器可以直接读取 parse tree，不但节省编译时间，连 parser 都不用写。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">数据库接口</strong>：程序与关系式数据库之间的交互使用含有 SQL 语句的字符串，由于字符串里的内容跟程序的类型之间并无关联，导致了这种程序非常难以调试。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">XML</strong>: 设计的初衷就是解决数据编码的问题，然而不幸的是，它自己都难 parse。它跟 SQL 类似，与程序里的类型关联性很差。程序里的类型名字即使跟 XML 里面的定义有所偏差，编译器也不会报错。Android 程序经常出现的 &quot;force close&quot;，大部分时候是这个原因。与 XML 相关的一些东西，比如 XSLT, XQuery, XPath 等等，设计也非常糟糕。<br/></p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Web</strong>：JavaScript 经常被作为字符串插入到网页中。由于字符串可以被任意组合，这引起很多安全性问题。Web安全研究，有些就是解决这类问题的。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">IDE接口</strong>：很多编译器给编辑器和 IDE 提供的接口是基于文本的。编译器打印出出错的行号和信息，比如 &quot;102:32 variable x undefined&quot;，然后由编辑器和 IDE 从文本里面去提取这些信息，跳转到相应的位置。一旦编译器改变打印格式，这些编辑器和 IDE 就得修改。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">log分析</strong>: 有些公司调试程序的时候打印出文本 log 信息，然后专门请人写程序分析这种 log，从里面提取有用的信息，非常费时费力。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">测试</strong>：很多人写 unit test 的时候，喜欢把数据结构通过 toString 等函数转化成字符串之后，与一个标准的字符串进行比较，导致这些测试在字符串格式改变之后失效而必须修改。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">还有很多的例子，你只需要在你的身边去发现。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">什么是“人类可读”和“通用”接口？</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当我提到文本流做接口的各种弊端时，经常有人会指出，虽然文本流不可靠又麻烦，但是它比其它接口更通用，因为它是唯一人类可读 (human-readable) 的格式，任何编辑器都可以直接看到文本流的内容，而其它格式都不是这样的。对于这一点我想说的是： </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">什么叫做“人类可读”？文本流真的就是那么的可读吗？几年前，普通的文本编辑器遇到中文的时候经常乱码，要折腾好一阵子才能让它们支持中文。幸好经过全世界的合作，我们现在有了 Unicode。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">现在要阅读 Unicode 的文件，你不但要有支持 Unicode 的编辑器/浏览器，你还得有能显示相应码段的字体。文本流达到“人类可读”真的不费力气？</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">除了文本流，其实还有很多人类可读的格式，比如 JPEG。它可比文本流“可读”和“通用”多了，连字体都用不着。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>
所以，文本流的根本就不是“人类可读”和“通用”的关键。真正的关键在于“标准化”。如果其它的数据类型被标准化，那么我们可以在任何编辑器，浏览器，终端里加入对它们的支持，完全达到人类和机器都可轻松读取，就像我们今天读取文本和 JPEG 一样。<br/><br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">解决方案</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实有一个简单的方式可以一劳永逸的解决所有这些问题： </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">保留数据类型本来的结构。不用文本流来表示除文本以外的数据。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">用一个开放的，标准化的，可扩展的方式来表示所有数据类型。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">程序之间的数据传递和存储，就像程序内部的数据结构一样。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Unix 命令行的本质</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">虽然文本流引起了这么多问题，但是 Unix 还是不会消亡，因为毕竟有这么多的上层应用已经依赖于它，它几乎是整个 Internet 的顶梁柱。所以这篇文章对于当前状况的一个实际意义，也许是可以帮助人们迅速的理解 Unix 的命令行机制，并且鼓励程序员在新的应用中使用结构化的数据。<br/><br/>
Unix 命令虽然过于复杂而且功能冗余，但是如果你看透了它们的本质，就能轻而易举的学会它们的使用方法。简而言之，你可以用普通的编程思想来解释所有的 Unix 命令：<br/><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">函数</strong>：每一个 Unix 程序本质上是一个函数 (main)。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">参数</strong>：命令行参数就是这个函数的参数。 所有的参数对于 C 语言来说都是字符串，但是经过 parse，它们可能有几种不同的<strong style="font-style:normal;font-weight:bold;font-size:100%;">类型</strong>：</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">变量名</strong>：实际上文件名就是程序中的变量名，就像 x, y。而文件的本质就是程序里的一个对象。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">字符串</strong>：这是真正的程序中的字符串，就像 &quot;hello world&quot;。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">keyword argument</strong>: 选项本质上就是“keyword argument”(kwarg)，类似 Python 或者 Common Lisp 里面那个对应的东西，短选项（看起来像 &quot;-l&quot;, &quot;-c&quot; 等等），本质上就是 bool 类型的 kwarg。比如 &quot;ls -l&quot; 以 Python 的语法就是 ls(l=true)。长选项本质就是 string 类型的 kwarg。比如 &quot;ls --color=auto&quot; 以 Python 的语法就是 ls(color=auto)。</p></li></ul></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">返回值</strong>：由于 main 函数只能返回整数类型(int)，我们只好把其它类型 (string, list, record, ...) 的返回值序列化为文本流，然后通过文件送给另一个程序。这里“文件”通指磁盘文件，管道等等。它们是文本流通过的信道。我已经提到过，文件的本质是程序里的一个对象。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">组合</strong>：所谓“管道”，不过是一种简单的函数组合(composition)。比如 &quot;A x | B&quot;，用函数来表示就是 &quot;B(A(x))&quot;。 但是注意，这里的计算过程，本质上是 lazy evaluation (类似 Haskell)。当 B “需要”数据的时候，A 才会读取更大部分的 x，并且计算出结果送给 B。并不是所有函数组合都可以用管道表示，比如，如何用管道表示 &quot;C(B(x), A(y))&quot;？所以函数组合是更加通用的机制。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">分支</strong>：如果需要把返回值送到两个不同的程序，你需要使用 <a href="http://en.wikipedia.org/wiki/Tee_(command)" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">tee</a>。这相当于在程序里把结果存到一个临时变量，然后使用它两次。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">控制流</strong>：main 函数的返回值（int型）被 shell 用来作为控制流。shell 可以根据 main 函数返回值来中断或者继续运行一个脚本。这就像 Java 的 exception。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">shell</strong>: 各种 shell 语言的本质都是用来连接这些 main 函数的语言，而 shell 的本质其实是一个 REPL (read-eval-print-loop，类似 Lisp)。用程序语言的观点，shell 语言完全是多余的东西，我们其实可以在 REPL 里用跟应用程序一样的程序语言。Lisp 系统就是这样做的。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">数据直接存储带来的可能性</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">由于存储的是结构化的数据，任何支持这种格式的工具都可以让用户直接操作这个数据结构。这会带来意想不到的好处。<br/><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">因为命令行操作的是结构化的参数，系统可以非常智能的按类型补全命令，让你完全不可能输入语法错误的命令。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">可以直接在命令行里插入显示图片之类的 &quot;meta data&quot;。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">Drag&amp;Drop 桌面上的对象到命令行里，然后执行。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">因为代码是以 parse tree 结构存储的，IDE 会很容易的扩展到支持所有的程序语言。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">你可以在看 email 的时候对其中的代码段进行 IDE 似的结构化编辑，甚至编译和执行。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">结构化的版本控制和程序比较(diff)。（参考我的<a href="http://yinwang0.wordpress.com/2012/02/12/structural-version-control" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">talk</a>）</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">还有很多很多，仅限于我们的想象力。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">程序语言，操作系统，数据库三位一体</strong></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
如果 main 函数可以接受<strong style="font-style:normal;font-weight:bold;font-size:100%;">多种类型</strong>的参数，并且可以有 <strong style="font-style:normal;font-weight:bold;font-size:100%;">keyword argument</strong>，它能返回一个或多个不同类型的<strong style="font-style:normal;font-weight:bold;font-size:100%;">对象</strong>作为返回值，而且如果这些对象可以被自动存储到一种特殊的“<strong style="font-style:normal;font-weight:bold;font-size:100%;">数据库</strong>”里，那么 shell，管道，命令行选项，甚至连文件系统都没有必要存在。我们甚至可以说，“操作系统”这个概念变得“透明”。因为这样一来，操作系统的本质不过是某种程序语言的“运行时系统”(runtime system)。这有点像 JVM 之于 Java。其实从本质上讲，Unix 就是 C 语言的运行时系统。<br/><br/>
如果我们再进一步，把与数据库的连接做成透明的，即用同一种程序语言来“隐性”(implicit)的访问数据库，而不是像 SQL 之类的专用数据库语言，那么“数据库”这个概念也变得透明了。我们得到的会是一个非常简单，统一，方便，而且强大的系统。这个系统里面只有一种程序语言，程序员直接编写高级语言程序，用同样的语言从命令行执行它们，而且不用担心数据放在什么地方。这样可以大大的减小程序员工作的复杂度，让他们专注于问题本身，而不是系统的内部结构。<br/><br/>
实际上，类似这样的系统在历史上早已存在过 (<a href="http://en.wikipedia.org/wiki/Lisp_machine" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Lisp Machine</a>, <a href="http://en.wikipedia.org/wiki/IBM_System/38" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">System/38</a>，<a href="http://en.wikipedia.org/wiki/Oberon_(operating_system)" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Oberon</a>)，而且收到了不错的效果。但是由于某些原因（历史的，经济的，政治的，技术的），它们都消亡了。但是不得不说它们的这种方式比 Unix 现有的方式优秀，所以何不学过来？我相信，随着程序语言和编译器技术发展，它们的这种简单而统一的设计理念，有一天会改变这个世界。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="978"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c5605" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">谈谈 Currying</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多基于 lambda calculus 的程序语言，比如 ML 和 Haskell，都习惯用一种叫做 currying 的手法来表示函数。比如，如果你在 Haskell 里面这样写一个函数：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  f x y = x + y</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然后你就可以这样把链表里的每个元素加上 2：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (f 2) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">它会输出 [3, 4, 5]。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">注意本来 f 需要两个参数才能算出结果，可是这里的 (f 2) 只给了 f 一个参数。这是因为 Haskell 的函数定义的缺省方式是“currying”。Currying 其实就是用“单参数”的函数，来模拟多参数的函数。比如，上面的 f 的定义在 Scheme 里面相当于：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(define f</p><p style="margin:0px 0px 20px;padding:0px;">  (lambda (x)</p><p style="margin:0px 0px 20px;padding:0px;">    (lambda (y)</p><p style="margin:0px 0px 20px;padding:0px;">      (+ x y))))</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">它是说，函数 f，接受一个参数 x，返回另一个函数（没有名字）。这个匿名函数，如果再接受一个参数 y，就会返回 x + y。所以上面的例子里面，(f 2) 返回的是一个匿名函数，它会把 2 加到自己的参数上面返回。所以把它 map 到 [1, 2, 3]，我们就得到了 [3, 4, 5]。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这个例子里面，currying 貌似一个挺有用的东西，它让程序变得“简短”。如果不用 currying，你就需要制造另一个函数，写成这个样子：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (\y-&gt;f 2 y) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这就是为什么 Haskell 和 ML 的程序员那么喜欢 currying。这个做法其实来源于最早的 lambda calculus 的设计。因为 lambda calculus 的函数都只有一个参数，所以为了能够表示多参数的函数，有一个叫 <a href="http://en.wikipedia.org/wiki/Haskell_Curry" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Haskell Curry</a> 的数学家和逻辑学家，发明了这个方法。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当然，Haskell Curry 是我很尊敬的人。不过我今天想指出的是，currying 在程序设计的实践中，其实并不是想象中的那么好。大量使用 currying，其实会带来程序难以理解，复杂性增加，并且还可能因此引起意想不到的错误。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">不用 currying 的写法（\y-&gt;f 2 y）虽然比起 currying 的写法（f 2）长了那么一点，但是它有一点好。那就是你作为一个人（而不是机器），可以很清楚的从“\y-&gt;f 2 y”这个表达式，看到它的“用意”是什么。你会很清楚的看到：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“f 本来是一个需要两个参数的函数。我们只给了它第一个参数 2。我们想要把 [1, 2, 3] 这个链表里的每一个元素，放进 f 的第二个参数 y，然后把 f 返回的结果一个一个的放进返回值的链表里。”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">仔细看看上面这段话说了什么吧，再来看看 (f 2) 是否表达了同样的意思？注意，我们现在的“重点”在于你，一个人，而不在于计算机。你仔细想，不要让思维的定势来影响你的判断。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你发现了吗？(f 2) 并不完全的含有 \y-&gt;f 2 y 所表达的内容。因为单从 (f 2) 这个表达式（不看它的定义），你看不到“f 总共需要几个参数”这一信息，你也看不到 (f 2) 会返回什么东西。f 有可能需要2个参数，也有可能需要3个，4个，5个…… 比如，如果它需要3个参数的话，map (f 2) [1, 2, 3] 就不会返回一个整数的链表，而会返回一个函数的链表，它看起来是这样：[(\z-&gt;f 2 1 z), (\z-&gt;f 2 2 z), (\z-&gt;f 2 3 z)]。这三个函数分别还需要一个参数，才会输出结果。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这样一来，表达式 (f 2) 含有的对“人”有用的信息，就比较少了。你不能很可靠地知道这个函数接受了一个参数之后会变成什么样子。当然，你可以去看 f 的定义，然后再回来，但是这里有一种“直觉”上的开销。如果你不能同时看见这些信息，你的脑子就需要多转一道弯，你就会缺少一些重要的直觉。这种直觉能帮助你写出更好的程序。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然而，currying 的问题不止在于这种“认知”的方面，有时候使用 curry 会直接带来代码复杂性的增加。比如，如果你的 f 定义不是加法，而是除法：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  f x y = x / y</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然后，我们现在需要把链表 [1, 2, 3] 里的每一个数都除以 2。你会怎么做呢？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">map (f 2) [1, 2, 3] 肯定不行，因为 2 是除数，而不是被除数。熟悉 Haskell 的人都知道，可以这样做：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (flip f 2) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">flip 的作用是“交换”两个参数的位置。它可以被定义为：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  flip f x y = f y x</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">但是，如果 f 有 3 个参数，而我们需要把它的第 2 个参数 map 到一个链表，怎么办呢？比如，如果 f 被定义为：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  f x y z = (x - y) / z</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">稍微动一下脑筋，你可能会想出这样的代码：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (flip (f 1) 2) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">能想出这段代码说明你挺聪明，可是如果你这样写代码，那就是缺乏一些“智慧”。有时候，好的程序其实不在于显示你有多“聪明”，而在于显示你有多“笨”。现在我们就来看看笨一点的代码：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (\y -&gt; f 1 y 2) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在比较一下，你仍然觉得之前那段代码很聪明吗？如果你注意观察，就会发现 (flip (f 1) 2) 这个表达式，是多么的晦涩，多么的复杂。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">从 (flip (f 1) 2) 里面，你几乎看不到自己想要干什么。而 \y-&gt; f 1 y 2 却很明确的显示出，你想用 1 和 2 填充掉 f 的第一，三号参数，把第二个参数留下来，然后把得到的函数 map 到链表 [1, 2, 3]。仔细看看，是不是这样的？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以你花费了挺多的脑力才把那使用 currying 的代码写出来，然后你每次看到它，还需要耗费同样多的脑力，才能明白你当时写它来干嘛。你是不是吃饱了没事干呢？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">练习题：如果你还不相信，就请你用 currying 的方法（加上 flip）表达下面这个语句，也就是把 f 的第一个参数 map 到链表 [1, 2, 3]：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  map (\y -&gt; f y 1 2) [1, 2, 3]</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">得到结果之后再跟上面这个语句对比，看谁更加简单？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">到现在你也许注意到了，以上的“笨办法”对于我们想要 map 的每一个参数，都是差不多的形式；而使用 currying 的代码，对于每个参数，形式有很大的差别。所以我们的“笨办法”其实才是以不变应万变的良策。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">才三个参数，currying 就显示出了它的弱点，如果超过三个参数，那就更麻烦了。所以很多人为了写 currying 的函数，特意把参数调整到方便 currying 的顺序。可是程序的设计总是有意想不到的变化。有时候你需要增加一个参数，有时候你又想减少一个参数，有时候你又会有别的用法，导致你需要调整参数的顺序…… 事先安排好的那些参数顺序，很有可能不能满足你后来的需要。即使它能满足你后来的需要，你的函数也会因为 currying 而难以看懂。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这就是为什么我从来不在我的 ML 和 Haskell 程序里使用 currying 的原因。古老而美丽的理论，也许能够给我带来思想的启迪，可是未必就能带来工程中理想的效果。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="983"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c561b" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Scheme编程环境的配置</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">介绍了这么久的 Scheme，却没有讲过如何配置一个高效的 Scheme 的编程环境。有些人开始学习 Scheme 的时候感觉无从下手，所以今天讲一下它的配置。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Scheme 的配置有很多种方式，我不想介绍太多东西，免得有人看花了眼，所以这里只介绍一下我自己的配置。我不大喜欢像 <a href="http://www.neilvandyke.org/quack" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Quack</a> 一类的复杂的环境，因为它们经常有很多多余的功能，却缺少我想要的功能。一旦我想修改它们，又到处出问题。我的配置很简约，我用它写了几千行的超高难度的代码，翻来覆去的改，感觉效率非常高，也没有觉得缺少什么特别重要的东西。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在我就一步一步的介绍我的配置。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1. 安装 Scheme</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">世界上最好的 Scheme 实现是 <a href="http://blog.sina.com.cn/s/blog_5d90e82f0101jscn.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Chez Scheme</a>，但是它不免费也不开源。所以如果你不想破费，那就只好下载一个它的“免费版”，叫做 Petite Chez Scheme（petite 是法语里“小”的意思）。它可以在这里下载：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://scheme.com/download/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://scheme.com/download</a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这个页面挺长，上面都是正式版的 Chez Scheme，一点击就会叫你“联系销售人员”。要滚动到下面才能看见免费的版本。怎么安装我就不讲了，自己看说明应该很容易的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Petite 是一个完善的，高效的实现，你可以把它当成解释器使用。这个解释器的速度非常之快，甚至比很多别的 Scheme 实现编译后的代码还要快。但是它有一个问题，就是它给出的出错信息太简约了，以至于连出错的函数名字都不告诉你。这样写大一点的程序就会比较痛苦了（虽然我还是用它写了2000多行的编译器代码）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以如果你想写稍微大点的东西，可以用 Racket。它可以在这里下载：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://racket-lang.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://racket-lang.org</a></p><p style="margin:0px 0px 20px;padding:0px;">安装应该很容易。Ubuntu 也自带了 Racket，所以可以直接让系统安装它。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">2. 设置 ParEdit mode</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我编辑 Scheme 的时候都用 Emacs。我使用一个叫做 ParEdit mode 的插件。它可以让你“半结构化”式的编辑 Scheme 和其它的 Lisp 文件。开头你可能会有点不习惯，可是一旦习惯了，你就再也离不开它。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">ParEdit mode 可以在这里下载：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><a href="http://mumble.net/~campbell/emacs/paredit.el" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://mumble.net/~campbell/emacs/paredit.el</a><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">下载之后，把它放到一个目录里，比如 ~/.emacs.d，然后打开 ~/.emacs 配置文件，加入如下设置：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(autoload 'paredit-mode &quot;paredit&quot;</p><p style="margin:0px 0px 20px;padding:0px;">  &quot;Minor mode for pseudo-structurally editing Lisp code.&quot;</p><p style="margin:0px 0px 20px;padding:0px;">  t)</p><p style="margin:0px 0px 20px;padding:0px;">这样，只要你使用 M-x paredit-mode 就可以自动载入这个模式。具体的操作方式可以看它的说明（按 C-h m 查看“模式帮助”），我下面也会简单说一下。</p><p style="margin:0px 0px 20px;padding:0px;">3. 设置 scheme mode</p><p style="margin:0px 0px 20px;padding:0px;">我一般就用系统自带的 Scheme 模式，叫 cmuscheme。但是为了方便，我自己写了几个函数，用于在执行 Scheme 代码的时候自动启动解释器，并且打开解释器窗口。你基本只需要把下面的代码拷贝到你的 .emacs 文件里就行：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">;;;;;;;;;;;;</p><p style="margin:0px 0px 20px;padding:0px;">;; Scheme </p><p style="margin:0px 0px 20px;padding:0px;">;;;;;;;;;;;;</p><p style="margin:0px 0px 20px;padding:0px;">(require 'cmuscheme)</p><p style="margin:0px 0px 20px;padding:0px;">(setq scheme-program-name &quot;racket&quot;)         ;; 如果用 Petite 就改成 &quot;petite&quot;</p><p style="margin:0px 0px 20px;padding:0px;">;; bypass the interactive question and start the default interpreter</p><p style="margin:0px 0px 20px;padding:0px;">(defun scheme-proc ()</p><p style="margin:0px 0px 20px;padding:0px;">  &quot;Return the current Scheme process, starting one if necessary.&quot;</p><p style="margin:0px 0px 20px;padding:0px;">  (unless (and scheme-buffer</p><p style="margin:0px 0px 20px;padding:0px;">               (get-buffer scheme-buffer)</p><p style="margin:0px 0px 20px;padding:0px;">               (comint-check-proc scheme-buffer))</p><p style="margin:0px 0px 20px;padding:0px;">    (save-window-excursion</p><p style="margin:0px 0px 20px;padding:0px;">      (run-scheme scheme-program-name)))</p><p style="margin:0px 0px 20px;padding:0px;">  (or (scheme-get-process)</p><p style="margin:0px 0px 20px;padding:0px;">      (error &quot;No current process. See variable `scheme-buffer'&quot;)))</p><p style="margin:0px 0px 20px;padding:0px;">(defun scheme-split-window ()</p><p style="margin:0px 0px 20px;padding:0px;">  (cond</p><p style="margin:0px 0px 20px;padding:0px;">   ((= 1 (count-windows))</p><p style="margin:0px 0px 20px;padding:0px;">    (delete-other-windows)</p><p style="margin:0px 0px 20px;padding:0px;">    (split-window-vertically (floor (* 0.68 (window-height))))</p><p style="margin:0px 0px 20px;padding:0px;">    (other-window 1)</p><p style="margin:0px 0px 20px;padding:0px;">    (switch-to-buffer &quot;*scheme*&quot;)</p><p style="margin:0px 0px 20px;padding:0px;">    (other-window 1))</p><p style="margin:0px 0px 20px;padding:0px;">   ((not (find &quot;*scheme*&quot;</p><p style="margin:0px 0px 20px;padding:0px;">               (mapcar (lambda (w) (buffer-name (window-buffer w)))</p><p style="margin:0px 0px 20px;padding:0px;">                       (window-list))</p><p style="margin:0px 0px 20px;padding:0px;">               :test 'equal))</p><p style="margin:0px 0px 20px;padding:0px;">    (other-window 1)</p><p style="margin:0px 0px 20px;padding:0px;">    (switch-to-buffer &quot;*scheme*&quot;)</p><p style="margin:0px 0px 20px;padding:0px;">    (other-window -1))))</p><p style="margin:0px 0px 20px;padding:0px;">(defun scheme-send-last-sexp-split-window ()</p><p style="margin:0px 0px 20px;padding:0px;">  (interactive)</p><p style="margin:0px 0px 20px;padding:0px;">  (scheme-split-window)</p><p style="margin:0px 0px 20px;padding:0px;">  (scheme-send-last-sexp))</p><p style="margin:0px 0px 20px;padding:0px;">(defun scheme-send-definition-split-window ()</p><p style="margin:0px 0px 20px;padding:0px;">  (interactive)</p><p style="margin:0px 0px 20px;padding:0px;">  (scheme-split-window)</p><p style="margin:0px 0px 20px;padding:0px;">  (scheme-send-definition))</p><p style="margin:0px 0px 20px;padding:0px;">(add-hook 'scheme-mode-hook</p><p style="margin:0px 0px 20px;padding:0px;">  (lambda ()</p><p style="margin:0px 0px 20px;padding:0px;">    (paredit-mode 1)</p><p style="margin:0px 0px 20px;padding:0px;">    (define-key scheme-mode-map (kbd &quot;&lt;f5&gt;&quot;) 'scheme-send-last-sexp-split-window)</p><p style="margin:0px 0px 20px;padding:0px;">    (define-key scheme-mode-map (kbd &quot;&lt;f6&gt;&quot;) 'scheme-send-definition-split-window)))</p><p style="margin:0px 0px 20px;padding:0px;">我的配置会在加载 Scheme 文件的时候自动载入 ParEdit mode，并且把 F5 键绑定到“执行前面的S表达式”。这样设置的目的是，我只要把光标移动到一个S表达式之后，然后用一根手指头按 F5，就可以执行程序。够懒吧。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">4. ParEdit mode 的简单使用方法</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>ParEdit mode 是一个很特殊的模式。它起作用的时候，你不能直接修改括号。这样所有的括号都保持完整的匹配，不可能出现语法错误。但是这样有一个问题，如果你要把一块代码放进另一块代码，或者从里面拿出来，就不是很方便了。<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为此，ParEdit mode 提供了几个非常高效的编辑方式。我平时只使用两个： </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1) C-right: 也就是按住 Ctrl 再按右箭头。它的作用是让光标右边的括号，“吞掉”下一个S表达式。</p><p style="margin:0px 0px 20px;padding:0px;">比如，(a b c) (d e)。你把光标放在 (a b c) 里面，然后按 C-right。结果就是 (a b c (d e))。也就是把 (d e) 被整个“吞进”了 (a b c) 里面。 </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">2) M-r: 去掉外层代码。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这在你需要去掉外层的 let 等结构的时候非常有用。比如，如果你的代码看起来是这样：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(let ([x 10])</p><p style="margin:0px 0px 20px;padding:0px;">  (* x 2))</p><p style="margin:0px 0px 20px;padding:0px;">当你把光标放在 (* x 2) 的最左边，然后按  M-r，结果就变成了</p><p style="margin:0px 0px 20px;padding:0px;">(* x 2)</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">也就是把外面的 (let ([x 10]) ...) 给“掀掉”了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其它的一些按键虽然也有用，不过我觉得这两个是最有用的，甚至不可缺少的。有些其他的自动匹配括号的模式，没有提供这种按键，所以用起来很别扭。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">5. 设置括号颜色</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人看见 Lisp 就怕了，就是因为它看起来括号太多。可是这样的语法，却是有很大的好处的（参考这篇博文《<a href="http://blog.sina.com.cn/s/blog_5d90e82f0101irad.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">谈语法</a>》）。如果你真的觉得括号碍眼，你可以稍微调整一下括号的颜色，比如淡灰色。这样括号看起来就没有那么显眼了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你只需要下载这个 el，放到你的 .emacs.d:</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">  <a href="https://www.dropbox.com/s/v0ejctd1agrt95x/parenface.el" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">https://www.dropbox.com/s/v0ejctd1agrt95x/parenface.el</a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然后在 .emacs 里面加入两行：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">(require 'parenface)</p><p style="margin:0px 0px 20px;padding:0px;">(set-face-foreground 'paren-face &quot;DimGray&quot;)</p><p style="margin:0px 0px 20px;padding:0px;">然后再打开 Scheme 代码的时候，你就会看到是这个样子：</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101ko2d&amp;url=http://s2.sinaimg.cn/orignal/5d90e82fgda1d51f37161" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgda1d51f37161&600.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/><br/><p style="margin:0px 0px 20px;padding:0px;">好了，这就是我写 Scheme 的所有配置了。希望这些有所帮助。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="985"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bf1d" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">我看PhD</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">前段时间看了一下这些关于 PhD 的负面信息： <br/><br/>
一个专门反对读 PhD 的 BLOG 叫“100 Reasons NOT to Go to Graduate School”（下文简称“100个理由”） <br/>
哈佛大学教授 William James 的“The PhD Octopus”（写于 1903 年） <br/>
斯坦福大学的计算机系博士 Philip Guo 写的书“The Ph.D. Grind”（描述他的 PhD 生涯） <br/>
专门讽刺 PhD 生活的系列漫画“PhD Comics”（PhD Movie 拍得很烂，不要看！） <br/><br/>
它们都向我们提出这样一个问题：PhD 到底还值不值得读？作为一个读了十多年 PhD，周转了三个大学（清华，Cornell, Indiana），仍然没有毕业的人，我想提出一点我的独家见解，并且对他们其中的某些内容提出一些看法，希望对后来人有所启发。 <br/><br/>
1. 我是什么？ <br/><br/>
在提出自己的看法之前，我想先说明的问题是，我对此有资格发言吗？答案是毋庸置疑的。我已经比一般人看透了很多的东西，所以对此我不需要再谦虚。 <br/><br/>
很多人发现我还没有毕业的时候，想到的的首要问题是：“王垠，你在干什么？为什么还没有拿到 PhD？怎么一篇 paper 都没有发表？”有时候看到以前的同学都当了教授，或者成为了某公司的总工程师，我也问我自己这个问题，我到底追求的是什么？我也曾经被各种虚浮的标准所困惑，搞不清楚自己到底在走向何方。可是当我发现自己能在两个星期之内不看书不看论文，独立得出并且“消灭”某些“深奥”的领域20多年的所有研究成果的时候；当我依靠自己的独立思考，“猜出”整本整本的经典专业著作的内容的时候；当我在十几分钟之内浏览完几百页的博士论文，并且知道它们是如何在扯淡的时候；当我轻而易举的看透领域里的某些顶尖专家耍的小把戏，发现他们其实看不到事物本质，只会制造吓人的术语的时候；当我不再对“逻辑”或者“定理”之类的术语感冒，看到一个“新逻辑”就知道它是如何被设计出来的时候；当我发现自己的导师已经跟不上我的思维的时候；当我在12个星期的实习期内，从无到有的设计和实现了 Google 一个小组的资深程序员需要好几年才能完成的项目的时候；当我发现很多人的论文深度还不如我的 blog 的时候；当我一眼就看出某些大公司设计的“新语言”其实完全是扯淡的时候；当我不再崇拜任何偶像，不再拿图灵奖或者别的什么奖当回事的时候；当我认识到 Church，Kleene，图灵，冯诺依曼，维根斯坦，Frege，Russell, Godel 的思想的本质，并且开始思索它们的局限性的时候，…… 我明白了自己是什么。我就是“我”，一个自由而强大的灵魂，他在与世界的虚假标准的战斗中胜出。他已经不再需要博士学位，因为博士的头衔其实已经不再能衡量他。这个虚浮的世界，不再有资格给他贴上任何标签。短短十年的时间，能到达这样的境界，还真的很值。 <br/><br/>
William James 在他的 The PhD Octopus 里提到，读 PhD 的有两种人：1.非常聪明，以至于其实不需要 PhD 的人。2.一般聪明，所以需要“PhD”来给自己一个标签的人。我是哪一种人呢？我的情况其实比较特殊。简言之，在 IQ 方面我属于第一种人，但是在 EQ 方面我比较弱，所以一直被这个世界以它的各种肤浅的标准衡量着，蒙蔽着，以至于以为自己是第二种人。可惜的是，我的世界，现在我已经不会再被你欺骗了，不用再企图蒙蔽我。 <br/><br/><br/>
我一直不确信自己是否应该作出这样判断，一直怀疑自己是否错了，是否太自傲。我试图保持谦虚，却往往因为这种谦虚被人误解，以至于怀疑我的能力，以至于让没有资格评价我的人和规则来左右我，以至于让半壶水响叮当的人在我面前炫耀。谦虚是一种美德，但是诚实更加重要，谦虚过了头就变成了虚伪。我必须对自己诚实，展现真正的自我，不再把别人对我的看法当回事。 <br/><br/>
有人也许误解了我，认为我一味鄙视自己待过的学校和公司。而其实我并不会因为别人学识不行就鄙视他们，正好相反，我对他们相当友好。我鄙视的其实是精英主义分子。越是因为自己出身名校或者效力业界巨头就自认为高人一等的人，越是容易被我鄙视。把名校和大公司的名字挂在嘴边，说明他们其实自己都瞧不起自己，看不到自己的个人价值，所以被我瞧不起也理所当然喽。我也很讨厌满口术语的人。使用偏僻的术语，往往说明他们并不理解这些术语的内涵。真正理解这些术语的人，往往会直接使用它们的内涵，而不是它们的名字。 <br/><br/><br/>
2. PhD 是否仍然有价值 <br/><br/>
好了，说出了心里话。现在让我来谈谈很多学生关心的问题：PhD 是否仍然值得去读。这是一个非常困难的问题。我并不觉得本文开头列出的对 PhD 的负面评价，是完全客观公正的。虽然它们的某些看法是正确的，但是里面也含有一些片面的，目光短浅的东西。 <br/><br/>
简言之，我对此的答案是：读 PhD 这个过程仍然可能有价值，但是 PhD 的头衔，其实没有什么价值。下面我来详细解释一下这是为什么。 <br/><br/>
首先，为什么读 PhD 这个过程仍然可能有价值？那是因为你能利用它来学到精华的知识。注意，我说的只是“可能”，而不是“肯定”有价值，因为有很多因素决定了 PhD 的学习是否有价值。一个很显然的事实是，本科的教育不会教给你深入的知识，因为几乎所有大学（包括所谓的“世界一流大学”）的本科教育都是填鸭式的。本科生心里想的，只不过是通过考试，提高 GPA，所以他们一般只能学到皮毛。硕士，不过是本科的一点点延伸而已。读硕士的人往往急功近利，只是为了找到一份稍微好点的工作。只有 PhD 学生由于有专门的导师指导，而且需要好几年才能毕业，所以在客观上他们有可能静下心来学会真正的东西。 <br/><br/>
可是一个有价值的 PhD 阶段，却是来之不易的。有非常多的因素决定你是否学到真东西： <br/>
一个有真知，而且愿意分享真知的导师。事实上，除非你是神童，你只有直接从人那里才会学会真知，而不是从书籍或者论文。最深刻的知识，往往不是通过书籍或者论文传播的，而是通过人直接口授。这种现象产生的原因是人类的自私。刚入行的学生往往会高估本领域的“顶尖专家”们的学识和品德，以为看了牛人写的“经典著作”就可以得到真知。可是其实呢，每个人都是自私的。他们往往不会把最核心的直觉和想法写进书籍和论文里，而只是把一堆复杂的符号，公式，定理，证明写进去，让你知其然而不知其所以然。这种现象在数学，逻辑，和计算机科学里面尤为常见。打个比方，这就像写了程序之后不把源程序给你，而只是编译后的二进制代码。得到这种“二进制知识”的人，永远也不会看透这些复杂的符号背后其实有着非常简单的想法。数学和逻辑的书很难看懂，就是这个原因。拥有真知的人，却不一定在牛校，所以你需要放宽视野。我在 Cornell 的时候很郁闷，因为教授们往往写一黑板公式，却没有透露一点点直觉和想法。有一天当一个教授写满了两黑板的证明之后我问他：“你证明了这个定理的正确性，可是我想知道的是这个定理本身是怎么想出来的。”他说：“你问这种问题有什么意义吗？我告诉你它是正确的，那就够了。只有非常聪明的人，花很多精力才能想得出来这样的定理。”后来到了 IU，却发现有个教授上课时轻松的道出了这个定理的由来。然后我才发现，原来那个 Cornell 的教授其实只是照本宣科，还咋呼人。 <br/>
自己的努力。那么什么样的人会向你分享所有最精辟的思想呢？没有人。自古以来，所有的武林高手都会对自己的门徒留一手。而高深的学者与武林高手的作风其实惊人的相似，就连我最尊敬的 Dan Friedman 教授也不例外。他自己知道的东西，比他提点大家的东西要多很多，可是他不会全都说出来。这就是为什么上过他的课的人的对他评价不一。我对他有非常高的评价，因为我认为他的点拨加上我自己的努力，让我学到了很多东西。可是也有人对他的评价是“我什么也没学到，因为他根本没有教我们！”IU 的另一个世外高人 R. Kent Dybvig，他的 Chez Scheme 编译器里有很多没有发表的机密。毫不客气的说，这个人比起“龙书”，“虎书”或者 LLVM 的作者，造诣都要高很多。但是他是如此的“超然物外”，以至于他根本不屑于让人知道他的想法。他只用很酷的眼神告诉你：“你被打败了。”只有当你拼命去想，快接近答案的时候去试探他，他才会透露给你一点点线索：“你的方向是对的。”仅此而已！所以自己的能动性和努力是非常重要的。俗话说“机遇只会青睐有准备的人”，“师傅领进门，修行在个人”，就是这个道理。 <br/><br/>
找对导师，自己努力。如果做不到这两点，那么就不要盲目的进入 PhD。否则那“100个理由”里面，可能有90个都会出现！这两点里，第一点特别困难。因为在这个谣言横行的世界，再加上本科生毕业生经验的缺乏，很难说清楚谁是有真知的人。一般人的做法就是看名气，但是这往往是错误的。所以除非你在本科阶段已经深入的了解了导师，否则恐怕最好的做法是先去工作几年，把自己的生活安顿下来之后，再慢慢研究 PhD 的事情。这样还有另一个好处：因为自己有了经济的保障，你会在师生关系的心理上占据一些主动。因为你随时可以走人，所以教授们不会以为你可以被“任人宰割”。另外一个经验就是，在进入博士学习以后，要多方面考察，不要吊死在一棵树上。不妙就撤，找对前进的方向，节省精力和时间。 <br/><br/><br/>
那么为什么 PhD 的头衔其实没有价值呢？因为 PhD 不再存在于光辉的迷雾里。这个社会在进步，它知道每年有多少 PhD 毕业，它知道绝大部分的 PhD 到底是怎么拿到的。这个年头，笨蛋也能从名校拿到 PhD，只要你会“混”。PhD 不过是个游戏而已，这是非常真实的事实。“你的 PhD 做了什么？”现在几乎每一个雇主都会问这个问题。他们往往会实际的考察你做的东西对他们有没有价值，而不是只看你的头衔。所以没有作出有价值东西的人，即使拿到了 PhD，也不会有很大的发展，甚至不如本科生。 <br/><br/><br/>
3. 美国大学的现状 <br/><br/><br/>
《100个理由》已经指出很多我要说的东西。其中有一些重复的话题，也有一些片面和错误的看法。那么美国大学的现状是什么样的呢？经历过两个美国大学，一个常青藤联盟的名校，一个名不见经传的公立大学。见识了顶尖的专家学者以及其它顶尖名校的博士。现在我想我可以做出一个比较全面的总结了。 <br/><br/>
本科应试教育。上过“新东方”的人都被蒙蔽了。所谓的西方批判性思想（critical thinking），其实在美国是非常缺乏的。美国其实是一个非常“河蟹”的社会。但是与中国不同，它构建在非常巧妙的，虚伪的社会人际关系之上。笑里藏刀是常见的，拍马屁的功夫之高，拍得你都看不出痕迹。找工作，申请学校的时候别人都看推荐信，所以你永远不敢得罪上司，否则他可以向新雇主说你坏话。中国的统治者们，真的应该向美国人好好学学。在美国的大学里，你很少见到直抒己见的人。美国没有 BBS，没有愤青，每个学生都是沉默的羔羊。学生怕老师，怕分数，是普遍的现象。大家都只关心 GPA，而不是得到真知。我曾经对教育很热心，试图教给他们一些真东西，可是到头来都觉得很浪费表情。因为他们只会在作业快要提交的那天来找你，而且只是想套出题目的答案。不管是 Cornell 还是 IU，还是别的什么世界名校，都是一个样。 <br/>
没有深入讨论。《美丽心灵》里面的开放的讨论，已经不存在了。Common Room，现在是用来睡午觉的地方。“100个理由”提到，同领域的人，都是竞争者，这一点都不假。每一个有点想法的人，都怕自己的想法被别人“偷走”。每一个没有自己想法的人，都想从别人那里偷一点过来。所以结果就是，厉害的人绝对不会在发表论文之前把真实的想法透露给别人。因为他们所关心的，是让这个想法被冠以自己的名字。不管是你的同事，或者领域里的顶尖学者，其实都一个样。如果你很坦率的把自己的想法告诉别人，这个人可能会打击你的信心，说这个想法其实已经有人做过了。等你对自己的想法失去了兴趣，他却悄悄的把你的想法以他自己的名义发表。这种勾心斗角的现象，我经历过或者听说过好几次，所以我现在都不跟人说真实的想法了。核心的想法自己留起来，衍生出来的“二等品”甚至“三等品”才公开出来。当然这样不利于学术发展，但是我也没有办法。 <br/>
信息不平等。美国大学的研究生很少直言不讳的评价一个教授的学识和人品，一是怕这些话传到教授耳朵里对自己不利，另外他们不想让你抢走他们的教授。所以当你选择导师的时候，不能轻信任何人的评价，因为他们一般都只会对你说“他是大牛啊。好厉害！”我有一次就是凭直觉觉得一个教授的研究完全是在扯淡，可是因为别人告诉我他很牛，所以我开始怀疑自己的判断力。在跟他做了一段时间研究之后才完全的确信，他确实就是在扯淡。这种学生之间的信息不通，造成了很多博士生对研究的迷惑。可是具有讽刺意味的是，教授之间的信息通道却是非常畅通的。每隔一段时间，系里都会召开一次全体教授会议，讨论各个学生的进展情况。当然某个教授对你有意见的话，肯定会毫不留情的说出来。所以你看到了，这种信息流通上的不平等，造成了学生们在战略上的被动。学生其实是一个非常不团结，充满内斗的被压迫阶级。 <br/>
近亲繁殖。如果你想得到真知，那么就去找拥有真知的人，可是真知不等于“仕途”。如果你想在美国大学里找到职位，那么你必须得拼命进入“牛校”，因为只有从那里才能进入这种“学术关系网”。同一个导师的学生，往往能打成一团；而那些导师的死对头的学生，想法再好我们也要嗤之以鼻。IU 这种无名之辈，里面的教授一个个不是哈佛就是 Princeton 或者 MIT 毕业的，所以你可以看到 PhD 已经多到了什么样的地步。进了牛校，不管你最后落到什么样的导师手里，只要你肯做苦力，硬着头皮毕业了，将来一般都能在学术界混下去，就这样永远的混下去。如果无知的同事，违心的夸奖，肤浅的论文，无聊的会议，急功近利的学生，超长的工作时间，能带给你快乐的话，何乐而不为呢？ <br/>
发表，发表，发表。“100个理由”提到人文学科的会议以及论文的泛滥，其实在科学界，特别是计算机科学界，也是一样的。全世界都是一样的。我一月份的时候参加了一次本领域最顶尖的会议：POPL（Principles Of Programming Languages）。我不得不说，里面一半以上的论文其实都是废话，但是很多打着像“逻辑”一类的旗号来吓唬人。其实会议的基本用途，就是方便人们打广告，拉关系，找工作。比如，我在这会议上就遇到好几个早已毕业的博士在找工作。还在校的博士生们也紧张的忙着向前辈们显示自己。思想的交流？其实很少。所以我对这个领域的会议其实已经失去了兴趣。计算机界顶尖的理论领域都如此，其他的领域肯定就更加扯淡了。我现在看的论文，好多都是出自100年前的大师们。可能也只有他们，才会无私的透露出真实的想法。因为那个年代的学者是很穷的，不被人重视，所以也没有什么动机发表废话。 <br/>
政治斗争。一个领域的研究进行到一定的阶段，所有根本性的理论都已经被发现，又不想宣告解散。剩下的日子怎么活呢？没有办法，只好把旧的想法贴上新的标签拿出来兜售喽。或者提出一些“等价”的，却没必要存在的概念。只要有人把你捧起来，你就可以创造新的“领域”，召开新的会议，成为这个领域的头面人物，甚至得到领域里的最高荣誉（比如图灵奖）。所以最关键的事情就是如何推销你的“新想法”，以及如何巧妙的附和别人的想法。有时候即使你的想法其实没有价值，也会有人来支持你。因为这些人都知道这个道理，把你捧红，然后他们也方便沾光了。这就是为什么我经常在几天的探索后发现，某些领域20年来的成果几乎完全没有价值，或者被另一个简单的想法完全的超越，它却能继续组织专门的会议。真正简单而深刻的想法，真是少之又少。 <br/><br/>
那么《100个理由》里面有哪些是错误的呢？我可能想不起所有的，这里只暂时提出几点： <br/><br/>
博士生在学校的地位。关于这一点，《100个理由》有很多误导。其实博士生在学校的地位比起本科生和硕士生，可以说是相当高的。有些本科生喜欢作出一副“大爷相”或者“顾客相”，但是跟对待狗一样的原理，只要你够狠，他们就会服服帖帖的。你控制了他们的成绩，所以他们实际上是怕你的。至于本科生给我的 evaluation，我从来就没看过。只要你研究好自己的东西，学校根本不把本科生对你的评价当回事，因为你对学校更有利用价值。当然，大部分本科生还是友好的。 <br/>
朋友很少。读博士到了一定境界，你自然不会再期望有很多朋友。君子之交淡如水。你的境界会让你有所选择，不会再与喜欢低级趣味的人做朋友。所以其实这是一个优点，《100个理由》把这作为读博的缺点，可以说是黑白颠倒了。 <br/>
婚姻，家庭。《100个理由》的作者大概是一个非常传统的人。他经常提到这些东西说：“你的大学同学已经在这些方面超过你。”其实他没有看到的是，这些没有上 PhD 的同学们，他们的“成人生活”其实很可能并不那么幸福。人活一辈子难道就是为了传宗接代吗？结了婚，生了孩子，买了房子，又能怎么样呢？现代发达国家的人们，越是受教育程度高，越是富裕，越是懒得结婚生孩子。很简单的道理，因为它们很少给人带来快乐。相反，它们几乎总是给人带来烦恼，让人老得更快。<br/>
孤独。《100个理由》指出读 PhD 会非常的孤独，可是他并没有理解“高处不胜寒”的道理。每一个聪明的人都会不被人理解，都会孤独，这是不可避免的，不管读不读 PhD 都一样。而且一个人单独做一些事情，并不会感到孤独。孤独来自于对“交流”的期待。如果没有这种期待，那么也不会有孤独。比如我小时候总是一个人玩得很开心，自己有一个大木头箱子，里面装满了我从各处捡回来的“宝贝”。那时候我从来没有感觉到过孤独，因为我并不期望有人跟我交流。其实，读 PhD 的时候如果积极参加活动，还是会有朋友的。 <br/><br/><br/>
总之呢，世界就是这个样子了。人类的愚昧是无止境的，学术界也难幸免。PhD 的头衔对我来说其实已经无关紧要了，因为我已经掌握了一些最核心的思想，足够让我可以藐视整个整个的领域。我其实也没有必要待在学校里，因为它已经不再能教给我新的东西，而它的官僚主义让我厌烦。我仍然在这里，是因为我还没有找到合适的地方和我想做的事情。有一句名言说，去摘最高处的苹果吧，因为你随时可以得到那些低处的。我仍然没有发现我能到达的最高点在哪里。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="992"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c5611" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">谈“测试驱动的开发”</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在的很多公司，包括 Google 和我现在的公司 Coverity，都喜欢一种“测试驱动的开发”（test-driven development）。它的原理是，在写程序的时候同时写上自动化的“单元测试”（unit test）。在代码修改之后，这些测试可以批量的被运行，这样就可以避免不应该出现的错误。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这不是一个坏主意。我在 <a href="http://blog.sina.com.cn/s/blog_5d90e82f0101jscn.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Kent 的编译器课程</a>上也使用了很多测试。它们在编译器的开发中是不可缺少的。编译器是一种极其精密的程序，微小的改动都可能带来重大的错误。所以编译器的项目一般都含有大量的测试。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然而测试的构建，应该是在程序主体已经成形的情况下才能进行。如果程序属于创造性的设计，主体并未成形，过早的加入测试反而会大幅度的降低开发效率。所以当我给 Google 开发 <a href="http://yinwang0.wordpress.com/2010/09/12/pysonar/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Python 静态分析</a>的时候，我几乎没有使用任何测试。虽然组里的成员催我写测试，但是我却知道那只会降低我的开发效率，因为这个程序在几个星期的过程中，被我推翻重来了好几次。要是我一开头就写上测试，这些测试就会碍手碍脚，阻碍我大幅度的修改代码。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">测试的另一个副作用是，它让很多人对测试有一种盲目的依赖心理。改了程序之后，把测试跑一遍没出错，就以为自己的代码是正确的。可是测试其实并不能保证代码的正确，即使完全“覆盖”了也是一样。覆盖只是说你的代码被测试碰到过了，可是它在什么条件下碰到的却没法判断。如果实际的条件跟测试时的条件不同，那么实际运行中仍然会出问题。测试的条件往往是“组合爆炸”的数量级，所以你不可能测试所有的情况。唯一能可靠的方法是使用严密的“逻辑推理”，证明它的正确。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当然我并不是让你用 <a href="http://www.cs.utexas.edu/~moore/acl2/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">ACL2</a> 或者 <a href="http://coq.inria.fr/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Coq</a> 这样的定理证明软件。虽然它们的逻辑非常严密，但是用它们来证明复杂的软件系统，需要顶尖的程序员和大量的时间。即使如此，由于理论的限制，程序的正确性有可能根本无法证明。所以我这里说的“逻辑推理”，只是局部的，人力的，基本的逻辑推理。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人写程序只是凭现象来判断，而不能精密的分析程序的逻辑，所以他们修改程序经常“治标不治本”。如果程序出问题了，他们的办法是看看哪里错了，也不怎么理解，就改一下让它不再出错，最多再把所有测试跑一遍。或者再加上一些新的测试，以保证这个地方下次不再出问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这种做法的结果是，程序里出现大量的“特殊情况”和“创可贴”。把一个“虫子”按下去，另一个虫子又冒出来。忙活来忙活去，最后仍然不能让程序满足“所有情况”。其实能够“满足所有情况”的程序，往往比能够“满足特殊情况”的程序简单很多。这是一个很奇怪的事情：能做的事越多，代码量却越少。也许这就叫做程序的“美”，它跟数学的“美”其实是一回事。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">美的程序不可能从修修补补中来。它必须完美的把握住事物的本质，否则就会有许许多多无法修补的特例。其实程序员跟画家差不多，画家如果一天到头蹲在家里，肯定什么好东西也画不出来。程序员也一样，蹲在家里面对电脑，其实很难写出什么好的代码。你必须出去观察事物，寻找“灵感”，而不只是写代码。在修改代码的时候，你必须用“心灵之眼”看见代码背后所表达的事物。这也是为什么很多高明的程序员不怎么用调试器（debugger）的原因。他们只是用眼睛看着代码，然后闭上眼，脑海里浮现出其中信息的流动，所以他们经常一动手就能改到正确的地方。</p></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="997"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f63df" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">结构化版本控制</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://blog.sina.com.cn/s/blog_5d90e82f0101cnxf.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">结构化版本控制 </a></p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/icon-go.gif" type="image/gif" height="13" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;" width="13"/></p><p style="margin:0px 0px 20px;padding:0px;">作者：王垠 发表时间：2012年10月16日</p><p style="margin:0px 0px 20px;padding:0px;"><a href="https://www.dropbox.com/s/mrzd8spg0jsegq7/struct-vc.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img height="18" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="18"></img></a></p><br/>
可能已经有人看过这个 PPT，不过因为我只在另一篇博文里提了一下，而且链接是国内没法访问那种，所以觉得有必要提出来专门说一下。这个 PPT 前面主要是介绍 <a href="http://blog.sina.com.cn/s/blog_5d90e82f01014tvf.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">ydiff</a> 结构化比较程序的一些技术细节，从28页开始，我开始讲述对一种“结构化版本控制”（structural version control）软件的设想。
<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">通常的版本控制软件（Git, Mercurial, Darcs, ...) 都是基于文本的行或者字符，可是对于程序我们可以做得更好。通过对程序文本进行 parse，我们可以构造超越现有版本控制软件的机制。这个 PPT 基本上包含如下内容：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">如何进行对程序的结构化比较？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 程序的结构化存储会带来什么样的编程工具的发展？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 基于文本的版本控制为什么对于程序来说有一个根本性的错误？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 为什么文本方式的版本控制的某些问题，在结构化的版本控制里根本不存在？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">Darcs 为什么需要 patch theory，而 Git 为什么不用它？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 结构化版本控制的一些未来发展方向。</p></li></ul></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1002"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f639f" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">小小科学家的归来</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠 发表时间：2012年5月18日</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人来信关心我的现状，所以在写别的技术性文章之前，先说说我现在的情况吧。虽然自己追求的东西和经历都比较不同寻常，但是也许可以给奋斗中的人们一些慰藉和鼓励。</p><p style="margin:0px 0px 20px;padding:0px;">首先是超级好消息。几经周折，我得到了我想要的东西：异常强大而独立的思想。我成为了我想成为的人：曾经那个爱玩蚂蚁的“小小科学家”。是的，他回来了，他永远都不会再离开。现在的我，每一天都充满了激情。脑子里总是有一些没法描述的，神奇的思想在萌发。它们让我感觉到无与伦比的美，让我的脸上浮现出笑容。它们让我从睡梦中蹦起，去试验。它们让我对这个世界有焕然一新的看法。我很惊奇的发现自己的思想所能达到的位置。</p><br/><p style="margin:0px 0px 20px;padding:0px;">这也许不是一般人所向往的：早点博士毕业，拿到教授职位或者找到工作。但这些是我的目标吗？从来就不是。写我不满意的论文，拿我不满意的博士学位或者教授职位，有什么用吗？设想一下，如果我委屈自己在清华或者Cornell，当了教授，也许今天正在痛苦挣扎，给本科生上我不喜欢的课，写毫无意义的proposal，争取funding，想办法让我的PhD学生多做点事情，赶一些没必要的论文deadline…… 我还会有时间思考真正重要的问题吗？（关于什么是重要的问题，我以后会写一些。）独立的思想，比这些重要太多太多。它能给我快乐，给我自由，给我想要的一切。没有人再能控制我，阻挡我。</p><p style="margin:0px 0px 20px;padding:0px;">所以现在回顾一下，离开清华和Cornell，都是再正确不过的决定。如果不离开，我就不可能是今天的我。在这过程中，我非常感激的人是 Dan Friedman，是他从绝望中拯救了我。在这个退休的年龄，他对真知的追求和孩子般的好奇心，一次次的教育我，鼓励我。他教会我的那些东西，是真正的无价之宝。</p><p style="margin:0px 0px 20px;padding:0px;">所以经过一番奋斗，我其实已经达到了自己的理想。剩下的事情只是继续享受和发挥我的思想，去探索未知的世界，以及把这些经验分享给需要它的人。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="1006"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bea8" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">如何掌握程序语言</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　学习程序语言是每个程序员的必经之路。可是这个世界上有太多的程序语言，每一种都号称具有最新的“特性”。所以程序员的苦恼就在于总是需要学习各种稀奇古怪的语言，而且必须紧跟“潮流”，否则就怕被时代所淘汰。</p><p style="margin:0px 0px 20px;padding:0px;">　　作为一个程序语言的研究者，我深深的知道这种心理产生的根源。程序语言里面其实有着非常简单，永恒不变的原理。看到了它们，就可以在很短的时间之内就能学会并且开始使用任何新的语言，而不是花费很多功夫去学习一个又一个的语言。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对程序语言的各种误解</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　学习程序语言的人，经常会出现以下几种心理，以至于他们会觉得有学不完的东西，或者走上错误的道路。以下我把这些心理简要分析一下。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 程序语言无用论。这是国内大学计算机系的教育常见的错误。教授们常常对学生灌输：“用什么程序语言不重要，重要的是算法。”而其实，程序语言却是比算法更加精髓的东西。任何算法以及它的复杂度分析，都是相对于某种计算模型，而程序语言就是描述这种计算模型的符号系统。算法必须用某种语言表述出来，通常算法设计者使用伪码，这其实是不严谨的，容易出现推理漏洞。算法设计再好，如果不懂得程序语言的原理，也不可能高效的实现。即使实现了，也可能会在模块化和可扩展性上面有很大问题。某些算法专家或者数学家写出来的程序极其幼稚，就是因为他们忽视了程序语言的重要性。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 追求“新语言”。基本的哲学告诉我们，新出现的事物并不一定是“新事物”，它们有可能是历史的倒退。事实证明，新出现的语言，可能还不如早就存在的。其实，现代语言的多少“新概念”不存在于最老的一些语言里呢？程序语言就像商品，每一家都为了拉拢程序员作广告，而它们绝大多数的设计都可能是肤浅而短命的。如果你看不透这些东西的设计，就会被它们蒙蔽住。很多语言设计者其实并不真的懂得程序语言设计的原理，所以常常在设计中重复前人的错误。但是为了推销自己的语言和系统，他们必须夸夸其谈，进行宗教式的宣传。</p><p style="margin:0px 0px 20px;padding:0px;">　　3. “存在即是合理”。记得某人说过：“不能带来新的思维方式的语言，是没有必要存在的。”他说的是相当正确的。世界上有这么多的语言，有哪些带来了新的思维方式呢？其实非常少。绝大部分的语言给世界带来的其实是混乱。有人可能反驳说：“你怎么能说 A 语言没必要存在？我要用的那个库L，别的语言不支持，只能用A。”但是注意，他说的是存在的“必要性”。如果你把存在的“事实”作为存在的“必要性”，那就逻辑错乱了。就像如果二战时我们没能打败希特勒，现在都做了他的奴隶，然后你就说：“希特勒应该存在，因为他养活了我们。”你的逻辑显然有问题，因为如果历史走了另外一条路（即希特勒不存在），我们会过上自由幸福的生活，所以希特勒不应该存在。对比一个东西存在与不存在的两种可能的后果，然后做出判断，这才是正确的逻辑。按照这样的推理，如果设计糟糕的A 语言不存在，那么设计更好的 B 语言很有可能就会得到更多的支持，从而实现甚至超越 L 库的功能。</p><p style="margin:0px 0px 20px;padding:0px;">　　4. 追求“新特性”。程序语言的设计者总是喜欢“发明”新的名词，喜欢炒作。普通程序员往往看不到，大部分这些“新概念”其实徒有高深而时髦的外表，却没有实质的内涵。常常是刚学会一个语言 A，又来了另一个语言 B，说它有一个叫 XYZ 的新特性。于是你又开始学习B，如此继续。在内行人看来，这些所谓的“新特性”绝大部分都是新瓶装老酒。很多人写论文喜欢起这样的标题：《XYZ：A Novel Method for ...》。这造成了概念的爆炸，却没有实质的进步。</p><p style="margin:0px 0px 20px;padding:0px;">　　5. 追求“小窍门”。很多编程书喜欢卖弄一些小窍门，教你如何让程序显得“短小”。比如它们会跟你讲 &quot;(i++) - (++i)&quot;应该得到什么结果；或者追究运算符的优先级，说这样可以少打括号；要不就是告诉你“if 后面如果只有一行代码就可以不加花括号”，等等。殊不知这些小窍门，其实大部分都是程序语言设计的败笔。它们带来的不是清晰的思路，而是是逻辑的混乱和认知的负担。比如 C 语言的 ++ 运算符，它的出现是因为 C 语言设计者们当初用的计算机内存小的可怜，而 &quot;i++&quot; 显然比&quot;i=i+1&quot; 少 2 个字符，所以他们觉得可以节省一些空间。现在我们再也不缺那点内存，可是 ++ 运算符带来的混乱和迷惑，却流传了下来。现在最新的一些语言，也喜欢耍这种语法上的小把戏。如果你追求这些小窍门，往往就抓不住精髓。</p><p style="margin:0px 0px 20px;padding:0px;">　　6. 针对“专门领域”。很多语言没有新的东西，为了占据一方土地，就号称自己适合某种特定的任务，比如文本处理，数据库查询，WEB 编程，游戏设计，并行计算。但是我们真的需要不同的语言来干这些事情吗？其实绝大部分这些事情都能用同一种通用语言来解决，或者在已有语言的基础上做很小的改动。只不过由于各种政治和商业原因，不同的语言被设计用来占领市场。就学习而言，它们其实是无关紧要的，而它们带来的“学习负担”，其实差不多掩盖了它们带来的好处。其实从一些设计良好的通用语言，你可以学会所有这些“专用语言”的精髓，而不用专门去学它们。</p><p style="margin:0px 0px 20px;padding:0px;">　　7. 宗教信仰。很多人对程序语言有宗教信仰。这跟人们对操作系统有宗教信仰很类似。其实如果你了解程序语言的本质，就会发现其实完全没必要跟人争论一些事情。某个语言有缺点，应该可以直接说出来，却被很多人忌讳，因为指出缺点总是招来争论和憎恨。这原因也许在于程序语言的设计不是科学，它类似于圣经，它没法被“证伪”。没有任何实验可以一下子断定那种语言是对的，那种是错的。所以虽然你觉得自己有理，却很难让人信服。没有人会去争论哪家的汉堡更好，却有很多人争论那种语言更好。因为很多人把程序语言当成自己的神，如果你批评我的语言，你就是亵渎我的神。解决的办法也许是，不要把自己正在用的语言看得太重要。你现在认为是对的东西，也许不久就会被你认为是错的，反之亦然。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">如何掌握程序语言</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　看到了一些常见的错误心理，那么我们来谈一下什么样的思维方式会更加容易的掌握程序语言。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 专注于“精华”和“原理”。就像所有的科学一样，程序语言最精华的原理其实只有很少数几个，它们却可以被用来构造出许许多多纷繁复杂的概念。但是人们往往忽视了简单原理的重要性，匆匆看过之后就去追求最新的，复杂的概念。他们却没有注意到，绝大部分最新的概念其实都可以用最简单的那些概念组合而成。而对基本概念的一知半解，导致了他们看不清那些复杂概念的实质。比如这些概念里面很重要的一个就是递归。国内很多学生对递归的理解只停留于汉诺塔这样的程序，而对递归的效率也有很大的误解，认为递归没有循环来得高效。而其实递归比循环表达能力强很多，而且效率几乎一样。有些程序比如解释器，不用递归的话基本没法完成。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 实现一个程序语言。学习使用一个工具的最好的方式就是制造它，所以学习程序语言的最好方式就是实现一个程序语言。这并不需要一个完整的编译器，而只需要写一些简单的解释器，实现最基本的功能。之后你就会发现，所有语言的新特性你都大概知道可以如何实现，而不只停留在使用者的水平。实现程序语言最迅速的方式就是使用一种像 Scheme 这样代码可以被作为数据的语言。它能让你很快的写出新的语言的解释器。我的 GitHub 里面有一些我写的解释器的例子（比如这个短小的<a href="https://github.com/yinwang0/magic/blob/master/interp-call-by-need.ss" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">代码</a>实现了 Haskell 的 lazy 语义）。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">几种常见风格的语言</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　下面我简要的说一下几种常见风格的语言以及它们的问题。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 面向对象语言</p><p style="margin:0px 0px 20px;padding:0px;">　　事实说明，“面向对象”这整个概念基本是错误的。它的风靡是因为当初的“软件危机”（天知道是不是真的存在这危机）。设计的初衷是让“界面”和“实现”分离，从而使得下层实现的改动不影响上层的功能。可是大部分面向对象语言的设计都遵循一个根本错误的原则：“所有的东西都是对象（Everything is anobject）。”以至于所有的函数都必须放在所谓的“对象”里面，而不能直接被作为参数或者变量传递。这导致很多时候需要使用繁琐的设计模式(design patterns) 来达到甚至对于 C 语言都直接了当的事情。而其实“界面”和“实现”的分离，并不需要把所有函数都放进对象里。另外的一些概念，比如继承，重载，其实带来的问题比它们解决的还要多。</p><p style="margin:0px 0px 20px;padding:0px;">　　“面向对象方法”的过度使用，已经开始引起对整个业界的负面作用。很多公司里的程序员喜欢生搬硬套一些不必要的设计模式，其实什么好事情也没干，只是使得程序冗长难懂。</p><p style="margin:0px 0px 20px;padding:0px;">　　那么如何看待具备高阶函数的面向对象语言，比如 Python, JavaScript, Ruby， Scala?当然有了高阶函数，你可以直截了当的表示很多东西，而不需要使用设计模式。但是由于设计模式思想的流毒，一些程序员居然在这些不需要设计模式的语言里也采用繁琐的设计模式，让人哭笑不得。所以在学习的时候，最好不要用这些语言，以免受到不必要的干扰。到时候必要的时候再回来使用它们，就可以取其精华，去其糟粕。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 低级过程式语言</p><p style="margin:0px 0px 20px;padding:0px;">　　那么是否 C 这样的“低级语言”就会好一些呢？其实也不是。很多人推崇C，因为它可以让人接近“底层”，也就是接近机器的表示，这样就意味着它速度快。这里其实有三个问题：</p><p style="margin:0px 0px 20px;padding:0px;">　　 1) 接近“底层”是否是好事？</p><p style="margin:0px 0px 20px;padding:0px;">　　 2)“速度快的语言”是什么意思？</p><p style="margin:0px 0px 20px;padding:0px;">　　 3) 接近底层的语言是否一定速度快？</p><p style="margin:0px 0px 20px;padding:0px;">　　对于第一个问题，答案是否定的。其实编程最重要的思想是高层的语义(semantics)。语义构成了人关心的问题以及解决它们的算法。而具体的实现(implementation)，比如一个整数用几个字节表示，虽然还是重要，但却不是至关重要的。如果把实现作为学习的主要目标，就本末倒置了。因为实现是可以改变的，而它们所表达的本质却不会变。所以很多人发现自己学会的东西，过不了多久就“过时”了。那就是因为他们学习的不是本质，而只是具体的实现。</p><p style="margin:0px 0px 20px;padding:0px;">　　其次，谈语言的“速度”，其实是一句空话。语言只负责描述一个程序，而程序运行的速度，其实绝大部分不取决于语言。它主要取决于 1)算法和2)编译器的质量。编译器和语言基本是两码事。同一个语言可以有很多不同的编译器实现，每个编译器生成的代码质量都可能不同，所以你没法说“A语言比 B 语言快”。你只能说“A 语言的 X 编译器生成的代码，比 B 语言的 Y 编译器生成的代码高效”。这几乎等于什么也没说，因为 B 语言可能会有别的编译器，使得它生成更快的代码。</p><p style="margin:0px 0px 20px;padding:0px;">　　我举个例子吧。在历史上，Lisp 语言享有“龟速”的美名。有人说“Lisp 程序员知道每个东西的值，却不知道任何事情的代价”，讲的就是这个事情。但这已经是很久远的事情了，现代的 Lisp 系统能编译出非常高效的代码。比如商业的 Chez Scheme 编译器，能在 5 秒钟之内编译它自己，编译生成的目标代码非常高效。它可以直接把 Scheme 程序编译到多种处理器的机器指令，而不通过任何第三方软件。它内部的一些算法，其实比开源的 LLVM 之类的先进很多。</p><p style="margin:0px 0px 20px;padding:0px;">　　另外一些函数式语言也能生成高效的代码，比如 OCaml。在一次程序语言暑期班上，Cornell 的 Robert Constable 教授讲了一个故事，说是他们用 OCaml 重新实现了一个系统，结果发现 OCaml 的实现比原来的 C 语言实现快了 50 倍。经过C 语言的那个小组对算法多次的优化，OCaml 的版本还是快好几倍。这里的原因其实在于两方面。第一是因为函数式语言把程序员从底层细节中解脱出来，让他们能够迅速的实现和修改自己的想法，所以他们能够迅速的找到更好的算法。第二是因为 OCaml 有高效的编译器实现，使得它能生成很好的代码。</p><p style="margin:0px 0px 20px;padding:0px;">　　从上面的例子，你也许已经可以看出，其实接近底层的语言不一定速度就快。因为编译器这种东西其实可以有很高级的“智能”，甚至可以超越任何人能做到的底层优化。但是编译器还没有发展到可以代替人来制造算法的地步。所以现在人需要做的，其实只是设计和优化自己的高层算法。</p><p style="margin:0px 0px 20px;padding:0px;">　　3. 高级过程式语言</p><p style="margin:0px 0px 20px;padding:0px;">　　很早的时候，国内计算机系学生的第一门编程课都是 Pascal。Pascal 是很不错的语言，可是很多人当时都没有意识到。上大学的时候，我的 Pascal 老师对我们说：“我们学校的教学太落后了。别的学校都开始教C 或者 C++ 了，我们还在教 Pascal。”现在真正理解了程序语言的设计原理以后我才真正的感觉到，原来 Pascal 是比 C 和 C++ 设计更好的语言。它不但把人从底层细节里解脱出来，没有面向对象的思维枷锁，而且有一些很好的设计，比如强类型检查，嵌套函数定义等等。可是计算机的世界真是谬论横行，有些人批评 Pascal，把优点都说成是缺点。比如 Brain Kernighan 的这篇《<a href="http://www.lysator.liu.se/c/bwk-on-pascal.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Why Pascal is Not My Favorite Programming Language</a>》，现在看来真是谬误百出。Pascal 现在已经几乎没有人用了。这并不很可惜，因为它被错怪的“缺点”其实已经被正名，并且出现在当今最流行的一些语言里：Java,Python, C#， ……</p><p style="margin:0px 0px 20px;padding:0px;">　　4. 函数式语言</p><p style="margin:0px 0px 20px;padding:0px;">　　函数式语言相对来说是当今最好的设计，因为它们不但让人专注于算法和对问题的解决，而且没有面向对象语言那些思维的限制。但是需要注意的是并不是每个函数式语言的特性都是好东西。它们的支持者们经常把缺点也说成是优点，结果你其实还是被挂上一些不必要的枷锁。比如 OCaml 和 SML，因为它们的类型系统里面有很多不成熟的设计，导致你需要记住太多不必要的规则。</p><p style="margin:0px 0px 20px;padding:0px;">　　5. 逻辑式语言</p><p style="margin:0px 0px 20px;padding:0px;">　　逻辑式语言（比如 Prolog）是一种超越函数式语言的新的思想，所以需要一些特殊的训练。逻辑式语言写的程序，是能“反向运行”的。普通程序语言写的程序，如果你给它一个输入，它会给你一个输出。但是逻辑式语言很特别，如果你给它一个输出，它可以反过来给你所有可能的输入。其实通过很简单的方法，可以不费力气的把程序从函数式转换成逻辑式的。但是逻辑式语言一般要在“pure”的情况下（也就是没有复杂的赋值操作）才能反向运行。所以学习逻辑式语言最好是从函数式语言开始，在理解了递归，模式匹配等基本的函数式编程技巧之后再来看 Prolog，就会发现逻辑式编程简单了很多。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">从何开始</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　可是学习编程总要从某种语言开始。那么哪种语言呢？就我的观点，首先可以从 Scheme 入门，然后学习一些 Haskell (但不是全部)，之后其它的也就触类旁通了。你并不需要学习它们的所有细枝末节，而只需要学习最精华的部分。所有剩余的细节，会在实际使用中很容易的被填补上。现在我推荐几本比较好的书。</p><p style="margin:0px 0px 20px;padding:0px;">　　《The Little Schemer》(TLS)：我觉得 Dan Friedman 的 The Little Schemer 是目前最好，最精华的编程入门教材。这本书很薄，很精辟。它的前身叫《The Little Lisper》。很多资深的程序语言专家都是从这本书学会了 Lisp。虽然它叫“The Little Schemer”，但它并不使用 Scheme 所有的功能，而是忽略了 Scheme 的一些毛病，直接进入最关键的主题：递归和它的基本原则。</p><p style="margin:0px 0px 20px;padding:0px;">　　《Structure and Interpretationof Computer Programs》(SICP)：TheLittle Schemer 其实是比较难的读物，所以我建议把它作为下一步精通的读物。SICP 比较适合作为第一本教材。但是我需要提醒的是，你最多只需要看完前三章。因为从第四章开始，作者开始实现一个 Scheme 解释器，但是作者的实现并不是最好的方式。你可以从别的地方更好的学到这些东西。不过也许你可以看完 SICP 第一章之后就可以开始看 TLS。</p><p style="margin:0px 0px 20px;padding:0px;">　　《A Gentle Introduction to Haskell》：对于 Haskell，我最开头看的是 A GentleIntroduction to Haskell，因为它特别短小。当时我已经会了 Scheme，所以不需要再学习基本的函数式语言的东西。我从这个文档学到的只不过是 Haskell 对于类型和模式匹配的概念。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">过度到面向对象语言</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　那么如果从函数式语言入门，如何过渡到面向对象语言呢？毕竟大部分的公司用的是面向对象语言。如果你真的学会了函数式语言，就会发现面向对象语言已经易如反掌。函数式语言的设计比面向对象语言简单和强大很多，而且几乎所有的函数式语言教材（比如 SICP）都会教你如何实现一个面向对象系统。你会深刻的看到面向对象的本质以及它存在的问题，所以你会很容易的搞清楚怎么写面向对象的程序，并且会发现一些窍门来避开它们的局限。你会发现，即使在实际的工作中必须使用面向对象语言，也可以避免面向对象的思维方式，因为面向对象的思想带来的大部分是混乱和冗余。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">深入本质和底层</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　那么是不是完全不需要学习底层呢？当然不是。但是一开头就学习底层硬件，就会被纷繁复杂的硬件设计蒙蔽头脑，看不清楚本质上简单的原理。在学会高层的语言之后，可以进行“语义学”和“编译原理”的学习。</p><p style="margin:0px 0px 20px;padding:0px;">　　简言之，<a href="http://blog.sina.com.cn/s/blog_5d90e82f010184hx.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">语义学</a>(semantics)就是研究程序的符号表示如何对机器产生“意义”，通常语义学的学习包含 lambda calculus 和各种解释器的实现。编译原理(compilation)就是研究如何把高级语言翻译成低级的机器指令。编译原理其实包含了计算机的组成原理，比如二进制的构造和算术，处理器的结构，内存寻址等等。但是结合了语义学和编译原理来学习这些东西，会事半功倍。因为你会直观的看到为什么现在的计算机系统会设计成这个样子：为什么处理器里面有寄存器(register)，为什么需要堆栈(stack)，为什么需要堆(heap)，它们的本质是什么。这些甚至是很多硬件设计者都不明白的问题，所以它们的硬件里经常含有一些没必要的东西。因为他们不理解语义，所以经常不明白他们的硬件到底需要哪些部件和指令。但是从高层语义来解释它们，就会揭示出它们的本质，从而可以让你明白如何设计出更加优雅和高效的硬件。</p><p style="margin:0px 0px 20px;padding:0px;">　　这就是为什么一些程序语言专家后来也开始设计硬件。比如 Haskell 的创始人之一 Lennart Augustsson 后来设计了 BlueSpec，一种高级的硬件描述语言，可以 100% 的合成 (synthesis) 为硬件电路。Scheme 也被广泛的使用在硬件设计中，比如 Motorola, Cisco 和曾经的 Transmeta，它们的芯片设计里面含有很多 Scheme 程序。</p><p style="margin:0px 0px 20px;padding:0px;">　　这基本上就是我对学习程序语言的初步建议。以后可能会就其中一些内容进行更加详细的阐述。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1014"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c094" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">你好，世界</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">周末闲的无事，打算先写一点关于自己的更新，然后再在下一篇博文里，针对一些来信的共同问题，做一些简单的回复。</p><p style="margin:0px 0px 20px;padding:0px;">　　按照原来的想法，我已经离开了 Indiana 大学，<a href="http://news.cnblogs.com/n/161937/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">不再继续读博士学位</a>。我虽然在 Indiana 大学学到了很多，但是却并不是每个人都能从那里学到好东西，同一个老师的学生质量也参差不齐。实话说吧，我能学会那些东西的很大部分原因，其实在于我自己。俗话说，机遇只青睐有准备的头脑，也就是这个原因。所以不要以为我之前的赞美而去这个学校，否则你很有可能会失望。</p><p style="margin:0px 0px 20px;padding:0px;">　　实话实说，我的老师们（比如 Dan Friedman，Kent Dybvig）真算是世界的头几号专家了。Stanford，Berkeley，MIT，CMU，…… 都很少有人能够与他们相比。也许他们只是客观上导致了我学到好东西，他们并不在乎我。很多时候我感觉他们在对我“留一手”，他们的傲气有时也让我很难接受，但是我还是把自己的学识归功于他们。因为如果没有他们，我也许就学不到现在知道的东西。可是他们的身边，却总是围绕着一群趾高气昂，自认为是“天才”的学生。程序语言的领域里面，充满了其它一些更加自大的人，盲目崇拜的人，借古人的名声来抬高自己威望的人，他们喜欢过度复杂却不中用的公式…… 这一切都让我窒息。所以我很高兴自己离开了那个领域，却悄悄带走了他们的精华。</p><p style="margin:0px 0px 20px;padding:0px;">　　我在旧金山找到了一份还算不错的工作。公司名叫 <a href="http://www.coverity.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Coverity</a>，是一个不怎么知名的 startup，产品是一种程序分析软件。简言之，这种程序能自动找到别的程序里面的错误。这跟我当年在 Google 做的东西概念类似。公司的客户貌似都是一些对代码安全性要求很高的公司（比如丰田，洛克希德.马丁，美国宇航局），所以一般人都不怎么听说它的名字。我不想在这里对公司的产品做任何评价，不过你也许可以在 youtube 上找到一些关于它的<a href="http://www.youtube.com/watch?v=8gOic_LD2u8" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">广告</a>。</p><p style="margin:0px 0px 20px;padding:0px;">　　总的来说工作环境还算满意。没有什么特别值得称道的东西，也没有什么特别不顺心的。也许这才叫做正常的“公司”吧。公司给了你工资，让你帮忙做产品，你就付出相应的智力或者劳力，剩下的时间就做自己喜欢的事情，过自己的周末。如果一个公司恁是要伪装成学校或者教会，总认为自己伟大，了不起，推广自己的“公司文化”，认为你应该仰慕它，向它“学习”，那就不好了。我们是高级知识分子，是 hired gun，又不是国内某些快餐店的打工仔，早上还要穿着制服一起做早操，士气高昂的合唱“公司歌”。给任何公司工作都不要赞美它，不要仰慕它，不要把自己等同于它，才能保持自己的独立和尊严。在这种意义上，我觉得 Coverity 是比较适合我的地方。</p><p style="margin:0px 0px 20px;padding:0px;">　　我住在旧金山市区一个很小的公寓里。每天早上去上班，都走过这么美丽的地方：</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/03181233-536afe8d4eac4e3db5dc0ea0589a3e90.jpg" type="image/jpeg" height="367" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="490"/></p><p style="margin:0px 0px 20px;padding:0px;">　　我才发现，自己错过了多少生命的美好。。。别了，学术界。你好，世界。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1019"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47befd" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">论研究</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">很多人称自己在研究，却不明白什么是研究。实际上，恰恰是“研究”这个时髦的词汇，导致了今天学术界的堕落，以至于使得真正希望研究的人离它而去。<br/><br/>
每个领域都有它硕果累累的时期，在那个时期随手抓到一个果实，就可能成为某个重要分支的鼻祖。可惜的是，这种时期却不是常在的。当那些最重要的理论全都被发现之后，一个领域的研究实际上就完成了它的使命。在这种情况下人们应该做的，其实是总结这些成果，让它们更加容易的被大众吸收，然后开辟新的领域。可是“研究”作为一种有利可图的职业，却推动着学术界朝着相反的方向发展。第一手的学术成果被各种二手货充斥，以至于它们不被人认识。制造出各种无需有的新名词，或者对已有的简单的理论进行故意的复杂化，使得它们显得高深，让人望而却步。所以其实“研究”并不一定是好东西。如果研究没有带来深入的理解，还不如不要研究。<br/><br/>
现在很多的“研究”都可以简单的归为几类：<br/><br/>
1. 应用。套用现成的通用理论，做出一些特例，然后发表。打一个比方，这就像发表一篇论文，标题叫《1234 * 5678 = 7006652》。也许在几千年前你可以称这是研究，让大家知道 5678 个 1234 加起来是多少。但是自从有人发表了一篇论文叫做《乘法》，你再写这样的论文就没有任何价值了，因为所有懂得乘法的人一看就知道这是怎么回事。当然并不是每个人都会乘法，所以你做的事是有意义的，至少你应用乘法的知识解决了一个特定的问题。但是解决了问题并不等于你为此写一篇论文就会有意义。论文应该对人有通用的指导作用，看了的人应该可以用它的方法来解决一类问题，而不只是问题的一个特例。知道了 1234 * 5678 对多少人有用呢？这只是一个比方，但是现在的很多论文跟它非常的神似。某些“热门领域”几乎全都是这样的论文，其实它们的作用不过是广告而已。它们的作者只是想告诉别人“我做了这件事”，而不是“做这件事的方法”。<br/><br/>
2. 改头换面。因为研究必须是“原创”的思想，所以很多人的做法就是给已有的理论起一个新的名字发表出来。如果你涉足多个领域的话就会经常发现这样的现象。比如我发现“程序逻辑”，“程序分析”和“类型理论”里面的很多概念其实对应同一个非常简单的本质。只有当你看到概念对应的本质的时候才会发现，原来某些人完全是在重复别人的工作，某些领域里面的很多概念都是另一个领域的概念换了一种“说法”而已。<br/><br/>
3. 制造问题。有些领域真的是没有问题可解决了。怎么办呢？那就制造问题来解决。就像我的一个同学说的：“有问题要解决；没有问题，制造问题也要解决。”怎么制造问题呢？有一个好办法就是“假设”出一些特定场景。比如，假设某些资源不存在，或者假设某些条件不能改变。本来我们不缺这些资源，条件也是可以灵活改变的，可是你作出相反的假设，问题就出来了。然而很多这些假设，其实都是永远不可能出现的。所以你就做出一些完全不可能找到应用的理论来，或者只找到问题的次优解。<br/><br/>
4. 心理战术。有些论文显得很“理论”，但是其实只不过是用一些可怕的符号和公式作为它们的迷彩。因为它们的作者知道，当读者看不懂公式的时候，往往不是怨作者，而是怨自己脑子不好使，所以如果你看到公式就顶礼膜拜的话，那你就上当了。你必须透过那些符号看清它们所表示的本质含义，才会发现作者的把戏。可是反过来如果你自己不了解这些本质，那么你就看不透那些符号。这个“鸡与蛋”的矛盾就是很多数学家和逻辑学家的看家法宝。数学和逻辑的书很难看懂，也就是这个原因。对于这些符号公式的受害者，我建议你们去看看现代逻辑学鼻祖 Frege 的一些<a href="http://www.olimon.org/uan/frege-writings.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">论文</a>（特别是Begriffsschrift）。看看他是如何用直观的图形来描述最抽象的逻辑，看看他如何指出数学所用的语言给人们的理解带来的混乱。也许从他的文章你会发现，原创的思想其实往往比二手的容易理解很多。<br/><br/>
也许从古至今都是这样，有知识的人喜欢把知识垄断，让没知识的人知其然而不知其所以然。让他们去套用我们想出来的公式和定理，证明给他们看这些是正确的。但是不要告诉他们这些公式和定理是怎么想出来的，不要把知识的“生产工具”给他们。这样这些人就不可能想出跟我们同样水准的公式，就会把我们当成“天才”供养起来。大学里的教授们其实很多时候是故意不告诉你一些公式背后的直觉。很多经典著作的作者也是一样的做法。人们所谓的“尊重权威”，其实跟“新来的小弟乖乖听话”类似。如果你真的去“尊重”他们，依照他们的思想去研究，你就永远也跳不出他们给你设置的知识壁垒。<br/><br/>
所以，学术的“霸权主义”其实已经由来已久了。有什么办法可以突破这道壁垒呢？其实每个人都可以做的一件事情就是：藐视权威。当然，藐视权威并不等于对他没礼貌，而只是在心理上把他真正的作对一个普通人对待。不卑，不亢，不盲从，相信自己的力量。就像纳什的传记《美丽心灵》里所描述的，纳什不看论文不看书，全凭自己的能力重新把整套的理论想出来，不盲从任何权威。很多人都没有意识到，其实他们自己也是可以做到这些的，可是他们总是认为他们不是“天才”，所以不可能做得到。思想的唯一限制，其实是人的信念。只有相信自己能做到，你才能做得到。<br/><br/>
本来研究这活动，从前是贵族阶级吃饱了没事干的消遣，而它现在却成了穷人以为可以用来通往更高阶级的光明大道。贵族做研究就像编笑话，不好笑的笑话，就不用讲给人听了。可是穷人做研究总是为了一点研究经费就像和尚一样去化斋，给我钱我就随便念一段经给你听，反正你也听不懂。也许唯一的根治这个问题的办法是实现罗素所设想的，真正的“<a href="http://www.zpub.com/notes/idle.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">社会主义</a>”。想一下吧，世界上的资源其实足够每个人活得好好的了，机械化大生产也实现了，为什么我们还在这么拼命的工作呢？为了毁灭地球吗？我们应该对每个人都实现一星期五天，一天四小时的工作制，这应该足够支持每个人的衣食住行。之后每个人就都可以像从前的贵族一样，可以进行一些高雅的娱乐活动和真正的研究了。<br/><br/>
这一天会来到吗？<br/></p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="1025"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bf72" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">用脑图来分享思想</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　一直都觉得自然语言并不是分享思想的最好手段。不管是论文，博客，还是个人主页，总是不能很好的传播思想。其中的原因，我觉得是因为自然语言是一种顺序化的媒体。它的产生来自于人类语言最初的载体：声波。那个远古的时候，没有文字，也没有艺术。声波是一种顺序化的媒体，你必须先听到一句话，才能听到下一句话。想想吧，如果两句话同时传过来，你就什么也听不清。然而，人的头脑却是高度并行的信息处理机构。这就是为什么人们往往发现看图比阅读更加迅速，而阅读又比说话更加迅速。我经常发现自己写的博客过一段时间就觉得某些部分表达得不好，却又改来改去总改不对，这就是自然语言的局限性所致。</p><p style="margin:0px 0px 20px;padding:0px;">　　鉴于这个原因，我在很早之前就开始使用一些脑图软件来管理我的思想，比如 Mind Manager 和 Freemind。不过这些软件以前都是单机的，不适合分享思想。不过现在很多都开始朝着 WEB 的方向发展。为了做一个实验，显示脑图对分享思想的作用，我决定开始在一个 WEB 模式的脑图软件上记录我最近的思想，并且公开出来。这样能看到这个网站的人都能知道我在想什么，而我也能随时的更新和改进我的想法。</p><p style="margin:0px 0px 20px;padding:0px;">　　我的第一个公开的脑图是关于计算机科学里的“数据结构”，它的网址在这里：　<a href="http://www.mindmeister.com/212871624/data-structure" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://www.mindmeister.com/212871624/data-structure</a></p><p style="margin:0px 0px 20px;padding:0px;">　　目前只有很少的内容，而且不知道这个 MindMeister 软件到底好不好用。感觉比 Freemind 和 XMind 的 WEB 界面好点，不过比 Mind Manager 可能要差点。</p><p style="margin:0px 0px 20px;padding:0px;">　　不过如果实验成功的话，不久我就会加进很多的东西。目前我还没有发现很好的接受评论的方法，所以如果有问题或者想法，也许只能给我发 email。不过也许这些软件不久就会提供很好的方式来接受评论（比如直接在图的结点上做评论）。</p></div></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="1030"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_479b6a" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">完全用 Gnu/Linux 工作</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">我已经半年没有使用 Windows 的方式工作了。Linux 高效的完成了我所有的工作。</p><p style="margin:0px 0px 20px;padding:0px;">GNU/Linux 不是每个人都想用的。如果你只需要处理一般的事务，打游戏，那么你不需要了解下面这些了。</p><p style="margin:0px 0px 20px;padding:0px;">我不是一个狂热的自由软件份子，虽然我很喜欢自由软件。这篇文章也不是用来推行自由软件运动的，虽然我觉得自由软件运动是非常好的。</p><p style="margin:0px 0px 20px;padding:0px;">这篇文章也不是用来比较 Linux 和 Windows 内核效率，文件系统，网络服务的。我现在是作为一个用户而不是一个开发者来说话的，我们的讨论是基于操作，应用层面的。是为了告诉大学里还不了解，或者不理解 UNIX 的科学工作者和大学生，UNIX 比 Windows 更适合用于科学研究工作，请大家理解 UNIX 的工作方式，不要用 Windows 的标准来要求 Linux，而要用一个科学工作者的标准来要求自己，用 UNIX 的思想来武装自己。</p><p style="margin:0px 0px 20px;padding:0px;">我显然是反对在大学，特别是理工科专业推广 Windows 的。我也反对在对“娃娃” 们的计算机启蒙教育中使用 Windows。因为 Windows 不论从技术上，经济上，思想风格上都是与我们培养高科技人才的目标格格不入的。Windows 的流行属于历史遗留问题，爷爷一级的人当然已经不可救药，但是我们不应该让下一代继续走上歧途。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">UNIX 不是计算机专家的专利</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">当我建议一些非计算机专业的人用 Linux 的时候，很多人说：“UNIX 是计算机系的人用的，我们不能理解。” “UNIX 是男孩用的，我们女孩不用。”</p><p style="margin:0px 0px 20px;padding:0px;">但是其实世界上的大多数科学家和工程师几乎用的都是 UNIX 作为他们的电脑工具。就因为它简单，可靠，稳定，强大，有趣。甚至很多时候 UNIX 就是唯一的选择。</p><p style="margin:0px 0px 20px;padding:0px;">你说：“我们都会用 UNIX 的话，你们计算机专业的人还用来干什么？” 很荣幸的告诉你，计算机专业的有一部分人就是专门为你们提供这样强大而方便的计算机工具的。如果他们制造的工具只有自己会用的话，那这个工具还有什么用？</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">理解 GNU/Linux</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">不要用 Windows 的标准来要求 Linux。</p><p style="margin:0px 0px 20px;padding:0px;">由于GNU/Linux这个词太长，下面如果没有特别指明，“Linux”就是指“GNU/Linux”。</p><p style="margin:0px 0px 20px;padding:0px;">在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得“Linux 只不过是跟 DOS 差不多的东西”，那请问问你旁边的 Linux 用户，Linux 到底是什么？</p><p style="margin:0px 0px 20px;padding:0px;">那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和 UNIX，虽然他们也在用它，但是他们有时会问：“为什么 Linux 不能像 Windows 那样 ……？”，“怎么Redhat Linux不能 mount NTFS 分区！”，“Linux 下用什么整理硬盘？”，“什么时候OpenOffice才能完全兼容Word文件啊？”，“现在还有什么Windows能干的事情Linux干不了的？”……</p><p style="margin:0px 0px 20px;padding:0px;">他们有40G的硬盘，却只为 Linux 分配了2G空间，有时还抱怨“这个东西怎么占这么多硬盘！” 似乎 Windows 该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对 Drag&amp;Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像 Windows 程序的 Linux 程序，一定会很高兴的说：“哈哈！Linux 也能……了！” 如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux解决问题的时候，甚至用Wine[<a href="http://i.linuxtoy.org/docs/guide/ch06s03.html#ftn.id3051836" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">5</a>]来运行Windows程序。有时实在没办法，只好重起到 Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare[<a href="http://i.linuxtoy.org/docs/guide/ch06s03.html#ftn.id3051844" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">6</a>] 虚拟一个 Linux 玩。</p><p style="margin:0px 0px 20px;padding:0px;">你如果出现了上面的情况，说明你的思想受到了 Windows 的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的 UNIX 思想。你支持 Linux，你喜欢 Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux 从来就不是一个玩具，它是天才UNIX的后代。UNIX 是自晶体管发明以来最伟大的发明[<a href="http://i.linuxtoy.org/docs/guide/ch06s03.html#ftn.id3051867" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">7</a>]，它从诞生那一天开始就比 Windows 的设计出色。</p><p style="margin:0px 0px 20px;padding:0px;">你要体会什么叫做“设计”，一个糟糕的设计并不是到后来缝缝补补就可以变好的，而一个出色的设计，不但可以以不变应万变，而且可以影响到后来者。一个出色的设计配上一个出色的实现，那就是非常出色的发明。Linux 就是这样的一个出色的发明。 Linux 并不需要追赶 Windows，也不需要打垮微软。它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。</p><p style="margin:0px 0px 20px;padding:0px;">Unix 是简单的，你不需要成为一个天才也能理解这种简单。</p><p style="margin:0px 0px 20px;padding:0px;">UNIX的设计者 Dennis Ritchie 说：“Unix is simple. It just takes a genius to understand its simplicity.” 但是我不这么认为，因为我不是一个天才，但是我却勇敢的把 Windows 完全删除掉，遇到不明白的事情的时候努力用 UNIX 的方式去解决，而不是寻求 Windows 的帮助。现在我体会到了 UNIX 的思想和好处，我可以用比 Windows 高效几倍的效率工作。因为我相信这样的信念：“Windows 能办到的事 Linux 一定能办到，而且办的更好。”</p><p style="margin:0px 0px 20px;padding:0px;">这小节开头的话应该改成：“Unix 是简单的，你不需要成为一个天才或是计算机专家。但是在这个冲斥着 Windows 错误观念的世界，你需要信念和勇气才能理解它的简单。” 我下面就告诉你一些我理解到的东西。首先，你要知道的是微软在国际科学领域是根本没有地位的。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">微软的地位</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的 MIT，Stanford 的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个“小”并不是说它人少，钱少，而是说它先进技术少。</p><p style="margin:0px 0px 20px;padding:0px;">我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC 作为平台。我在分析算法时还得到 Fortune 很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给 Fortune，他回信说：“对不起。我机器上没有 MFC。” 话说的很客气，但是我已经感觉到了他对 Windows 的不屑。然后我把 MFC 静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。</p><p style="margin:0px 0px 20px;padding:0px;">你能感觉到这位科学家对微软和 Windows 是什么态度了吧？不是反感，而是他心里根本没有 Windows 这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！</p><p style="margin:0px 0px 20px;padding:0px;">好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office XP，学校的选课系统是非IE不能正确浏览，论文用 Word 编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连 863 项目都用 VC 写程序了。我很久以前就看到一份报纸说，“微软为什么不严厉打击盗版？” 这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，“以后我要你们加倍的来还我！” 确实如此，它的目的快实现了。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Windows 笼罩下的中国计算机教育</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">说句丢脸的话，比尔盖茨很久以前是我的偶像……</p><p style="margin:0px 0px 20px;padding:0px;">在中国，比尔盖茨被很多人奉为神圣，“少年电脑天才”，甚至有的人提到他的名字就做出“抱拳对天”的姿势。很多人谈到微软的“新技术”，“高科技” 都是眉飞色舞。各种“VC编程圣经”，“深入了解 Visual C++”之类的书，在开头几页都会出现非常肉麻的字眼，“在那团团的混沌中，一个开天辟地的精灵，Windows 1.0，诞生了……”</p><p style="margin:0px 0px 20px;padding:0px;">微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些 DOS 命令，打字，Windows 基本操作，Word 文档处理，PowerPoint，高级班可能有 Excel，Access…… 参加各种微软认证考试，MCSE，MSDE 的人络绎不绝。考试辅导班都贴出了“280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是“Microsoft Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的 Windows XP 内部发行版。</p><p style="margin:0px 0px 20px;padding:0px;">“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的 Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi 编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种“初级阶段”的时候就已经用 Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！</p><p style="margin:0px 0px 20px;padding:0px;">我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过“中华学习机”。看到新入学的同学们各个谈论的都是 “Windows 95”，“VC”…… 我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：“你们天天谈论的瘟95是什么啊？”答：“win95就是一个操作系统，跟DOS是一类。”“朵死是什么？” “你连DOS都不知道是什么？别在计算机系混了。” 学校上课当然不讲VC编程之类的东西，但是上 Pascal 的老师有一次就说：“嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC 了，我们还在讲 Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。” 于是，有些同学很多时候上课都捧着一本很重的“Windows 编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，“代码的优化是无止境的”，“匈牙利命名法真是伟大的发明 ” …… 这就是中国很多大学计算机系的情况。</p><p style="margin:0px 0px 20px;padding:0px;">感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说 UNIX 好，Xwindow 好的时候，都被一群人围着说教：“这个 Windows 也能做到 ”，“你对 Windows 有偏见”，“微软才是主流啊”，“你敢瞧不起 win2k？”，“.NET 就是世界潮流”，“微软的毕竟是新技术”，“有钱就是有技术”…… 甚至在一番论战比较后败下来还是要说：“Windows 性能差点，但是易用性强”，“Windows 是老百姓用的，要求别那么高 ”，“微软那么有钱，以后想超过 UNIX 还不容易吗？”……</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">发达国家的计算机教育</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">我前段时间在 USENET 发文问有关 Scheme 语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很“深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习 LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 &quot;Syntactic Closures&quot;。他还打包给我寄过来一份 MIT 的 &quot;How to Design Programs&quot;。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行 Scheme 程序。他对 Emacs 的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme 解释器。这对于我来说是望尘末及了。</p><p style="margin:0px 0px 20px;padding:0px;">他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，他是丹麦一所普通高中的计算机老师。</p><p style="margin:0px 0px 20px;padding:0px;">他说他在高中里讲授程序设计和算法，计算机语言文法。他说用 Scheme，他的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。</p><p style="margin:0px 0px 20px;padding:0px;">天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">微软和它的朋友们的如意算盘</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是 100 多美元，每次升级又是几乎同样的价钱。Windows NT 还要贵几倍，而且有用户数目限制，5个用户的，10个用户的…… 以后如果要增加用户数目还要按比例付钱。</p><p style="margin:0px 0px 20px;padding:0px;">花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上 Windows 之后一般第一件事就是去下载一个 WinZip 吧，“只要 29 美元”。Windows 会中病毒啊，马上花 70 美元买一个 Norton AntiVirus 吧。还有黑客呢？再买一个 Norton Internet Security 好了，100 美元。系统需要优化，磁盘需要整理，买一个 Norton System Works 是你最佳的解决方案，100美元。</p><p style="margin:0px 0px 20px;padding:0px;">可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套 Office XP 吧，一起买便宜些，$459.90。</p><p style="margin:0px 0px 20px;padding:0px;">那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看“帮助”也学不会。买本书看看吧，我推荐 “Special Edition Using Microsoft Office XP”，不贵，$27.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，$17.85。</p><p style="margin:0px 0px 20px;padding:0px;">你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为 Windows 程序员。首先买一个 Visual Studio.NET 吧，要不然怎么编译程序。$494.95。</p><p style="margin:0px 0px 20px;padding:0px;">为了紧跟微软动向，世界潮流，不能不注册个 MSDN 什么的吧？这个贵一点，不过物有所值啊，$2,799。</p><p style="margin:0px 0px 20px;padding:0px;">嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样“自由”的，“安全”的生活了</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">为什么要反对使用 Windows</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">很多人都说不应该完全否定 Window，Windows 也有它的长处。不应该骂微软。</p><p style="margin:0px 0px 20px;padding:0px;">对。Windows 容易操作，适合普通用户。如果微软把它自己定位在 P&amp;G，Philips 那样的地位，能够给我们的百姓提供周到的，完善的，价廉物美的服务。那我肯定是很喜欢它的。</p><p style="margin:0px 0px 20px;padding:0px;">但是从上面的种种情况说明，微软是一个野心极大的国际垄断组织！它的产品没有一个是不出问题的：Windows 不稳定，容易中病毒，而微软不为大家免费提供杀毒软件。我就是要让你们花钱买我的朋友 Symantec 的杀毒软件，谁叫你们已经上了我的贼船？这叫什么售后服务啊！</p><p style="margin:0px 0px 20px;padding:0px;">你买来微软的程序，安装的时候一般都有一个协议，说：“由于微软的程序造成你的数据损坏或丢失，微软概不负责。” 我想很多人肯定觉得这个不合理，不想按那个 &quot;I accept&quot;。但是你的软件买都买来了，钱都花了，现在一按 &quot;I decline&quot;，安装程序马上就会退出。你只好被迫点击了 &quot;I accept&quot;！这不是不平等条约吗？</p><p style="margin:0px 0px 20px;padding:0px;">我已经目睹了好几个朋友的文档被 Microsoft Word 损坏，有的是编辑了十多天的30多页的论文，有的是费了很大工夫做出来的个人简历，那个朋友为此失去了到自己向往的 P&amp;G 工作的机会。就在他要投简历的前一个晚上，就在那一瞬间…… 不知道他痛哭的时候有没有想起要投诉微软，可是谁叫我们用的都是盗版呢，况且你还点击了 &quot;I accept&quot;。</p><p style="margin:0px 0px 20px;padding:0px;">微软仗势已经占有大部分PC市场，制定不符合国际标准的“微软的标准”，以不合理的方式压制其它公司的软件，这个问题已经在美国司法部闹了很久了。他甚至在 Windows 系列操作系统中放置能够通过网络泄漏用户信息的代码，以至于 Windows 刚进入澳大利亚时被澳大利亚政府禁止使用。</p><p style="margin:0px 0px 20px;padding:0px;">有些人说：“微软毕竟开创了一个历史，造就了今天的 IT 行业。” 但是，如果没有微软，我们今天早就用上非常稳定，非常可靠，非常方便，非常“傻瓜”的软件了！微软是阻挡信息技术发展的罪魁祸首。</p><p style="margin:0px 0px 20px;padding:0px;">微软的程序的工作方式(注意，我只是说操作方式，病毒的事情另外算)确实适合于一般家庭，上上网，发发邮件，打打游戏都不错。可是微软却要把自己包装成什么 “高科技”企业，要在世界各地设置“研究院”，在大学计算机系赠送不适合用于科研的 Windows 产品，甚至出钱请图灵奖得主来中国畅谈“二十一世纪的计算”，还在大会上宣传自己的 .NET 技术。非要把别人认为自己是科学的，自己是领导世界高科技的。但是呢？它什么高科技也没有。欧洲，美国，哪一个关键部门在用微软的东西？NASA? DOE? CERN? 你仔细想一想，微软的程序对人类到底有什么重大作用？</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">什么是 Windows 能干而 Linux 干不了的事情？</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</p><p style="margin:0px 0px 20px;padding:0px;">有个朋友看我半年没有用 Windows，有时就会问我：“你只用 Linux，有没有发现有些 Windows 能处理的事情 Linux 干不了？”</p><p style="margin:0px 0px 20px;padding:0px;">我回答说：“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Windows 能做的有益的事情 Linux 都能做</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">Windows 下的某些功能确实是我们需要的，那么 Linux 的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比 Windows 的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX, 所以几乎所有商业的科学工程程序，比如 Matlab, Mathematica, AutoCAD, Candence的，Synopsys 的，Avant! 的……全都是先有 UNIX 的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给 Windows，因为 Windows 的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有 PSpice, UNIX 的 HSpice 要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。</p><p style="margin:0px 0px 20px;padding:0px;">但是 Windows 下有些东西在 Linux 下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows 的那个程序都要差很多，那么原因有两种可能性：</p><p style="margin:0px 0px 20px;padding:0px;">有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。</p><p style="margin:0px 0px 20px;padding:0px;">而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于 Gtk, Qt 的诞生，Linux 下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。当然也有一流的程序用 Gtk 和 Qt，比如 GVIM 就可以用 Gtk 作为图形界面，我还知道 Synopsys 一些程序用了 Qt。</p><p style="margin:0px 0px 20px;padding:0px;">我曾经也犯过这样的错误，从外表区分一切。结果优秀的 FVWM, lftp, Mutt, wget 都被我忽略过。当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友 :) 我第一次看到 FVWM 觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM 都说：“哇！真漂亮。”</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">有另一种完全不同的方式可以达到相同的目的，甚至更好</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">很多人很关心 Open Office, Star Office, AbiWord, ... 他们多么盼望有一天某一个 Linux 程序能够完全兼容的打开一个复杂的 doc 文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式。它一定会不断变化 doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc 文档时总是有某种问题，从而你必需购买 Microsoft Office 和 Windows。</p><p style="margin:0px 0px 20px;padding:0px;">你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是 Linux 或者其它类型的 UNIX，他们没有 Word 可用，怎么处理文档呢？这么多年没有一个像 Open Office 的程序出现，难道大家没有办法写文档吗？</p><p style="margin:0px 0px 20px;padding:0px;">显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的幻灯片，它们是什么做的？原来 UNIX 用户早就有非常方便的 troff, LaTeX, SGML 等东西可以处理文档，而且它们比起 Word 都要高明的多。Word 显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word 的程序，除非某些公司想抢微软的饭碗。</p><p style="margin:0px 0px 20px;padding:0px;">很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和 PowerPoint。我见过一个教授，他的 Windows 笔记本电脑上除了 PowerPoint 什么都没有。有一天演示的时候，他指着堆乱字符说：“对不起，这是一个公式……怎么每次都是这样……” 其实有比 PowerPoint 好几百倍的东西可以制造幻灯片，你可以用最简单的方法制造世界一流效果的论文和幻灯片。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开 Windows。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Windows 能做的那些没用的事情 Linux 永远做不好</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">电脑游戏</p><p style="margin:0px 0px 20px;padding:0px;">有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux 下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike[<a href="http://i.linuxtoy.org/docs/guide/ch06s05.html#ftn.id3052357" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">9</a>], 没有 Star Craft, ……</p><p style="margin:0px 0px 20px;padding:0px;">并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。</p><p style="margin:0px 0px 20px;padding:0px;">你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony Hawk's Pro Skaters 里滑板…… 但是 It's not real！你虽然有很高的“反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制 Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在 THPS 里作出一个 &quot;360 kickflip to hangten grind to fakie&quot;，但是你踩在自己的滑板上的时候还不会 ollie！</p><p style="margin:0px 0px 20px;padding:0px;">说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows + PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo 的 N64，Namco 的街机……每一个都比 Windows 游戏精彩，每一个都有如此高的3D性能，以至于 Pentium4, Itanium + GForce4 都无法与它们比美！</p><p style="margin:0px 0px 20px;padding:0px;">Linux 的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么 Linux 几乎没有游戏了吧？:)</p><p style="margin:0px 0px 20px;padding:0px;">“整理硬盘，优化系统”</p><p style="margin:0px 0px 20px;padding:0px;">这是一个非常有意思的话题，仅次于有关“病毒”的话题。相信很多 Windows 用户都有整理硬盘的经历。在很多 Windows 用户眼里，“硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。</p><p style="margin:0px 0px 20px;padding:0px;">我也曾经津津有味的看着 Norton Defrag 一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告：“100% 没有碎片。你的硬盘现在已经达到最佳状态。” 我现在才发觉我那时是多么的幼稚。</p><p style="margin:0px 0px 20px;padding:0px;">Linux 和 UNIX 用户似乎从来没有“整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX 的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！</p><p style="margin:0px 0px 20px;padding:0px;">Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux 用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS 高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以“越用越整齐 ”，“越用碎片越少”[<a href="http://i.linuxtoy.org/docs/guide/ch06s05.html#ftn.id3053196" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">10</a>]！你应该把文件大部分放在 Linux 的分区，而不是 Windows 分区，因为它比 Windows 分区可靠得多。</p><p style="margin:0px 0px 20px;padding:0px;">还有更滑稽的事情就是有很多“Norton System Doctor”，“Windows 优化大师”，“超级兔仔注册表魔法” 之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来“优化”它，而且为了得到优化，你需要付钱！这些问题 Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">IDE</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux 现在已经有一些 IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望 Linux 某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用 IDE？你说：“IDE 开发迅速，调试方便，适合大型程序……” 那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。</p><p style="margin:0px 0px 20px;padding:0px;">高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。</p><p style="margin:0px 0px 20px;padding:0px;">你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow 程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE 弄的，我还知道 Candence, Synopsys，Mentor 的高性能的图形界面 EDA 程序也都不是 IDE 写的。你信不信，微软的人在写 Windows 本身的时候也根本不用 IDE。微软内部程序员最喜欢的编辑器其实是 VIM，用 VIM 的微软程序员上次向乌干达的可怜儿童捐助了1000多美元，这是值得称赞的。</p><p style="margin:0px 0px 20px;padding:0px;">有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus 在内，没有一个人用 IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说 “GNU Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的 MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make 这样的自动工具调用 gcc 编译器完成编译工作的。甚至高级的 Windows 程序员也不用 IDE，他们可以从命令行调用 cl，nmake 来编译自己的程序。虽然这样的 Windows 程序员很少，但是他们却是最了解 Windows，最高明的 Windows 程序员。</p><p style="margin:0px 0px 20px;padding:0px;">为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX 的设计思想了。首先，一个 IDE 集成了编辑器，编译器，汇编器，调试器，跟踪器…… 这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上 as，调试器比不上 gdb, ddd, 跟踪器比不上 strace, ltrace, truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套 IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮…… 跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。</p><p style="margin:0px 0px 20px;padding:0px;">而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM 里可以调用 GNU make，make 可以调用 gcc, ld, ... make 的出错信息可以被 VIM 捕获，VIM 能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是 gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd 来显示各种数据结构之间的关系。你还可以在 Emacs 里调用 gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs 还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件…… 你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin 都可以在内部使用 VIM，这样就更方便了。实际上 make 在其它方面还能帮你很多忙，我的每一个比较大型的 LaTeX 文档都是用 make 维护的。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Linux 能干的高精尖的事情 Windows 都干不了</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC 机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC 机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows 的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows 机器是以“死机”著称的，我们怎么能放心？</p><p style="margin:0px 0px 20px;padding:0px;">所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows 的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过 Windows 版本的 Mathematica 和 Linux 的有什么区别吗？</p><p style="margin:0px 0px 20px;padding:0px;">IBM 制造的最大的并行计算机有 8000 多个处理器，Windows 不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。</p><p style="margin:0px 0px 20px;padding:0px;">《泰坦尼克号》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是 Linux 机器做的。</p><p style="margin:0px 0px 20px;padding:0px;">民航总局用来训练地情人员的虚拟现实训练设备，Windows 当然无能为力。那都是商业的 IRIX 机器。</p><p style="margin:0px 0px 20px;padding:0px;">UNIX 是最早支持 TCP/IP 网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997 年，微软的比尔盖茨还在扬言：“Internet 是没有前途的。” 微软的这个“远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。</p><p style="margin:0px 0px 20px;padding:0px;">其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Linux 干不了的有用的事情 Windows 照样干不了</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是 Linux 干不了的事情，Windows 肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux 必定是你的好伙伴。</p><p style="margin:0px 0px 20px;padding:0px;">不要把Linux和Xwindow掩盖起来！</p><p style="margin:0px 0px 20px;padding:0px;">不要把我们的用户当成傻瓜。</p><p style="margin:0px 0px 20px;padding:0px;">什么？你早就知道 Windows 是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。</p><p style="margin:0px 0px 20px;padding:0px;">“好了。你知道 Windows 是垃圾，你现在用什么？”</p><p style="margin:0px 0px 20px;padding:0px;">“Linux + Xwindow”</p><p style="margin:0px 0px 20px;padding:0px;">“那我问你，Xwindow 是什么样的？”</p><p style="margin:0px 0px 20px;padding:0px;">“不就是跟 Windows 差不多吗？只不过 'Start' 按钮比较方，而且上面不是一个 Windows 标志，而是一个脚丫子[<a href="http://i.linuxtoy.org/docs/guide/ch06s05.html#ftn.id3053473" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">11</a>]。点击一下居然还有很漂亮的中文菜单。我喜欢！”</p><p style="margin:0px 0px 20px;padding:0px;">“你知道什么是‘根窗口’吗？”</p><p style="margin:0px 0px 20px;padding:0px;">“不知道。从来没听说过呢？”</p><p style="margin:0px 0px 20px;padding:0px;">“根窗口就是遮盖整个屏幕的那个最大的窗口。”</p><p style="margin:0px 0px 20px;padding:0px;">“哪儿有什么窗口啊！我没有看到呢？”</p><p style="margin:0px 0px 20px;padding:0px;">你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对 Linux 和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow 都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和其它程序有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口的“class name”，“resource name”是什么东西。他们也不知道 .Xdefaults 是用来干什么的。特别是他们很多人都不知道 Xwindow 的字体是如何命名的，什么是 fontset，有了一个新的字体也不知道怎么安装。</p><p style="margin:0px 0px 20px;padding:0px;">他们被遮在 Linux 之上的一层一层的包装迷惑了，他们等待有图形界面的工具来帮助完成一切事情，他们认为 Linux 跟 Windows 一样，只是麻烦一点。他们知道 Linux 内核很好，但是他们感觉不到 Linux 和 Xwindow 在操作层面的天生的先进性，随后不久就把 Linux 完全删除掉了。你发现没有，要用户理解 UNIX 和 Xwindow 的操作层面的先进性，才是留住用户的最好办法。如果用户体会不到操作时的方便和高效，内核再好他们也不会理会。</p><p style="margin:0px 0px 20px;padding:0px;">但是用摹仿 Windows 的作法来吸引用户，永远会失败的。因为 Linux 如果摹仿 Windows 那一套低效率的方式，那么 Linux 的这套“低效率方式”永远比不上 Windows 的那一套“低效率方式”。那么用户就会说：“这个 Linux，没有一样比的上 Windows。”</p><p style="margin:0px 0px 20px;padding:0px;">Linux 天生就是继承了 UNIX 的高效的工作方式，为什么我们要把它掩盖起来？我们为什么只告诉用户 KDE 的菜单怎么用？我们为什么不能像早期的 Xwindow 书籍那样第一节就告诉用户什么是 X server, 什么是 X client，什么是 Window Manager, 什么是根窗口。第二章就告诉用户窗口有哪些属性，什么是 classname, resource name, hint，怎样使用 .Xdefaults, xrdb ……</p><p style="margin:0px 0px 20px;padding:0px;">在这里我又不得不说一下那些 Linux 的发行公司和写书的人，他们把 Linux 和 Xwindow 包装起来，却没有从基本上告诉用户 Xwindow 的工作原理。很多书籍讲授的层次就是在 Gnome, KDE 的菜单操作的层次，靠大量抓图来占篇幅，“繁荣”Linux 书籍市场。</p><p style="margin:0px 0px 20px;padding:0px;">现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这个“图形化”，“可视化” 的年代，你如果还在用 troff, LaTeX 写文档，你还在用 VIM 自己编辑 HTML，用 Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用 Xlib 写程序, 你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩 Clossal Cave 这样的字符模式冒险游戏，那你就是老古董。</p><p style="margin:0px 0px 20px;padding:0px;">其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是 Windows 的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows 那样的环境，你迟早会删掉自己的 Linux。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">GUI vs. CLI</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">做一个坚定不移的“两面派”</p><p style="margin:0px 0px 20px;padding:0px;">大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：</p><p style="margin:0px 0px 20px;padding:0px;">GUI派用户：“哇！我一看你这小子就是 CLI 的。要不然自己写什么 Makefile？用什么 Mutt？”</p><p style="margin:0px 0px 20px;padding:0px;">CLI派用户：“切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”</p><p style="margin:0px 0px 20px;padding:0px;">可怜的我：“555～～ 你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”</p><p style="margin:0px 0px 20px;padding:0px;">计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command LIne[<a href="http://i.linuxtoy.org/docs/guide/ch06s06.html#ftn.id3053662" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">12</a>]) 的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个 SecureCRT[<a href="http://i.linuxtoy.org/docs/guide/ch06s06.html#ftn.id3053670" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">13</a>]登录到 Sun 机器，然后用一个 vanilla vi 编辑程序，我建议他启动一个 GVIM 过来显示在 Exceed 上可以有语法加亮。但是他坚决反对，说：“高手不用X。你想想，要是我在一个很慢的网络连接怎么用 X？而且好多服务器没有装 X 程序。”</p><p style="margin:0px 0px 20px;padding:0px;">但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun 机器有全套 X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用 Windows，他后来打开了好几个 SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择 &quot;SSH2&quot;，然后点击“Connnect”。他还不断的夸SecureCRT是“网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT 本身就是个 GUI 啊，他其实没有明白 Xwindow 的好处。</p><p style="margin:0px 0px 20px;padding:0px;">你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM 很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用 Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用 VIM 编辑 LaTeX。我自己写 Makefile 来维护 LaTeX 文档。我有时用 mpg321 来放 mp3。我上BBS用的我自己写的 expect 脚本。 好了，CLI 派的朋友可以收我做盟友了 :)</p><p style="margin:0px 0px 20px;padding:0px;">你说我是 CLI 的老古董？我的 FVWM 被我配置为可以“手写操作”，我只要画一个&quot;r&quot;就可以启动 rxvt，我只要画一个 &quot;U&quot; 就可以启动 GVIM，…… 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla 浏览网页，…… GUI 派的现在好像认我做朋友了 :)</p><p style="margin:0px 0px 20px;padding:0px;">好了。CLI 派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:</p><p style="margin:0px 0px 20px;padding:0px;">Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 \ </p><p style="margin:0px 0px 20px;padding:0px;">-bg gold -fg midnightblue  \ </p><p style="margin:0px 0px 20px;padding:0px;">-fn &quot;-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*  </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你是不是现在又想把我逐出师门？</p><p style="margin:0px 0px 20px;padding:0px;">GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：</p>All (rxvt) MoveToDesk  <p style="margin:0px 0px 20px;padding:0px;">把我所有的 rxvt 移动到我现在工作的桌面。“这家伙，怎么这么快就叛变了！”</p><p style="margin:0px 0px 20px;padding:0px;">其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow 都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI 还是命令行的都可以互相协作。UNIX 和 X 是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI 的模糊界线吗？我就是坚定不移的“两面派”。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">UNIX 是简单的</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">“我相信简单就是最好，如果太复杂，我是不能理解的。” —Seymour Cray</p><p style="margin:0px 0px 20px;padding:0px;">很多第一次用 Linux 的人会惊奇的发现，Linux 的程序居然不用“安装”就可以运行，程序拷贝到随便那个目录都可以用，而不是一定要占用你第一个分区的空间。程序的设置只是一些简简单单的文本文件。你根本不需要什么“注册表修改器 ” 就可以改变系统的设置。这就叫做简单，但是简单就是美。虽然这只是 UNIX 简单性的一个肤浅的认识，你已经体会到了某些东西。</p><p style="margin:0px 0px 20px;padding:0px;">但是简单并不意味着功能弱，并不意味着落后。相反，简单意味着强大，意味着生命力。</p><p style="margin:0px 0px 20px;padding:0px;">我不会再继续阐述我理解到的“UNIX 的简单”，因为这个需要自己去体会。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">UNIX 是永恒的</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">有人说：“Plan9 会取代 UNIX，Mach 会取代 Linux 内核。”</p><p style="margin:0px 0px 20px;padding:0px;">但是你如果是一个深入体会了 UNIX 的人，你就会知道：UNIX 的思想是永恒的，不管时过境迁，Plan9 是否代替 UNIX，UNIX 的灵魂都会在 Plan9 身上现形！</p><p style="margin:0px 0px 20px;padding:0px;">我为同一个设备写过 Linux 内核和 Windows VxD 驱动程序。写 Linux 驱动程序时，我对 UNIX 设计的完美的一致性，远见性所折服。UNIX 用同样界面的 read(), write() 系统调用就可以对不同的对象：普通文件，设备文件，管道，管道文件，socket，…… 进行统一的读写操作。我跟本不需要写一个测试用的应用程序就可以对我的设备驱动进行测试，因为 cat, cp, dd, 它们也使用了同样的 read(), write()，设备和普通文件在应用程序眼里没有区别。在那个还没有 Smalltalk, 没有 C++ 的年代，UNIX 的设计者已经使用了所谓的 “面向对象方法”。对，C 语言也可以实现面向对象。</p><p style="margin:0px 0px 20px;padding:0px;">UNIX 的系统调用几十年都没有很大变化，这非但不是顽固，不进步的象征，反而是 UNIX 的远见卓识的体现！这就跟 TeX 程序几十年都不变的情况差不多。这些才是真正的永恒的 master piece! 你应该改变所有软件都必需从 0.1, 1.0, 1.1, 1.2, 2.0, ..., 3.0, 3.1, 95, 98, 2000, XP, ... 不断升级的想法。</p><p style="margin:0px 0px 20px;padding:0px;">Windows 就不同了，它在最开头只是一个 DOS 之上的图形包装而已。后来为了兼容以前的糟糕设计，不得不加上很多累赘。我写 VxD 驱动程序的时候就深有体会，Windows 95 程序对设备的操作只有用 DeviceIoControl，我不得不写了两个应用程序来对设备驱动进行测试。Windows 内核的不一致性和隐密性使我非常恼火。不过 Windows WDM 驱动程序现在也有了 ReadFile, WriteFile，…… 那说明什么？那说明 Windows 在向 UNIX 学习，或者有可能是某个 UNIX 设计人员在微软打了几天临工，顺手加了几个 UNIX 的东西进去。这样做是没有用的，Windows 从一开始就是非常糟糕的设计，它的历史的包袱太沉重了，缝缝补补有什么用？它只能永远的被 UNIX 甩在身后！</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">UNIX 是强大的</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">让聪明人干任何他们想干的事情。</p><p style="margin:0px 0px 20px;padding:0px;">UNIX 的一个特点就是非常高的灵活性，Xwindow 也具有这种灵活性。这种灵活性体现在哪里呢？</p><p style="margin:0px 0px 20px;padding:0px;">UNIX 的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如 GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个 .inputrc 文件，就可以把它变成 vi 的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt 来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误 ……</p><p style="margin:0px 0px 20px;padding:0px;">UNIX 程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。</p><p style="margin:0px 0px 20px;padding:0px;">我们再来看看 Xwindow。Xwindow 是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的 X 程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件 …… 比如有时我的 XFree86 上会出现四个不同机器上的 XTerm，两个不同机器上的 GVIM，…… 它们统一受本机上的 FVWM 指挥。</p><p style="margin:0px 0px 20px;padding:0px;">Xwindow 程序都具有很多很多命令行参数和 resource 参数。你可以随意的在命令行或者 .Xdefaults 文件设置所有的颜色，字体，尺寸…… 而且如果你用 xrdb 把 .Xdefaults 导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。</p><p style="margin:0px 0px 20px;padding:0px;">Xwindow 的窗口具有 Property, 也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property 的存在，使得 Xwindow 具有无比强大的生命力。X 的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了 ICCCM(客户程序间通信规范)，这个规范就是通过 property 定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得 Xwindow 可以具有某些 Windows 的特征，比如一个工具条程序可以告诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。 ”</p><p style="margin:0px 0px 20px;padding:0px;">一个强大的窗口管理程序比如 FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！一切窗口乖乖听话，FVWM 给予用户最大的尊重。</p><p style="margin:0px 0px 20px;padding:0px;">你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 &quot;Yes or No&quot;？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？</p><p style="margin:0px 0px 20px;padding:0px;">还有就是很多 Windows 程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">只有符号才能完全操纵计算机</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">我们来说说很多初学 Linux 的用户。虽然他们在用 Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux 有一天能“像Windows那样”。你说：“我鼠标一点，我菜单一拉，…… 就可以完成我的操作。” 但是我要告诉你：“Linux 从来没有摹仿 Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows 的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”</p><p style="margin:0px 0px 20px;padding:0px;">看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget, tin, ... 没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？</p><p style="margin:0px 0px 20px;padding:0px;">当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox, radio button, ... 到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，…… 一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed, Perl，你会觉得那才是真正的自动化啊。</p><p style="margin:0px 0px 20px;padding:0px;">鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">各个小程序的完美配合</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。</p><p style="margin:0px 0px 20px;padding:0px;">这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX 程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed, make, Perl, Emacs, vi, tin, Mutt, ... 它们是那么的具有一致性！你一旦学会了 sed 的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM, 你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了 VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin 等很多程序中。你甚至可以把 bash 设置为 vi 的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里“嵌入”另外一个程序。</p><p style="margin:0px 0px 20px;padding:0px;">在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在 Windows 下使用 Perl来进行一些自动工作。但是 Windows 的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制 telnet 到水木清华 BBS。</p><p style="margin:0px 0px 20px;padding:0px;">Windows 的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的Virtual Terminal, 自己的通讯代码。每一个 IDE 都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织…… 不能 DIY！</p><p style="margin:0px 0px 20px;padding:0px;">你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择…… 而用 Windows 程序，你得到的是大杂烩，就像你去买“品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows 程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！</p><p style="margin:0px 0px 20px;padding:0px;">而 UNIX 和 Xwindow 就是高档的“组装货 ”。比如我用 Mutt 的时候，我可以用 VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv 来显示附件里的图片，我可以用 lynx 把 HTML 附件转成文本嵌入窗口中，我也可以把 HTML 附件交给 Mozilla 图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它 PGP 程序。我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail 帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理…… 这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">学 UNIX 绝对不是浪费时间</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">有人告诉我：“你看我用 Windows 什么都不用学。而用 Linux，光是安装就花了我一个星期！”</p><p style="margin:0px 0px 20px;padding:0px;">首先，我要告诉你的是，你装 Linux 花了一个星期，不是因为 Linux 不好装，而是因为你已经习惯了 Windows，对 Linux 最初难以理解而已。你想一想你最初安装 Windows 的时候呢？你花了多少时间搞明白什么是硬盘分区？什么是盘符？什么是目录？你认为 Windows 就是那么容易可以学会的吗？虽然你觉得没花时间学，但是你以前在用别人的机器的时候已经耳濡目染，自然就了解了。而且由于你想要 Linux 和 Windows 并存于硬盘上，又增加了安装难度。而且你肯定没有得到有经验的 Linux 用户的帮助，否则他们会在 20 分种之内帮你搞定。一个星期也太夸张了 :P</p><p style="margin:0px 0px 20px;padding:0px;">如果一开始用的就是Linux就没有这个问题。你想想如果你没有用过 windows，你肯定会很习惯 /etc, /usr, /usr/local ,... 而不是 C:, D:, E:, ... 是不是？如果你只用过 Linux，你第一次用 windows 时恐怕也会问：“/bin 目录哪里去了啊？”</p><p style="margin:0px 0px 20px;padding:0px;">最重要的是，你用惯了的UNIX工具，它们可以伴随你一生，而不会那么容易变化或消失。你可以永远不用再换另外的工具了。除非那个工具比你这个好的太多，而且可以完全模拟你现在的工具。</p><p style="margin:0px 0px 20px;padding:0px;">我们实验室一个60多岁的老师，用vi, cc, make, ...都几十年了，他以前的经验绝对没有白费，而且教会了我们一批又一批的学生。vi 伴随着 UNIX 的最初发行而诞生，直到今天还是世界上头两号编辑器之一！有些人的 FVWM 配置文件已经用了 10 多年，现在完全不经修改还可以用。</p><p style="margin:0px 0px 20px;padding:0px;">看看 Windows 的工具，你从 Borland C++ 换到 VC, 就必需适应新的环境：菜单不同了，颜色不同了，按钮不同了，帮助信息不同了，热键不同了，编译器参数，调试器功能也不同了，…… 那个时候恐怕花要花你很多时间去适应。当你刚刚适应了 VC, 你又要换成 VJ, PowerBuilder, C++Builder, ...</p><p style="margin:0px 0px 20px;padding:0px;">很多windows程序员都是这样，开头在dos下用 Turbo C, 然后是 Borland C, VC, C++ Builder, ......不断追赶微软的潮流。而且微软的 SDK, MFC, .NET …… 什么都在不断变化，不断出问题，又不断的在修改…… Windows 程序员不得不买又厚又重的 Microsoft Press 的书籍，看了才一个月，又过时了。今天你才学会了写 VxD，明天你就必须用 WDM 了。你不得不注册 MSDN 才能赶上 Microsoft 的步伐。很多人说：“计算机是贵族的专业。” 这就是微软一手造成的。</p><p style="margin:0px 0px 20px;padding:0px;">这些东西才是没完没了的浪费大家的时间和金钱的。这是浪费生命！我们为什么不使用从诞生就那么一致和完美的 UNIX？你需要理解先进工具的设计理念。UNIX 的工具就像我们用的汽车，它的离合器，油门，刹车，方向盘，后视镜，永远都在同样的位置。用惯了的话，你对你的汽车的每一个部件都会了如指掌，甚至你自己都可以修车了。这难道不好吗？</p><p style="margin:0px 0px 20px;padding:0px;">有人说：“你说我们需要了解 UNIX，难道你要开车还必须了解汽车的结构吗？” 你去问问开车的司机，哪一个不了解汽车的结构的，那他的驾照就是混来的。你难道想要傻瓜型的“微软牌汽车”吗？我们来看看：</p><p style="margin:0px 0px 20px;padding:0px;">你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱。车上的防撞气囊不时会冒出来，说是为了你的安全。每开100英里要大修一次，每过一年要换一次引擎。附带的，你还必须换用由微软汽车公司指定的石油公司提供的新型号的机油。你的车出了问题，但是法律规定，你不准私自拆开你的汽车来修理，你必需到微软汽车公司指定的维修点去，需要付相当多的钱才能修好一个小毛病。</p><p style="margin:0px 0px 20px;padding:0px;">最可气的是，你每换一个型号的微软牌汽车，它的刹车和离合器都在不同的位置，你需要重新去考驾驶执照。如果这辆汽车在途中刹车失灵，你受了重伤，你也不能状告微软汽车公司，因为你买来汽车之后必须签一个合同，说 “由于微软牌汽车对你和家人造成的一切死伤，微软概不负责。”</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">怎样完全用 GNU/Linux 工作</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">说了这么多 Windows 的不好。我还没有告诉你我怎么用 Linux 处理有些必要的事情。</p><p style="margin:0px 0px 20px;padding:0px;">半年以前我由于中文老是配置不好，一直是双系统，不时需要重起到 Win2k 来处理汉字。后来我找到了 miniChinput, XSIM 和 SCIM 输入法。这下可以处理汉字了。而且 VIM 和 Emacs 对汉字支持越来越好。我的大部分文本是用 VIM 编辑的，包括程序，信件，网页，LaTeX 论文，MetaPost 绘图语言。</p><p style="margin:0px 0px 20px;padding:0px;">我不用 Word 这样的程序写论文，而是用 LaTeX，因为这是世界上效果最好，最方便的论文工具，是大多数学术杂志要求的格式。幻灯都是用 ConTeXt 做的，用起来很简单，而且效果非常漂亮。你可以看看我的TeX介绍。</p><p style="margin:0px 0px 20px;padding:0px;">至于绘图，你可以用很多可视化的工具，比如 xfig，dia。但是对于我来说，任何可视化的工具都不能完成某些任务，我需要一种可以精确描述图形的语言。我找到了MetaPost。它简单又好用，而且效果是世界一流的。我的插图，如果不是图像，都是 MetaPost 画出来的。</p><p style="margin:0px 0px 20px;padding:0px;">我曾经抱怨 mozilla-mail 经常突然消失，损坏我好几封快要完成的信件。后来我发现 mozilla 的邮件处理程序确实是不稳定的，功能又弱，有经验的 UNIX 用户都不用这样的程序。Mutt 是一个非常稳定可靠的 UNIX 邮件处理程序，而且功能非常强大。</p><p style="margin:0px 0px 20px;padding:0px;">我曾经为 Gnome 和 KDE 的不稳定而烦恼。现在我找到了非常强大的 FVWM。KDE，Gnome 也能和 FVWM 一起工作。虽然 Gnome 和 KDE 总体不稳定，但是某些部件程序还不错，很多 gtk, Qt 的程序也很不错，它们很多都是可以独立于这些桌面环境运行的。</p><p style="margin:0px 0px 20px;padding:0px;">Linux 有很多强大方便的工作方式是 Windows 没有的，或者有类似的东西，但是很差劲或者用起来不方便。比如 ssh 服务，rsync，cvs，expect ……</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">结论</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows 灌输在你脑子里的谬论，别再相信它们所谓的“新技术”，别再追赶 Windows，因为追赶 Windows ＝ 倒退。马克思有一个思想很重要，“新生事物并不一定是在最近出现的。” UNIX，Xwindow, TeX 虽然都比 Windows 先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。</p><p style="margin:0px 0px 20px;padding:0px;">消除学计算机很难的幻觉，勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt …… 这样强大的程序，勇敢的面对符号。不要再埋怨“Linux 为什么不能像 Windows 那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。你需要理解 UNIX 的工作方式，因为那是大多数科学家的工作方式。 Linux 可以成为你的好朋友，你需要认识它，了解它，信任它，才能完全的靠它来高效的工作。当然，在游戏机，手机，掌上电脑里，或者在用电脑来娱乐的时候，用一些“傻瓜软件”还是不错的 :)</p><p style="margin:0px 0px 20px;padding:0px;">我希望小学，中学的计算机老师能够提高自己的素质，在孩子们的启蒙教育中充分利用 Linux 神秘的特点，引起孩子们对数学，对符号的好奇心。诱导他们用计算机来解决世界上的有趣问题，而不要把教学的范围局限于计算机的操作和它自身的问题。</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">附录: 我用来处理日常事务的 Linux 程序</strong></p></li></ul><p style="margin:0px 0px 20px;padding:0px;">好了好了。我知道你发现自己应该转向 Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。</p><p style="margin:0px 0px 20px;padding:0px;">如果你只想做一个像我这样的普通用户，主要目的是用 Linux 来完成自己的任务，那就可以不用系统管理员或者网络管理员的标准来要求自己，因为当一个系统和网络管理员确实很辛苦。这里我对实验室的网管同学鞠一躬，谢谢你的指点和帮助 :) 不用把你的机器当成网络服务器，不用开放没有必要的服务，设置好 ssh, ftp 已经足够了。这样会省去了解很多没必要了解的东西的时间。不用过度考虑“安全”，因为 Linux 缺省已经很安全了。不过你有兴趣了解更多那也无妨。</p><p style="margin:0px 0px 20px;padding:0px;">下面给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如 Matlab, Mathematica, Maple, HSpice, Design Compiler, …… 还有其它物理上的，化学上的，生物上的 …… 都必然有 Linux 和 UNIX 的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，自由不等于免费。它们是经过很多人辛勤劳动的产物，是可靠的程序，它们物有所值。</p><p style="margin:0px 0px 20px;padding:0px;">下面列出我常用的一些 Linux 程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的，我不喜欢试用程序。我不是一个合格的网络管理员，我的服务器都只设置了我自己需要的功能，那样可以省去我很多麻烦 :P</p><p style="margin:0px 0px 20px;padding:0px;">Shell: bash。它结合了 csh 和 ksh 的优点，并且有 readline 功能，你可以随意绑定自己的键盘。</p><p style="margin:0px 0px 20px;padding:0px;">编辑器： VIM, Emacs。</p><p style="margin:0px 0px 20px;padding:0px;">程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk ...</p><p style="margin:0px 0px 20px;padding:0px;">论文，幻灯工具：LaTeX, ConTeXt</p><p style="margin:0px 0px 20px;padding:0px;">绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可以用 xfig, dia 来画一些流程图之类的图片。</p><p style="margin:0px 0px 20px;padding:0px;">图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert 程序可以转换图像格式，display 可以显示图片和简单编辑(缩放，换质量，转格式，简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可以用 Gimp, 它几乎和 Photoshop 差不多。</p><p style="margin:0px 0px 20px;padding:0px;">自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更新插图…… 全自动，而且不会重复劳动。</p><p style="margin:0px 0px 20px;padding:0px;">数值计算程序：SciLab。这个程序基本上可以代替 Matlab。</p><p style="margin:0px 0px 20px;padding:0px;">代数计算程序：MAXIMA。这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。它是用 Common Lisp 实现的。很多现在的符号计算程序比如 Maple 都从 MAXIMA 身上学到很多东西。它现在经过 DOE 批准以 GPL发行，永远是一个自由软件。</p><p style="margin:0px 0px 20px;padding:0px;">加密程序：GnuPG。我的 PGP 密钥就是它搞出来的。</p><p style="margin:0px 0px 20px;padding:0px;">打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, ...</p><p style="margin:0px 0px 20px;padding:0px;">虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。</p><p style="margin:0px 0px 20px;padding:0px;">ftp 服务器：proftpd, vsftpd。proftpd 功能很强，但是我只用了最简单的一种设置。</p><p style="margin:0px 0px 20px;padding:0px;">WWW 服务器：apache。(我一般没有开)</p><p style="margin:0px 0px 20px;padding:0px;">ftp 客户程序：lftp，ncftp。它们都是文本方式操作的，但是比起图形界面的方便的多。比如 lftp 几乎具有 bash 的所有方便功能，Tab 补全，bookmark, queue, 后台下载，镜像…… Linux 也有图形界面的 ftp 客户程序，但是大多不稳定，有很多问题。这就是很多人抱怨 Linux 不如 Windows 的一个小原因。还有很多人用 Wine 模拟 Windows 的 leapftp，其实 lftp 比 leapftp 好很多，你需要的只是适应一下。</p><p style="margin:0px 0px 20px;padding:0px;">自动下载工具：wget。它非常稳定，有一次我下载一个程序，用 IE 和 Mozilla 下载回来的文件都是坏的，最后还是 wget 可靠的传输了数据。用它甚至可以镜像整个网站，比起 WebZip 这样的 Windows 程序强多了，而且不会因为你不付钱就在下载回来的网页里强制插入广告。</p><p style="margin:0px 0px 20px;padding:0px;">虚拟终端：rxvt, xterm, gnome-terminal, mlterm, ...</p><p style="margin:0px 0px 20px;padding:0px;">X server: XFree86 [<a href="http://i.linuxtoy.org/docs/guide/ch06s13.html#ftn.id3054788" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">14</a>]</p><p style="margin:0px 0px 20px;padding:0px;">窗口管理器：FVWM。编译加入了 libstroke。</p><p style="margin:0px 0px 20px;padding:0px;">中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用 SCIM。</p><p style="margin:0px 0px 20px;padding:0px;">email 处理：Mutt + Postfix + fetchmail</p><p style="margin:0px 0px 20px;padding:0px;">看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv, djvu工具包和 netscape 插件。</p><p style="margin:0px 0px 20px;padding:0px;">看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。</p><p style="margin:0px 0px 20px;padding:0px;">看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE 好很多。</p><p style="margin:0px 0px 20px;padding:0px;">英汉字典：IBM智能词典，星际译王。</p><p style="margin:0px 0px 20px;padding:0px;">编辑网页：我用 VIM 直接写 HTML。你如果想要图形方式的可以用其它的比如 screem, BlueFish。</p><p style="margin:0px 0px 20px;padding:0px;">登录其它 UNIX, Linux 机器：openSSH, telnet。 我喜欢用 openSSH 把其它机器的 X 程序通过 ssh 加密的隧道传到我机器上显示。</p><p style="margin:0px 0px 20px;padding:0px;">登录 Windows2000 server 的 display service: rdesktop，...我有一天试了一下，不错。后来就没有用过了。</p><p style="margin:0px 0px 20px;padding:0px;">同步程序：rsync。我用 rsync 通过 ssh 来跟某些机器同步数据，或者做自己机器上不同目录间的同步。</p><p style="margin:0px 0px 20px;padding:0px;">上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo 机器人的程序)</p><p style="margin:0px 0px 20px;padding:0px;">QQ, ICQ: 我没有 QQ[<a href="http://i.linuxtoy.org/docs/guide/ch06s13.html#ftn.id3054855" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">15</a>] 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和很多其它的即时通信方式。ICQ 用户也可以用 Licq。</p><p style="margin:0px 0px 20px;padding:0px;">放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD, DVD, divx, wma, wmv ... 用 Windows 的同学都很羡慕我，说 Windows 要放这个需要大堆插件。 rm 最好还是用 realplayer 放，它也是免费的。</p><p style="margin:0px 0px 20px;padding:0px;">放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg)。mpg321 不如 xmms 管理音乐文件那么方便，但是有时我还是用 mpg321 放 mp3 作为背景音乐，因为懒得开一个xmms窗口 :)</p><p style="margin:0px 0px 20px;padding:0px;">游戏：我觉得 KDE 的那个 ksokoban(推箱子)，很好玩 :)</p><p style="margin:0px 0px 20px;padding:0px;">看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没有特殊的格式干脆就用文本吧，何必那么麻烦。以前很奇怪的是，通知里本来没有什么特殊的格式居然还要发doc附件的email。现在好了，我们系发通知都用文本，PDF，甚至图片了 :P</p><p style="margin:0px 0px 20px;padding:0px;">其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor Scheme, Scheme48, Scsh, kawa...这些程序只有 Doctor Scheme 有 Windows版本。还有很多幕后工作但是你一般不察觉的：xinetd, telnetd, sshd, crond, atd, lpd, ... 他们都比 Windows 的对应者强的多，或者根本没有对应者。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1031"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47be29" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">GTF: Great Teacher Friedman</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">0. 写小人书的老顽童<br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/>Dan Friedman 是 Indiana 大学的教授，Lisp (Scheme) 语言的主要研究者之一。他主要的著作《The Little Schemer》（前身叫《The Little Lisper》) 是程序语言界最具影响力的书籍之一。现在很多程序语言界的元老级人物，当年都是看这本“小人书”学会了 Lisp/Scheme，才决心进入这一领域。</p><p style="margin:0px 0px 20px;padding:0px;"></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd739fe0800ac&800.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p> <p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f010177qx&amp;url=http://s3.sinaimg.cn/orignal/5d90e82fgd73a011a1452" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd73a011a1452&800.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">他对程序语言的理解，可以说是世界的最高标准。很可惜的是，由于他个人的低调（你看这些书的名字，封面，页数，<a href="http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">价格</a>，以及里面哄小孩的话，就看得出来），他受到很多人的误解。很多人以为他只懂得 Scheme 这种“类型系统落后的语言”。有些人觉得他只顾自己玩，不求“上进”，觉得他的研究闭门造车，不“前沿”。我也误解过他，甚至在见面之前，根据这些书的封面，我断定他肯定是个年轻小伙。结果呢，第一次见到他的时候，他已经过了60岁大寿。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">程序语言的研究者们往往追逐一些“新概念”，却未能想到，很多这些新概念早在几十年前就被 Friedman 想到了。举个例子，Haskell 所用的 lazy evaluation 模型，最早就是他在 1976 年在与 David Wise 合写的论文“CONS should not Evaluate its Arguments”中提出来的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">虽然写了 The Little Schemer， 但 Friedman 的学识并不限于 Scheme。他不断地实验各种其它的语言设计，包括像 ML 一类的含有静态类型系统的函数式语言，逻辑式语言，面向对象语言，用于定理证明的语言等等。在每次的试验之后，他几乎都会写一本书，揭示这些语言最精要的部分。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">觉得 ML 比 Scheme 先进很多的人们应该看看 Friedman 这本书：The Little MLer：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f010177qx&amp;url=http://s11.sinaimg.cn/orignal/5d90e82fgd74f6ba6769a" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd74f6ba6769a&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">想要真正理解 Java 设计模式的人，可以看看这本：A Little Java, A Few Patterns:</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f010177qx&amp;url=http://s2.sinaimg.cn/orignal/5d90e82fg7bee5894fc61" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fg7bee5894fc61&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/></a></p><br/><br/><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这些东西的优点和弱点，仿佛在他心里都有数。他几乎总是指向正确的前进方向。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1. 你知道些什么<br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/>Dan Friedman 是 IU 的教授，程序语言界的元老之一，Lisp (Scheme) 语言的主要研究者之一，《The Little Schemer》（前身叫《The Little Lisper》)的作者。他对程序语言有非常深刻的理解。Haskell 所用的 lazy evaluation 模型，最早就是他在 1976 年在与 David Wise 合写的论文“CONS should not Evaluate its Arguments”中提出来的。他并不是我正式的导师，但他是这一生中教会我最多东西的人，所以我想写一些关于他的小故事。也许你能从中看出，一个真正的教育者是什么样子的。我来 IU 之前，一位师兄告诉我，Dan Friedman 就像指环王里的甘道夫 (Gandalf)，来了之后发现确实很像。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">第一次在办公室见到 Friedman 的时候，他对我说：“来，给我讲讲你知道些什么？”我自豪地说：“我在 Cornell 上过研究生的程序语言课，会用 ML 和 Haskell，看过 Paul Graham 的 On Lisp，Peter Norvig 的 Paradigms of Artificial Intelligence Programming, Richard Gabriel 的一些文章...”他看着我微笑：“不错，你已经有一定基础……”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这么几年以后，我才发现他善良的微笑里面，隐藏着难以启齿的秘密：当时的我是多么的幼稚！在他的这种循循善诱之下，我才逐渐的明白了，知识的深度是无止境的。<br/><br/><br/>2. 反向运行 <br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/>Dan Friedman 已经远远超过了退休年龄，仍然坚持教学。他的本科生程序语言课程 C311 是 IU 的“星级课程”。我最敬佩的，是他那孩子般的好奇心和探索精神。几乎每一年的 C311，他都会发明不同的东西来充实课程内容。有时候是一种新的逻辑编程语言 (类似 Prolog)，有时候是些小技巧 （比如把 Scheme 编译成 C 却不会堆栈溢出），等等……</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Friedman 研究一个东西的时候总是全身心的投入，执着的热爱。自从开始搞这个叫 miniKanren 的逻辑编程语言，Friedman 多了一句口头禅：“Does it run backwards?”（能反向运行吗？）因为逻辑式的语言（像Prolog）的程序，都是能“反向运行”的。普通程序语言写的程序，如果你给它一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">输入</strong>，它会给你一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">输出</strong>。但是逻辑式语言很特别，如果你给它一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">输出</strong>，它可以反过来运行，给你所有可能的<strong style="font-style:normal;font-weight:bold;font-size:100%;">输入</strong>。但是 Friedman 真的走火入魔了。不管别人在讲什么，经常最后都会被他问一句：“Does it run backwards?”让你哭笑不得。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Friedman 有一个本领域的人都知道的“弱点”——他不喜欢静态类型系统 (static type system)。其实 Scheme 专家们大部分都不喜欢静态类型系统。为此，他深受“类型专家”们的误解甚至鄙视，可是他都从容对待之。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">有一次在他的进阶课程 B621 上，他给我们出了一道题：用 Scheme 实现 ML 和 Haskell 所用的 <a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Hindley-Milner 类型系统</a>。这种类型系统的工作原理一般是，输入一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">程序</strong>，它经过对程序进行类型推导（type inference），输出一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">类型</strong>。如果程序里有类型错误，它就会报错。由于之前在 Cornell 用 ML 实现过这东西，再加上来到 IU 之后对抽象解释 (abstract interpretation) 的进一步理解，我很快做出了这个东西，而且比在 Cornell 的时候做的还要优雅。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">他知道我做出来了，很高兴的样子，让我给全班同学（也就8，9个人）讲我的做法。当我自豪的讲完，他问：“Does it run backwards? 如果我给它一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">类型</strong>，它能自动生成出符合这个类型的<strong style="font-style:normal;font-weight:bold;font-size:100%;">程序</strong>来吗？”我愣了，欲哭无泪啊，“不能……”他往沙发靠背上一躺，得意的笑了：“我的系统可以！哈哈！我当年写的那个类型系统比你这个还要短呢。我早就知道这些类型系统怎么做，可我就是不喜欢。哈哈哈哈……”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">前几天看了 Stephen Kleene 的一篇论文，才发现原来他说的这种由类型反向算出程序的做法叫做 “realizability”，是一个很深刻的理论，可以用来帮助自动证明数学定理。而我后来对类型系统的进一步研究显示，Hindley-Milner 类型系统确实有很多不必要的问题，才导致了他不喜欢。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">他就是这样一个老顽童。他喜欢先把你捧上天，再把你打下来，让你知道天外有天 :-)</p><p style="margin:0px 0px 20px;padding:0px;"><br/><br/>3. miniCoq <br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">你永远想象不到 Dan Friedman 的思想的极限在哪里。当你认为他是一个函数式语言专家的时候，他设计了 miniKanren，一种<strong style="font-style:normal;font-weight:bold;font-size:100%;">逻辑式</strong>编程语言 (logic programming language)，并且写出 《The Reasoned Schemer》，用于教授逻辑编程。当你认为他不懂类型系统的时候，他开始捣鼓最尖端的 <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Martin-Löf 类型理论</a>，并且开始设计机器证明系统。而他做这些，完全是出于自己的兴趣。他从来不在乎别人在这个方向已经做到了什么程度，却经常能出乎意料的简化别人的设计。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">有一次系里举办教授们的“闪电式演讲”(lightening talk)，每位教授只有5分钟时间上去介绍自己的研究。轮到 Friedman 的时候，他慢条斯理的走上去，说：“我不着急。我只有几句话要说。我不知道我能不能拖够5分钟……”大家都笑了。他接着说：“我现在最喜欢的东西是 <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Curry-Howard correspondence</a> 和定理证明。我觉得现在的机器证明系统太复杂了，比如 Coq 有 nnnnn 行代码。我想在 x 年之内，简化 Coq，得到一个 miniCoq……”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">miniCoq... 听到这个词全场都笑翻了。为什么呢？自己去联想 </p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/E___6725EN00SIGG.gif" type="image/gif" height="22" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="22"/></p><p style="margin:0px 0px 20px;padding:0px;"> 从此，“Dan Friedman 的 miniCoq” 成为了 IU 的程序语言学生茶余饭后的笑话。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">但是他没有吹牛，他总是说到做到。他已经写出一个简单的定理证明工具叫 JBob（迫于社会舆论压力，不能叫 miniCoq），而且正在写一本书叫 《The Little Prover》，用来教授最重要的定理证明思想。他开始在 C311 上给本科生教授这些内容。我看了那本书的初稿，获益至深，那是很多 Coq 的教材都不涉及的最精华的道理。它不仅教会我如何<strong style="font-style:normal;font-weight:bold;font-size:100%;">使用</strong>定理证明系统，而且教会了我如何<strong style="font-style:normal;font-weight:bold;font-size:100%;">设计</strong>一个定理证明系统。我对他说：“你总是有新的东西教给我们。每隔两年，我们就得重新上一次你的课！”<br/><br/><br/>4. C311<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">当我刚从 Cornell 转学到 IU 的时候，Dan Friedman 叫我去上他的研究生程序语言课 B521。我当时以自己在 Cornell 上过程序语言课程为由，想不去上他的课。Friedman 把我叫到他的办公室，让我在他旁边坐下来，和蔼的对我说：“王垠，我知道你在 Cornell 上过这种课。我也知道 Cornell 是比 IU 好很多的学校。可是每个老师的教学方法都是不一样的，你应该来上我的课。我和我的朋友们在这里做教授，不是因为喜欢这个学校，而是因为我们的家人和朋友都在这里。”后来由于跟 Amr Sabry（我现在的导师）的课程 B522 时间重合，他特别安排我坐在本科生的 C311 的课堂上，却拿研究生课程的学分。后来发现，这两门课的内容基本没有区别，只不过研究生的作业要多一些。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在第一堂课上，他说了一句让我记忆至今的话：“《The Little Schemer》和《Essentials of Programming Languages》是这门课的参考教材，但是我上课从来不讲我的书里的内容。”刚一开始，我就发现这门课跟我在 Cornell 学到的东西很不一样。虽然有些概念，比如 closure，CPS，我在 Cornell 都学过，在他的课堂上，我却看到这些概念完全不同的一面，以至于我觉得其实我之前完全不懂这些概念！这是因为在 Cornell 学到这些东西的时候只是用来应付作业，而在 Friedman 的课上，我利用它们来完成有实际意义的目标，所以才真正的体会到这些概念的内涵和价值。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">一个例子就是课程进入到没几个星期的时候，我们开始写解释器来执行简单的 Scheme 程序。然后我们把这个解释器进行 CPS 变换，引入全局变量作为&quot;寄存器&quot; (register)，把 CPS 产生的 continuation 转换成数据结构（也就是堆栈）。最后我们得到的是一个抽象机 (abstract machine)，而这在本质上相当于一个真实机器里的中央处理器（CPU）或者虚拟机（比如 JVM）。所以我们其实从无到有，“发明”了 CPU！从这里，我才真正的理解到寄存器，堆栈等的本质，以及我们为什么需要它们。我才真正的明白了，冯诺依曼体系构架为什么要设计成这个样子。后来他让我们去看一篇他的好朋友 Olivier Danvy 的论文，讲述如何从各种不同的解释器经过 CPS 变换得出不同种类的抽象机模型。这是我第一次感觉到程序语言的理论对于现实世界的巨大威力，也让我理解到，<strong style="font-style:normal;font-weight:bold;font-size:100%;">机器并不是计算的本质</strong>。机器可以用任何可行的技术实现，比如集成电路，激光，分子，DNA…… 但是无论用什么作为机器的材料，我们所要表达的语义，也就是计算的本质，却是不变的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">而这些还不是我那届 C311 全部的内容。后半学期，我们开始学习 miniKanren，一种他自己设计的用于教学的逻辑式语言 (logic programming language)。这个语言类似 Prolog，但是它把 Prolog 的很多缺点给去掉了，而且变得更加容易理解。教材是免费送给我们的《The Reasoned Schemer》。在书的最后，两页纸的篇幅，就是整个 miniKanren 语言的实现！我学得比较快，后来就开始捣鼓这个实现，把有些部分重新设计了一下，然后加入了一些我想要的功能。这样的教学，给了我设计逻辑式语言的能力，而不只是停留于一个使用者。这是学习 Prolog 不可能做到的事情，因为 Prolog 实现的复杂性，会让初学者无从下手，只能停留在使用者的阶段。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我很幸运当初听了他的话，去上了这门课，否则我就不会是今天的我。<br/><br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">5. 独立思维<br/><br/>Dan Friedman 是一个不随波逐流，有独立思想的人。他的眼里容不下过于复杂的东西，他喜欢把一个东西简化到容得进几行程序，把相关的问 题理解得非常清楚。他的书是一种独特的“问答式”的结构，很像孔夫子或者苏格拉底的讲学方式。他的教学方式也非常独特。这在本科生课程 C311 里已经有一些表现，但是在研究生的课程 B621 里，才全部的显示出来。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我写过的最满意的一个程序，自动 <a href="http://en.wikipedia.org/wiki/Continuation-passing_style" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">CPS 变换</a>，就是在 C311 产生的。在 C311 的作业里，Friedman 经常加入一些“智力题”（brain teaser），做出来了可以加分。因为我已经有一定基础，所以我有精力来做那些智力题。开头那些题还不是很难，直到开始学 CPS 的时候，出现了这么一道：“请写出一个叫 CPSer 的程序，它的作用是自动的把 Scheme 程序转换成 CPS 形式。”那次作业的其它题目都是要求<strong style="font-style:normal;font-weight:bold;font-size:100%;">手动</strong>把程序变成 CPS 形式，这道智力题却要求一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">自动</strong>的——用一个程序来转换另一个程序。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我觉得很有意思。如果能写出一个自动的 CPS 转换程序，那我岂不是可以用它完成所有其它的题目了！所以我就开始捣鼓这个东西，最初的想法其实就是“模拟”一个手动转换的过程。然后我发现这真是个怪物，就那么几十行程序，不是这里不对劲，就是那里不对劲。这里按下去一个 bug，那里又冒出来一个，从来没见过这么麻烦的东西。我就跟它死磕了，废寝忘食几乎一星期。经常走进死胡同，就只有重新开始，不知道推翻重来了多少次。到快要交作业的时候，我把它给弄出来了。最后我用它生成了所有其它的答案，产生的 CPS 代码跟手工转换出来的看不出任何区别。当然我这次我又得了满分（因为每次都做智力题，我的分数总是在100以上）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">作业发下来那天下课后，我跟 Friedman 一起走回 Lindley Hall（IU 计算机系的楼）。半路上他问我：“这次的 brain teaser 做了没有。”我说：“做了。这是个好东西啊，帮我把其它作业都做出来了。”他有点吃惊，又有点将信将疑的样子：“你确信你做对了？”我说：“不确信它是完全正确，但是转换后的作业程序全都跟手工做的一样。”走回办公室之后，他给了我一篇30多页的论文 “Representing control: a study of the CPS transformation”，作者是 Olivier Danvy 和 Andrzej Filinski。然后我才了解到，这是这个方向最厉害的两个人。正是这篇论文，解决了这个悬而不决十多年的难题。而自动的 CPS 转换，可以被用于实现高效的函数式语言编译器。Princeton 的 Andrew Appel 教授写了一本书叫《Compiling with Continuations》，就是专门讲这个问题的。而 Amr Sabry（我现在的导师）当年的博士论文就是一个比 CPS 还要简单的变换（叫做 <a href="http://en.wikipedia.org/wiki/Administrative_normal_form" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">ANF</a>）。凭这个东西，他几乎灭掉了这整个 CPS 领域，并且拿到了终身教授职位。Friedman 啊，把这样一个问题作为“智力题”，真有你的！我开玩笑地对他说：“我保证，我不会把这个程序开源，不然你以后的 C311 学生们就可以拿来作弊了 :-)”回到家，我开始看那篇 Danvy 和 Filinski 的论文。这篇 1991 年的论文的想法，是从 1975 年一篇 Gordon Plotkin 的论文的基础上，经过一系列繁琐的推导得出来的。而它最后的结果，几乎跟我的程序一模一样，只不过我的程序可以处理更加复杂的 Scheme，而不只是 lambda calculus。我之前完全不知道 Plotkin 的做法，就直接得到了最新的结果。这是我第一次认识到自己头脑的威力。<br/><br/>第二个学期，当我去上 Friedman 的进阶课程 B621 的时候，他给我们出了同样的题目。两个星期下来，没有其它人真正的做对了。最后他对全班同学说：“现在请王垠给大家讲一下他的做法。你们要听仔细了哦。这个程序价值100美元！”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">而这还不是 B621 的全部，每一个星期，Friedman 会在黑板上写下一道很难的题目。他不让你看书或者看论文。他有时甚至不告诉你题目里相关概念的名字，或者给它们起个新名字，让你想查都查不到。他要求你完 全靠自己把这些难题解出来，下一个星期的时候在黑板上给其它同学讲解。他没有明确的评分标准，让你感觉完全没有成绩的压力。这些题目包括很难的一些问题， 比如 <a href="http://en.wikipedia.org/wiki/Church_encoding" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">church numeral</a> 的前驱 (predecessor)。这个问题，当年是 Stephen Kleene 花了三个月冥思苦想才做出来的。不幸的是，我早就学到了 Kleene 的做法，造成了思维的定势，所以这个训练当时对我来说失去了意义。而我们班上却有一个数学系的同学，出人意料的在一个星期之内做出了一个比 Kleene 还要简单的方法。其它的问题包括从 lambda calculus 到 <a href="http://en.wikipedia.org/wiki/SKI_combinator_calculus" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">SKI combinator</a> 的编译器，逻辑式（可逆）CPS 变换，实现 <a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Hindley-Milner</a> 类型系统，等等。我发现，就算自认为明白了的东西，经过一番思索，认识居然还可以更进一步。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当然，重新发明东西并不会给我带来论文发表，但是它却给我带来了更重要的东西，这就是独立的思考能力。一旦一个东西被你“想”出来，而不是从别人那里 “学”过来，那么你就知道这个想法是如何产生的。这比起直接学会这个想法要有用很多，因为你知道这里面所有的细节和犯过的错误。而最重要的，其实是由此得 到的<strong style="font-style:normal;font-weight:bold;font-size:100%;">直觉</strong>。如果直接去看别人的书或者论文，你就很难得到这种直觉，因为一般人写论文都会把直觉埋藏在一堆符号公式之下，让你看不到背后的真实想法。如果得到了直觉，下一次遇到类似的问题，你就有可能很快的利用已有的直觉来解决新的问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">而这一切都已经发生在我身上。比如，在听说 ANF 之后，我没有看 Amr Sabry 的论文，只把原来的 CPSer 程序改了一点点，就得到了 ANF 变换，整个过程只花了十几分钟。而在 R. Kent Dybvig 的编译器课程上，我利用 CPS 变换里面的直觉，改造和合并了 Dybvig 提供的编译器框架的好几个 pass，使得它们变得比原来短小好几倍，而且生成很不错的代码。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在我仍然是这样，喜欢故意重新发明一些东西，探索不止一个领域。这让我获得了直觉，不再受别人思想的限制，节省了看论文的时间，而且多了一些乐趣。一个问题，当我相信自己能想得出来，一般都能解决。虽然我经常不把我埋头做出来的东西放在心上，把它们叫做“重新发明”(reinvention)，但是出乎意料的是，最近我发现这里面其实很是隐藏了一些真正的发明。我准备慢慢把其中一些想法发掘整理出来，发表成论文，或者做成产品。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">俗话说，“授人以鱼，不如授人以渔。”就是这个道理吧。Dan Friedman，谢谢你教会我钓鱼。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1037"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c03c" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是程序语言的研究</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">介绍一下我的研究方向吧。我的领域叫“程序语言”(programming languages)。世界上只有很少数人真正在做这方面的研究，所以很少有人理解这个专业是干什么的，就连我身边的朋友同学也几乎不知道。但是其实这是一个非常重要的领域。在我看来，它就是计算机科学的精髓所在。<br/><br/>
程序语言的研究不是针对某一种语言，而是针对所有语言。它是一种基础性，普适性的研究。它专注于理解程序语言的本质，设计更为简单，合理和高效的语言，而不只是改进已有的语言。<br/><br/>
从广义一点的角度来说，程序语言研究的东西其实是计算的本质。计算都需要基于某种“计算模型”，而程序语言就是用来描述这种计算模型的符号系统，所以程序语言跟计算的本质非常接近。其实，早期的程序语言研究直接导致了计算机科学的诞生。它的历史可以追溯到20世纪30年代甚至更早。最早的时候产生这个想法是因为人们想给数学提供一个可靠的“基础”(foundation of mathematics)。之前对数学的描述都使用一些稀奇古怪的数学记号，夹杂一些自然语言。这是非常脆弱，不可靠，而且难于理解的。不小心看错一个句子，你可能就会接受一个错误的证明，或者无法验证一个正确的证明。而且数学记号的设计也缺乏一致性，导致学习的障碍。所以有人就提出了这样的想法，想让数学的描述和证明完全的机械化，这样人就可以用机器，而不是用自己的脑子去验证证明的正确性。这就像现在大家都用计算器来做算术一样，基本不需要动脑筋。所以这个领域最早就是致力于帮助数学家偷懒的。<br/><br/>
我每天都使用的一个概念叫 lambda calculus。它是一种非常简单的符号系统，可是几乎所有程序语言的所有构造，都可以用它来表示。通常当程序语言的构造被 lambda calculus 表示之后，问题就会变得清晰明了很多，甚至迎刃而解。这个东西是在1930年代由逻辑学家 Alonzo Church 发明的。Church 有很多学生，包括通常被认为是计算机科学鼻祖的图灵(Alan Turing)。当时还有其他一些重要的人物，比如 Church 的另外一个学生 Stephen Kleene。Lambda calculus 以及由它衍生出来的一些新的系统（比如 Martin-Löf 类型理论），构成了当今直觉主义逻辑 (intuitionistic logic) 的主要内容。<br/><br/>
有人也许会觉得这种基础性的研究没有应用前景。确实，有些基础性的研究是扯淡，是不能应用的，但是其它一些却有很大的应用前景。举一个切身体会的例子就是我在 Google 实习的时候给他们做的一个东西。他们需要为 Python 做一个可以像 Eclipse 一样能够精确跳转到定义的工具。因为 Python 是动态类型的，所以这个工作的难度比起 Java 这样的静态类型语言来说要大很多。我的 manager (Steve) 本来打算让我去拿一个开源的软件比如 PyDev 来改一改，可是我发现这些软件都不能正确的跳转到定义，所以我打算从头设计一个静态分析系统。当我提出这个想法的时候，Steve 非常的担心。他觉得这是在12个星期的实习期内不可能完成的事情，因为通常来说这种东西需要一个团队好几年的工作。比如 Steve 告诉我，Google 的 JS Compiler（开源之后叫做 closure compiler)，花费了他们一个小组四年时间才完成，光是处理符号表的代码就有9000多行。但是我没有被他吓倒，我知道自己受到过什么样的训练。所以我在一个周末的时间内设计实现了这个系统的原型，让他相信我是有能力做出这个系统的。在12个星期之内，我完全的实现了这个系统。最后整个系统的代码，包括空行和注释在内，才仅仅4000行。其中处理符号表的部分只有600行（9000的15分之1）。而在这之前，我对 Python 语言的了解几乎为零。能做出这个东西是因为我对程序语言的一种本质性的理解，让我能够迅速的看清 Python 的语义，从而实现一个针对 Python 的抽象解释器 (abstract interpreter)，在某种程度上说也就是实现了 Python 语言。我也可以为任何一个其它的语言做同样的事情。现在，Google 每天都用这个工具处理它所有的 Python 代码，生成可精确跳转到定义的索引。<br/><br/>
这个例子并不是程序语言研究最高精尖的应用。很多研究程序语言的人也进行一些程序验证和机器定理证明研究。简而言之，程序验证就是用机械化的逻辑来证明程序的正确性。这种证明与通常的单元测试(unit test)很不一样，在于它能 100% 的保证程序的正确，而测试的方法几乎总是会漏掉一些情况。这种研究在关键性的领域很有应用，比如航空航天，核电，武器，芯片设计等等。因为没有任何人愿意因为程序出错而坠毁一架飞机或者发射一颗核弹，所以他们愿意花很大的工夫保证控制程序的绝对正确。Intel的浮点运算bug当年导致好几亿美元的经济损失，所以在那以后很多芯片厂商都开始使用定理证明程序（比如 ACL2）来彻底的消灭某些芯片模块里可能存在的bug。这些定理证明程序里面的关键部分，就是程序语言的一些重要理论。当然必须指出，程序的很多性质是不可证明的，所以很多时候测试还是有必要的。<br/><br/>
有些定理证明程序（比如 Coq，Isabelle, HOL）已经开始被应用于数学的证明。最著名的例子就是四色定理，被人重新用 Coq 证明了一次，从而完全的确保这个定理的正确性。有些数学家也开始使用这些工具。比如 Thomas Hales，他当年证明了开普勒猜想 (Kepler conjecture)，提交了一份 250 页的论文（外加 3GB 的程序，数据和结果）给数学界的权威期刊 Annals of Mathematics。经过一个由 12 位数学家组成的评委四年的验证工作，没能完全确定证明的正确性。虽然论文最后还是发表了，但是被评委们添了一行注释：“我们只有 99% 的把握相信他的证明。”这使得这个证明几乎完去了数学的意义。所以 Thomas Hales 很恼火，最后决定用一种机器定理证明程序来重新证明开普勒猜想。<br/><br/>
其它重要的应用真是举不胜举。其实这个领域对我最重要的吸引力是它的思维方式。它让我透过现象看到本质，从而能够从根本上解决问题。至于我自己，故事还真多。在教授们的指导下，我做过各种各样有趣的东西，从逻辑式语言(logic programming)到编译器。现在我比较感兴趣的东西是类型系统 (type system)，supercompilation，自动定理证明和并行语言设计。我也利用程序语言的知识来思索其它领域的东西，或者做别的好玩的东西。具体的我以后再慢慢介绍。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="1041"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c562c" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是启发</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我喜欢用“启发”这个词。比如我经常会对人说：“你启发了我。”然而听到这话的人有时候不明白我的意思，自以为高我一筹，于是顿显傲气。其实我用“启发”这个词，是有深刻含义的。“启发”的意思并不等于“我没有你懂得多”或者“你比我聪明”，而是一个很含糊的词。</p><p style="margin:0px 0px 20px;padding:0px;">如果 A 受到了 B 启发，有几种可能性：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">B 做了一件很聪明的事情，所以从正面启发了 A</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">B 做了一件很笨的事情，所以从反面启发了 A</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">B 做了一件不好也不坏的事情，但是这个事情正好触发了 A 事先想的一个问题的答案</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">这就是为什么“美丽心灵”里的 John Nash 在酒吧看到一个美女之后，解决了一个重要的问题，然后对她说“谢谢”，让人家都莫名其妙。</p><p style="margin:0px 0px 20px;padding:0px;">Richard Feynman 也提到：“在你的头脑里随时准备好12个问题。每当发生一件有趣的事情，就检查一下其中是否有问题可以由此获得线索。久而久之，人们就会称你为天才。”</p><p style="margin:0px 0px 20px;padding:0px;">孔夫子所谓的“三人行必有我师”，也就是这个意思吧。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1045"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47becb" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">知识分子的傲慢与偏见</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　　经历了这么多的事情，见过了这么多不同种类的人，我一直在想，知识分子心里存在的傲慢与偏见是从哪里来，到哪里去的。现在我也许找到了一些线索。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">傲慢</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　先说说傲慢产生和消亡的规律吧。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 当我们懂得很少的时候，我们是不会傲慢的，因为自己根本没有值得傲慢的东西。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 当我们懂得了一些东西之后，傲慢就产生了，因为我们喜欢把自己的某种专业知识看得过于重要，比如对程序员来说就是编程能力。很多人以自己会用某种语言，或者会用某种操作系统为豪。我们会把这些语言或者操作系统的名字放在自己的名字前面，就好像自己的招牌，比如称自己是 Schemer, Linuxer,等等。你会发现，当我们这样做的时候，自己一般都没有能力设计自己的程序语言或者操作系统，所以我们才会把希望寄托于别人创造的东西。所以其实傲慢的人总是在某种东西之“下”，他们并没有思想的独立。</p><p style="margin:0px 0px 20px;padding:0px;">　　3. 当我们学到了深入本质的知识，就会发现其实以前认为很了不起的东西，其实也就那么回事。曾经自己只是“用户”的东西，现在自己成了“创造者”。而最后你发现，这些创造其实根本不是来自于我们自身的“天才”，而是从自然界的各种现象里面“抄”来的。自然界是如此的伟大，相比之下，我们可以说根本没有自己的创造，我们其实一直都只是在学习和摸索。一个人的知识再多，也不可能理解整个宇宙。这个世界上还有许许多多值得学习，值得探索的东西，自己其实一点都不了解。于是我们的心再度敞开，迎接新的知识，好奇心增加了，傲慢也随之消退了。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">偏见</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　偏见也有差不多的故事。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 当我们不懂什么东西的时候。偏见是不可能产生的，因为我们对事物了解如此之少，我们根本没有自己的判断。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 当我们学到了一定的程度，偏见就产生了。我们总是会忽然觉得某种东西是“救世主”，从而迅速的成为它的崇拜者。“精通”某种东西（比如程序语言）的人，往往觉得不会用这东西的人都低他一等，经常会为这些东西孰好孰坏争论得面红耳赤。他们会跟使用同样东西的人扎堆，结成“阵营”。阵营之间互相竞争和攻击，“敌人”的东西就算是好的我们也要嗤之以鼻，“自己人”的东西就算不好的我们也要把它捧起来。</p><p style="margin:0px 0px 20px;padding:0px;">　　3. 当我们得到了深入的知识，就会发现这些东西全都有自己的缺点，没有一个是完美的。所以我们就不再很关心这些东西之间的“宗教斗争”一类的事情，会觉得这些争论很无聊。与其支持某个东西，反对另外的，还不如把精力节省下来，自己做一个比它们都好的。所以当一个人有了强大的创造能力，偏见也就随之消退了。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以你看到了，傲慢和偏见都有一个从无到有，然后逐渐消亡的规律。我很清楚的看到，这些已经发生在了我的身上。虽然我经常在博客提到 Scheme，其实我自己并不是 Scheme 的“支持者”。我知道它有什么毛病。我从来不称自己是“Schemer”，我也很少关心 Scheme 的“标准”，比如 R5RS, R6RS。我使用 Scheme 的原因是因为我需要一种语言来描述我想说的东西（比如解释器），而 Scheme 是现有的最简单的可以说明这些问题的语言。实际上我不是任何语言的支持者，管它是 C++， Java, Python, Scheme,Common Lisp 还是 Haskell, OCaml, Clojure, ... 它们对我来说都是差不多的。它们的“社区”经常喜欢把缺点说成是优点，把“对手”的优点都嗤之以鼻，把某种概念说成是包治百病的灵丹妙药。这个现象是普遍存在的，就算是 Haskell 和 OCaml 的社区也不例外。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以我脑子里一直在构想的，其实是一种新的语言。它没有任何的宗教成分，并且不断的完善自己，消灭自己的弱点，简化自己的设计，最终成为世界上唯一需要存在的“终极语言”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="1050"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c55e5" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">什么是“脚本语言”</a></h2><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人都会用一些“脚本语言”（scripting language），却很少有人真正的知道到底什么是脚本语言。很多人用 shell 写一些“脚本”来完成日常的任务，用 Perl 或者 sed 来处理一些文本文件，很多公司用“脚本”来跑它们的“build”（叫做 build script）。那么，到底什么是“脚本语言”与“非脚本语言”的区别呢？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实“脚本语言”与“非脚本语言”并没有语义上，或者执行方式上的区别。它们的区别只在于它们设计的初衷：脚本语言的设计，往往是作为一种临时的“补丁”。它的设计者并没有考虑把它作为一种“通用程序语言”，没有考虑用它构建大型的软件。这些设计者往往没有经过系统的训练，有些甚至连最基本的程序语言概念都没搞清楚。相反，“非脚本”的通用程序语言，往往由经过严格训练的专家甚至一个小组的专家设计，它们从一开头就考虑到了“通用性”，以及在大型工程中的可靠性和可扩展性。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">首先我们来看看“脚本”这个概念是如何产生的。使用 Unix 系统的人都会敲入一些命令，而命令貌似都是“一次性”或者“可抛弃”的。然而不久，人们就发现这些命令其实并不是那么的“一次性”，自己其实一直在重复的敲入类似的命令，所以有人就发明了“脚本”这东西。它的设计初衷是“批量式”的执行命令，你在一个文件里把命令都写进去，然后执行这个文件。可是不久人们就发现，这些命令行其实可以用更加聪明的方法构造，比如定义一些变量，或者根据系统类型的不同执行不同的命令。于是，人们为这脚本语言加入了变量，条件语句，数组，等等构造。“脚本语言”就这样产生了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然而人们却没有发现，其实他们根本就不需要脚本语言。因为脚本语言里面的这些结构，在任何一种“严肃”的程序语言（比如 Java，Scheme）里面，早就已经存在了，而且设计得更加完善。所以脚本语言往往是在重新发明轮子，甚至连轮子都设计不好。早期脚本语言的“优势”，也许只在于它不需要事先“编译”，它“调用程序”的时候，貌似可以少打几个字。脚本语言对于 C 这样的语言，也许有一定的价值。然而，如果跟 Scheme 或者 Java 这样的语言来比，这个优势就非常不明显了。比如，你完全可以想一个自动的办法，写了 Java 代码之后，先调用 Java 编译器，然后调用 JVM，最后删掉 class 文件。或者你可以选择一种有解释执行方式的“严肃语言”，比如 Scheme。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人把 Scheme 误称为“脚本语言”，就是因为它像脚本语言一样可以解释执行，然而 Scheme 其实是比 C 和 Java 还要“严肃”的语言。Scheme 从一开头就被设计为一种“通用程序语言”，而不是用来进行某种单一简单的任务。Scheme 的设计者比Java 的设计者造诣更加深厚，所以他们对 Java 的一些设计错误看得非常清楚。像 Chez Scheme 这样的编译器，其实早就可以把 Scheme 编译成高效的机器代码。实际上，很多 Scheme 解释器也会进行一定程度的“编译”，有些编译为字节码，有些编译为机器代码，然后再执行。所以在这种情况下，通常人们所谓的“编译性语言”与“解释性语言”，几乎没有本质上的区别，因为你看到的“解释器”，不过是自动的先编译再执行。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">跟 Java 或者 Scheme 这样的语言截然不同，“脚本语言”往往意味着异常拙劣的设计，它的设计初衷往往是目光短浅的。这些语言里面充满了历史遗留下来的各种临时的 hack，几乎没有“原则”可言。Unix 的 shell（比如 bash，csh，……），一般都是这样的语言。Java 的设计也有很多问题，但也跟“脚本语言”有天壤之别。然而，在当今现实的工程项目中，脚本语言却占据了它们不该占有的地位。例如很多公司使用 shell 脚本来处理整个软件的“build”过程或者测试过程，其实是相当错误的决定。因为一旦这种 shell 脚本日益扩展，就变得非常难以控制。经常出现一些莫名其妙的问题，却很难找到问题的所在。Linux 使用 shell 脚本来管理很多启动项目，系统配置等等，其实也是一个历史遗留错误。所以，不要因为看到 Linux 用那么多 shell 脚本就认为 shell 语言是什么好东西。</p><p style="margin:0px 0px 20px;padding:0px;">如果你在 shell 脚本里使用通常的程序设计技巧，比如函数等，那么写几百行的脚本还不至于到达不可收拾的地步。可是我发现，很多人头脑里清晰的程序设计原则，一遇到“写脚本”这样的任务就完全崩溃了似的，他们仿佛认为写脚本就是应该“松散”一些。很多平时写非常聪明的程序的人，到了需要处理“系统管理”任务的时候，就开始写一些 shell 脚本，或者 Perl 脚本。他们写这些脚本的时候，往往完全的忘记了程序设计的基本原则，例如“模块化”，“抽象”等等。他们大量的使用“环境变量”一类的东西来传递信息，他们忘记了使用函数，他们到处打一些临时性的补丁，只求当时不出问题就好。到后来，他们开始耗费大量的时间来处理脚本带来的麻烦，却始终没有发现问题的罪魁祸首，其实是他们错误的认为自己需要“脚本语言”，然后认为写脚本的时候就是应该随便一点。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以我认为脚本语言是一个祸害，它几乎永远是错误的决定。我们应该尽一切可能避免使用脚本语言。在没有办法的情况下（比如老板要求），也应该在脚本里面尽可能的使用通常的程序设计原则。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1057"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c011" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">一个中国人的反省</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">        北京被大水淹了。在为逝去的生命感到惋惜之余，是全体中国人该反省的时候了。一次次的人为灾难之后，有人指责政府部门，指责各种外部因素。可是我觉得应该指责的，其实是我们自己。是的，我们，每一个中国人，不管是在国内还是在海外，不管你觉得自己多么的聪明，正直和高尚。<br/>
正视这个现实吧中国人，我们正在沦为世界上最低劣的民族之一。国内的中国人活着是靠运气，国外的中国人则是苟且偷生。问问我们自己，我们还有自己的尊严，自己的原则，自己的道德，自己的智慧吗？我们还有什么值得世界上的人尊敬吗？如果给我们一个机会重新建立一个国家，我们有足够的智慧和力量让它的发展轨迹跟现在的这个国家不一样吗？这个国家存在的腐败和各种不合理现象，难道是少数人就可以造成的结果吗？如果大多数人都知道什么是对的，并且坚持自己认为正确的原则，这个国家难道会因为少数人的败坏而变成这个样子吗？所以其实这里的原因在于我们每个人自己，在于我们每个人心里存在的卑劣，愚昧和怯懦，在于我们从小受到的教育。<br/>
对，这些人里面当然也包括我，不然的话我不会察觉到自己心里存在的这些问题。所以下文提到“中国人”的时候，当然也包括我自己。我检查自己，我对照别人，我发现问题，我改进自己。这些问题，可比我研究的学术问题全都要高难很多。在某种程度上，它们比所有的科学问题都要困难和重要。现在我就我们中国人存在的一些问题提出一些粗略的看法吧。这些问题是如此之复杂，恐怕难以一次就圆满的表达。我以后肯定还会有所修改。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对自己不负责<br/></strong>其实，社会的问题也可以用理性的，类似计算机科学的思维来看待。社会就像一个机器，这个机器里每一个系统和元件必须协调，这个系统才能正常的工作。否则这个机器就会越来越慢，浪费越来越多的资源，以至于到最后崩溃掉。所以虽然我对社会了解不多，我对这些现象的分析，比起社会学家可能还会有些独到之处。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;"><br/></strong>对自己负责，简而言之就是“自己的事情自己做”，也就是独立。可惜的是这个看似小儿科的问题，却是中国人（包括我）身上最缺乏的基本意识。然而这个问题却很难察觉到，以至于你对它视而不见。从计算机的角度来看，“对自己负责”就是“Unix哲学”的第一条原则：每个程序只做一件事情，并且把它做好。可是我发现，很多中国人其实连自己最起码的事情都做不好。<br/>
中国人有很强的依赖性。自己的事情自己不管理好，到头来却怪到别人头上，或者拖累别人。中国人有句俗话，“在家靠父母，出门靠朋友。”在家依赖父母，其实是这整个问题的根源，这个我稍后再说。出门靠朋友，则会带来更大程度上的社会问题。这是怎么回事呢？就拿我在美国见到过的一些中国同学作为例子吧。</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">暑假的时候，有些人去外地做实习生，为了省房租而早早的停掉自己的租房合同。但是美国的出租房一般都不提供家具的，那已经买好的家具怎么办呢？很多人的做法就是放到同学家里。有一次我到一个同学住的地方，发现堆满了的家具，坐的地方都快没有了。后来一问才发现是别人放在那里的，那些家具堆在他们那里已经一个夏天了。其实花很少的钱（一个月几十美元的样子）就能在美国租到短期的可以存放家具的仓库。本来做实习生工资就高，不缺那几个钱，却总想把那几十块钱省下来买点别的什么东西。同学不好意思说“不”，那就堆到他家去吧！</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">室友从外面回来。外面下着大雨。进门就发现自己房间的窗户没有关，东西被淋湿了。气呼呼的到我房间对我说：“下雨了你怎么也不帮我关一下窗户！”老实说，为了保持温度和节省能源，我房间的窗户夏天和冬天是几乎从来就不开的。我在忙自己的事情，以至于我根本都没觉察到天上在下雨。自己的窗户没关，东西被淋湿了，值得同情，可是这样把责任推到别人身上，还责怪别人，我还是着实吃了一惊。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">以前的室友，毕业在美国找到了工作，买好了机票回国探亲，然后满脸堆笑的对我说：“师兄，我要回国一个月，时间安排紧张。回来美国之后可能就不回学校，直接去公司的地方了。以后我退房子的时候，我的家具恐怕还要麻烦师兄帮我卖一下。”自己的家具自己不安排时间处理，让别人帮他卖。一卧室加一客厅的家具，我很清楚卖掉它们要花费多少时间和精力。这种事情也曾经发生在另一个同学身上，有人从国内打了一个电话来，说房子租约要到期了，要他找人去帮他搬家。搬家这样的事情，居然可以不亲自出面，完全由别人代理。这样的朋友，谁遇到谁倒霉。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">说了这么多别人的事，我也自我批评一下吧。我曾经让几个同学来帮我一起搬家。虽然我不像上面那个人那样居然不亲自出面，可是后来发现搬家这种事还真不应该麻烦同学。十几美元一个小时，就能在学校的网络上找到愿意帮忙搬家的美国同学，还提供卡车。请两个身强力壮的美国人搬完全部家具可能也花不到两个小时。同胞同学的体力和友谊，难道那点钱都不值，难道就是可以随便利用的？这个道理，我到后来才明白。</p></li></ol><br/>
这也许就是国外的中国留学生所谓的“出门靠朋友”。可是这种错误真的很难认识到，因为这种对自己不负责的态度，在很多国人的身上已经根深蒂固。从小就依赖父母帮自己做这做那的，将来就把这些事情都推到朋友身上。在国外遇到的中国人，很多是这个样子，以至于我都怕了。很多美国人不愿意跟中国人交往，可能也是这个原因。在这方面，我不得不承认美国人做得比我们好很多。做生活的强者，自己的事情自己处理，自己的麻烦自己解决。<br/>
这并不是给我们一个理由不去帮助那些真正需要帮助的人，而是说帮助别人不应该超越一定的界限。每个人都应该尽力处理自己应该做的那些事情，而不应该把这些力所能及的事情推给别人。这是很简单的道理，如果每个人都来麻烦你去做他们自己的事情，你自己的事情怎么办？拿去麻烦别人？这种扯不清的关系，就是为什么中国人的社会存在各种各样的矛盾和问题。父母和子女的关系，亲戚朋友的关系，婆媳关系，生意关系…… 里面存在的问题，很多时候都是因为这种依赖性所产生的。期望别人来做自己的事情，而且认为这是别人应该做的。这也在很大程度上导致了社会的冷漠和缺乏互相帮助。你好心帮助一个需要帮助的人，可是这个人到后来就賴上你了，什么事都来找你，所以你后来就懒得帮助别人了。<br/>
所以不管是做朋友还是做父母，都要注意人与人之间的界限。跨越这个界限去料理别人的事情，不但不会帮助别人，而且会助长他们的依赖情绪，以至于破坏朋友和亲子关系。所以对于别人“个人界限”内的事情，我们只需要给他们指出方向，让他们自己去做就行了。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">对社会不负责</strong><br/>
一个人不仅要负担起对自己的责任，还要负担起社会的一小部分责任。中国社会最模糊最扯不清楚的，就是人与人之间的责任界限。责任分明，白底黑字写清楚，往往被很多人认为是“不哥们”，“不亲热”。可是分不清责任，出了问题互相踢皮球，却是中国人社会生活里的大问题。想一想动车事故，想一想北京的水灾，想一想最近南航飞机着火…… 看见了吗？有谁主动的承认，并且承担起自己的那份责任呢？这是政府的问题，各种机构的问题，也是全体中国人的问题。<br/>
问一问自己，当发生了跟自己有关事情的时候，你有主动承担自己的那份责任吗，还是喜欢把责任一股脑推给别人？我不得不承认，我自己就做过这样的事情。勇于承担责任，貌似是每个中国人的弱点。“大丈夫一人做事一人当”，可是现在中国人有几个可以做到呢？街坊邻居，亲戚朋友，生意伙伴之间，经常是有福同享，有难却不同当。有了问题就翻脸不认人，推卸责任，颠倒黑白的行为，在我们自己的生活中难道不常见吗？自己都做不到主动承担责任，出了大事故，恐怕也就不能都怨政府和公司。因为这些官员也是中国人，跟我们一样的，不负责的人。为什么中国有这么多的贪官和腐败分子？他们身上的邪恶，其实来自于我们每一个中国人。如果我们不能在从小的教育里学会这些做人的基本原则，中国人恐怕就只有永远落后下去，甚至成为亡国奴。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">吝啬和贪婪</strong><br/>
中国人常说“付出总有回报”，事实却不是这样。究其原因，很多时候来自于我们的吝啬。我们没有明白，每一次收获，其实都需要我们付出。我们总是想收获却不想付出，这显然是不可能的。吝啬和贪婪，却几乎总是相互依存的。在某种意义上它们其实是同义词。<br/>
中国人太爱“省钱”了。“勤俭节约”是中国的光荣传统，但是很多人没有意识到，这其实很多时候是吝啬和贪婪披着“节约”的大衣。中国人对于钱的“多少”，貌似有非常扭曲的概念，付出再少的钱他也觉得太多。以至于中国人在国外为了省钱，会做出各种各样奇怪的事情。其实博士生一个月工资足够住好吃好，可是还是很多人把自己搞得很狼狈。用的吃的玩的，全都买最次的，不知道为什么。很多人为了省钱，手机是合伙开的“family plan”。收账算钱的那些麻烦事，还真是不值得省下来那点钱。吝啬，在很多时候造成了中国人对别人的依赖。本来花一点钱就可以得到专业的服务，却总是为了省钱去麻烦自己的朋友。友情都被这吝啬的性格给磨灭了。<br/>
国内这种情况就更厉害了。之前我回国一趟，发现真的很难适应现在国内的环境，花钱买不到等值的东西和服务。所有的商人和服务提供者都吝啬到家了，舍不得一点点钱来改善自己的服务环境，本来该有的设施和设备都没有。快递送货用摩托车，东西都往地上掉。卖电器的公司送货的卡车居然是敞篷的，一下雨电器都被淋湿了。为了一点钱就以次充好甚至掺假，毒牛奶，健美猪…… 旅游景点什么东西都卖天价，人造景点泛滥成灾，以至于现在国内所谓旅游，基本上都是扯淡。这些怪事，恐怕是几十年前也没有见过的。中国人道德的空前败坏，跟这种吝啬是非常有关系的。<br/>
吝啬和贪婪到了政府部门，就变成了腐败。各种道路房屋建筑设施都用劣质材料，导致人为灾难不断。省下来的钱呢？吃回扣放腰包里了。然而在对这些腐败分子深恶痛绝的同时，我们却没有发现，其实这一切罪恶的根源，都是出自我们自己的吝啬和贪婪。中国人真的应该学会什么叫做“付出”了。<br/>
付出并不代表着吃亏。如果每个人都懂得付出，每个人都会得到回报。罗素在他的《懒散颂》里面提到，喜欢存钱的人其实是最坏的坏蛋，因为他阻断了经济的流通。如果他把这些钱借给政府，那么政府就会拿这些钱去发动战争，所以还不如把钱拿出来开请客。这样大家开心，自己也开心，还可以给社会创造就业机会。饭店，酒厂，农民…… 一系列的人都会得到好处。这样社会经济发展了，自己也会得到回报。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">华而不实</strong><br/>
然而在能显示自己“身份”和“格调”的方面，中国人却是非常大方的。中国的“奢侈品”卖的之贵，可能世界上都罕见。而这些所谓的“奢侈品”，很多不过是美国摆在超市货架上的日常用品，一点也不贵。中国人装修房子都讲求格调，喜欢搞一些看似高档的地砖，木地板，却不重视产品的安全。很多装修材料都含有对人体有害的物质，其实还不如最便宜的材料。<br/>
有一次在朋友家暂住。洗澡的时候，浴室的玻璃门卡住了。我使劲一拉把手，结果整个玻璃门轰的一声全碎掉了，扎伤手脚多处。其实美国人的浴室根本没有这些看似豪华的装饰。一般就是一个浴缸加一个浴帘，浴室里除了镜子和灯泡根本没有玻璃。美国人缺那点钱装修吗？可是他们更加智慧，他们对每一种细微的东西都心里有数，确实的知道什么东西是好的，什么是不好的。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">卫生习惯不好</strong><br/>
我不得不说，美国的生活让我改变了对“卫生”概念。同学们随便就坐在教学楼的地板上，外面的草地上。很多美国人买了水果，洗也不洗就吃了，自来水烧也不烧就喝了，也不怕生病。美国旅馆的毛巾，如果你想当天换掉，就扔在地板上，否则就挂起来。中国人都觉得好奇怪，这么不卫生的习惯！可是这却是很卫生的，因为美国到处都干干净净的，甚至外面的人行道可能比自己家里的地板还干净。<br/>
相比之下，中国人的卫生习惯其实是很差的。大部分人都会注意个人卫生，可是却不注意环境卫生。脏东西只要不在自己家里那就行了。很多人在外面随地乱扔垃圾，造成环境污染。有的人更绝，认为只要不进 入嘴里的东西，就不用弄干净。所以他们的家里少数地方很干净，其他大部分的地方都很脏。可是这样到头来却让自己很累，因为你总是要“小心”。总是要去想，哪些地方是干净的，哪些是不干净的。要小心不要把不干净的东西放到干净的地方。这种不好的卫生习惯根深蒂固，以至于很多中国人到了美国，仍然不相信自来水可以直接喝，仍然买瓶装纯净水。<br/>
这其实也是对社会不负责的表现，而且这种社会责任感的缺乏，已经造成了自然环境的严重破坏。生活在这样的地方，就算你再有钱又如何舒服得起来？就算你家产上亿，住在花园豪宅，出门开法拉利，你总要下车接触到这个城市，这个国家吧？你总要呼吸空气，总要喝水吧？所以很大程度上在中国当亿万富翁，其实还不如在美国当普通老百姓。<br/>
但是美国不管怎么干净，也不是自己的国家。我多希望每个中国人都有公德心一点，这样自己也会活得开心一些。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">缺乏理性思想</strong><br/>
以上只是美国人聪明的一个很小的表现。如果我现在说美国是比中国设计更好的国家，恐怕一群“爱国者”就会开始唾骂我。这就像如果我说某种操作系统或者程序语言比另外一种好的时候一样。我们没有意识到，这些操作系统，程序语言，以至于国家，其实都是“东西”。它们的地位是低于人的，并不是被膜拜起来的神物。它们是需要科学和理性来设计和改造的，而不是什么什么“主义”就可以搞得好的。<br/>
对于美国社会生活设计上的科学性，我却是有很深体会的。大的地方（比如法律）另外再说，可是你没有想到，美国人这种科学和理性设计，其实已经到了最简单的电源插座。比如，下图就是中美两国的常见的家居电源插座的对比。左边是中国的标准插座，右边是美国的。<br/><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/5d90e82fgc5d9342d0d2f&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></p>
 <br/>
你看出来什么区别了吗？美国每个插座都是一样的三孔插座：平行的两个孔，大的是火线，小的是零线，第三个孔是地线。这样的设计的好处是，两脚的插头也可以插进任何一个插孔里，而不只是能插进专门的两脚插孔。中国的三脚插孔会让两脚插头都插不进去，而三脚的插头却是非常少见的。它们一般只存在于有金属外壳的电器，比如微波炉，洗衣机，等等。仔细观察你的卧室，有多少电器是需要三脚插座的呢？可是这种设计，却被放到了整个家居，包括卧室里。所以虽然看到好像有两个插座，其实只有一个可用的。而中国的两脚插座，却是不安全的。因为电灯的插座一般是两脚的，而中国插座的火线和零线大小是一样的，可以互换，所以你不能确保暴露的电极是在零线上。而美国电灯的插头却是一大一小两个插脚，所以火线和零线的插脚不可能插进错误的插孔里。<br/>
这个小东西算是美国人的设计更合理一些，但是中国的设计并不是完全的失败。美国的这种巧妙的设计无处不在，我也许将来会搜集汇总一些。相比之下，中国的建设有另外一些却是明显的设计失误，却完全没有人注意到，比如：
<ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">城市乱建。街道的大小，方向，路口的位置，交通灯的设计，…… 这些在很多地方都是设计糟糕的。这导致了交通拥挤，车祸频繁。在美国，开车是最简单不过的事情，因为道路几乎全都是简单的田字格，交通规则也很简单。中国的道路却是弯来弯去，总是喜欢造“N环路”。交通规则改来改去还改不对。如果你说古老的市区这没法改变，那么新建的城区为什么还要搞得这么复杂？我父母所在的城市，新建城区的某个路口居然有六个岔道，而且设计的无比复杂，这岛那岛的，你都搞不清楚什么时候该走什么时候不该走。我母亲居然还自豪的跟我说，这是请清华大学设计的。这六岔路口的交通灯都是十几个，然而在另外两条大马路的交汇处，却一个交通灯都没有！</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">残疾人设施是摆设。中国的人行道都有盲道，有些地方有残疾人的轮椅通道，可是这些残疾人设施，真的起作用吗？在南方某旅游城市，我很惊讶的看到残疾人的轮椅通道的入口处有一个20厘米高的坎，轮椅根本不可能上得去。所以其实这些都是做面子的，并不是设身处地的想要为残疾人服务的。因为上头说“每个人行道必须有盲道”，所以下面的人不得不照办。所以你就发现这些“<a href="http://ued.taobao.com/blog/2007/08/16/dumm_drift/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">有中国特色的盲道设计</a>”。而美国呢？美国根本就没有盲道，因为他们有更好的保障措施，比如导盲犬。而轮椅的通道，真是四通八达，没有任何一个轮椅通道是不能用的。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">北京无下水道，南方无暖气。中国人不懂得防患于未然，总是认为“北方雨水少”，“南方气温高”。以至于北京好多街道连下水道都没有，而南方的城市冬天都没有供暖设施。所以北京才会出现现在的水灾。而南方的人到了冬天在屋里都得穿棉袄，非常不舒服，而且导致各种健康问题比如风湿。相比之下，美国的每家每户全都有供暖设施，冬天在屋内就跟夏天差不多。这些供暖设施很贵吗？其实根本就不是很贵，能耗不多，工作原理也很简单（基本就是个炉子加个鼓风机）。所以这只是一个理念问题：与其花更多的钱去治疗各种由于寒冷造成的疾病，还不如早一点花钱装上供暖设施。</p></li></ol><br/>
还有很多这样的例子，我以后想起来可能还会补充。这些“设计失误”的背后，当然也免不了腐败的原因。但是我不觉得如果消灭了腐败现象，中国就会得到合理的建设。我们需要真正的懂得城市规划，建筑设计，各种办实事的专家，他们必须接受专业的训练。这是一个科学和设计的问题，而不是一个道德或者主义的问题。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">个人素质</strong><br/>
中国人总是以自己的“五千年文明”而自豪。可是我们的“文明”在哪里？人们见面基本的礼貌和尊重，社会的各种秩序，这些方面我都看不到有什么文明，甚至比起几十年前更加落后了。<br/>
在美国，人们见面都会主动的问好。虽然并不是每个人都真的关心你，可是他们总会说一句“How are you？”在音乐厅，在电影院或者别的什么地方，坐到你旁边的人，入座时总是会友好的打个招呼，甚至开始自我介绍。如果他们在超市的过道上，需要从你身边一米以内的地方经过，他们会对你友好的说声“excuse me”。如果两个车子同时到达没有红绿灯的路口，往往有人会友好的挥手，示意另外一个车先走。行人总是受尊重的，开车的人一般都会让行人先走。而行人在过马路是也是尊重开车的人的，他们会走人行道过街，而不是随意乱穿，也不会在路口闯红灯。<br/>
久而久之，你就发现这些礼节成为了社会不可缺少的一部分，以至于回到国内会非常的不适应。人们擦肩而过时，那种急匆匆，怒目相向的表情。在超市推着车子一声不响的从你身边擦过，甚至碰到你都不说声“对不起”。当你在等行人的绿灯的时候，旁边的人一窝蜂的横穿马路。还有插队，挤公车，抢车道…… 这些事情，以前在国内似乎习以为常的，现在却难以接受了。我不得不说，美国人在很大程度上教育了在美国的中国人。至少，他们变得更加有礼貌，更加懂得尊重他人。<br/>
但是这不只是一个礼貌的问题，这是一个社会能否有效运转的科学问题。如果中国的开车族都不抢车道，行人都不乱穿马路，那么交通拥挤的现象就能在很大程度上得到改善，交通事故也会减少。如果人们都自觉排队，那么服务业就会更加高效。<br/>
这些确实是不容易实现的。因为整个社会都是这个样子，如果只有少数的人做到这些，几乎是不起作用的。但是每个人都从自己做起，却是唯一有效的办法，虽然这在某些时候会给自己带来不便。比如你不去挤公车你可能就坐不上公车，但是如果我们自己不尽力这样去做，这个社会就会越来越混乱，效率就会越来越低，对别人对自己都没有好处。这些素质都需要从小培养的，所以在做好自己的同时，我们还需要教育下一代，让他们也有礼貌，遵守秩序。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">空洞的法律</strong><br/>
中国其实不是一个法治的国家。中国的立法人员，恐怕并不懂得什么是法律和法制。如果把理想的法律看成是一个程序，那么我们运行这个程序，就可以知道谁对谁错，就知道该如何判决。美国的法律在很大程度上就是这样的设计。虽然美国法律也有漏洞，但是在一般情况下都是非常有效的。每一个细小的概念，都有精确的定义，以至于到了需要判断的问题，很容易就解决了。<br/>
美国人做事都是按部就班的，因为法律说了算，法律要求有这些手续，那就一个都不能漏掉。所以你感觉是法律在统治这个国家，而不是人，这就叫做“法治”。这样能在很大程度上减少腐败和滥用职权的情况。虽然美国还是有这种问题，但是比中国好很多。中国的法律，却是一个充满了“未定义变量”和各种语法错误的程序，根本没法编译，更不要说执行。所以到了需要判决的时候，就几乎都是人说了算，因为那些未定义的变量和混淆的逻辑，可以被任意的解释！在中国，经常是有理也说不清，因为很多人根本不知道什么叫做“理”。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">错误的含蓄</strong><br/>
世界上最可怕的事情不是犯错误，而是明知道错了却不能指出。其实很多中国人都知道什么是对的，什么是错的。可是为什么我们总是让错误的东西横行，而睁一只眼闭一只眼呢？为什么可以挺身而出的人越来越少，以至于没有呢？为什么有时候出现一群人见死不救，任凭凶手横行的情况呢？<br/>
因为我们没有意识到，其实很多人跟我们一样，知道什么是对的。每一个人都以为自己是唯一一个“坚持真理”的人，这就造成了一群聪明人被一只狗耍的团团转的局面。其实只要大家有那么一点点勇气，说出真话，那么很多问题都解决了。为什么那么“含蓄”呢？<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">自高自大，不思进取</strong><br/>
在多国同学一起的时候，你往往会发现某些中国同学是里面最自大，最喜欢宣扬自己“五千年文化”以及各种“中央政策”的。我们太陶醉于自己也说不清楚到底有多长时间的“文化”了。鲁迅说“都写着吃人”，这还真的有可能。自大的很大部分原因来源于自卑。真的有实力有底气的人，都懒的跟人争论一些问题。我在想，我们什么时候才能放下自己的架子，去学习真正好的东西。世界上有很多的民族都值得我们学习，有的拥有先进的科技，有的拥有淳朴的文化，快乐的人民。他们也有自己的问题，但是我们只需要学习他们好的地方。而我们由于自己的自大，总是守着那些自己扯来扯去也说不明白的空洞大道理，不去了解新的事物。<br/>
一些中国人很喜欢谈论别国的缺点，却看不到它们的优点。比如我的一个朋友总是对我说，美国多么多么的坏，CIA的黑幕等等，却对中国的种种怪事一个字不提。美国对于别的国家的人很有可能是不利的，可是它对于自己国家的人，却是非常不错的。光是骂美国，却不把自己国家建设好，一点用也没有。说实话，在美国，生命被看得重要很多，至少他们的法律会强迫他们这样做。扯皮的时候，只要你提到你的健康受到威胁，商家立马就怕了。因为它知道这种有关健康或者人命的官司打下来，自己可吃不消。前几天我们的公寓楼9楼墙面上的一块石板不知道怎么掉下去了。现场立马就被封锁了起来，楼的周围全部被拦起来，所有通向靠近墙面的出口都被关闭了，不准人靠近以防发生意外。请了专业人员开着大吊车来检查整栋大楼的墙面，并且开始进行必要的修缮保障措施。什么时候在中国掉下去一个石板也能这么大动静，我们就安心了。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">“数字”教育</strong><br/>
说了这么多问题，其实归根结底在于我们的教育。中国的教育是严重失职的。如果说在培养科学家方面，中国教育可以刚好及格的话，那么在人的道德品质方面，中国教育就几乎是零蛋。而道德品质，却是教育最重要的作用。我们可以不要科学，但是最基本的人品：诚实，守信，互相尊重…… 却是不可缺少的。有些小国并没有很高的科学技术，它们没有发射过卫星，没有核武器，没有出色的数学家，物理学家，计算机科学家，但是它们却拥有淳朴，热情，快乐，互相关心的人民。世界人民尊敬他们，而不是那些拥有前进科技的冷酷的人们。<br/>
中国的教育，在这些方面却是起到相反的作用的。因为中国教育注重于“数字”，一切都是以分数，名次为准。而人品，却不是可以用数字来衡量的。这导致了学生只对数字敏感，忙着显示自己的“实力”，而忽视了最基本的人品。<br/>
中国教育里存在的很多“强迫性”，也在很大程度上造成了中国人爱做表面文章的现象。老师要我们做这事（比如擦窗户），那当然让老师满意，让老师觉得我们在“干活”就行，至于实质上有没有用，我们不管。所以你就看到许多个小孩擦同一块本来就干净的玻璃的情况。教育者应该让被教育者知道一件事情的重要性，从而让他们可以自觉的这样做，在需要的时候才这样做，而不只是强迫他们这样做。否则，他们就会想出各种办法做表面文章，不做实事。<br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">从自己做起</strong><br/>
说了这么多，头都有点晕了。写这么多没有人看，看了没有实际行动，又有什么用呢？其实我并不期望我能改变任何人的思想。这些就算是给我自己的一些警钟吧。一切从自己做起，就从现在做起。</div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1066"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47a02c" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">清华梦的粉碎——写给清华大学的退学申请</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">2005-09-27 </p><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">清华梦的诞生</strong></p><p style="margin:0px 0px 20px;padding:0px;">小时候，妈妈给我一个梦。她指着一个大哥哥的照片对我说，这是爸爸的学生，他考上了清华大学，他是我们中学的骄傲。长大后，你也要进入清华大学读书，为我们家争光。我不知道清华是什么样子，但是我知道爱迪生和牛顿的故事。清华，大概就是可以把我造就成他们这种人的地方吧。我幼小的脑海里就想象出我能在清华做的事情……我的脸上浮现出笑容。我说我要实现这个“清华梦”。这就是清华梦的诞生。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">小小科学家</strong></p><p style="margin:0px 0px 20px;padding:0px;">我相信每个人在小时候都跟我差不多，对这个世界充满了好奇。</p><p style="margin:0px 0px 20px;padding:0px;">鲁迅有他的百草园，我也有我自己的&quot;实验田&quot;。如果说小时候的鲁迅是一个艺术家，那么小时候的我就是一个科学家。这么说可能有人要说我口气太大，张口闭口就是这家那家。然而在我的字典里，&quot;艺术家&quot;和&quot;科学家&quot;并不是什么了不起的人，它们只是贴在人内心的一个标签。如果一个小孩专注于内心对世界的感觉，那么他就是一个艺术家。而我不是。我的大部分兴趣是在了解世界是怎样运转，甚至不惜代价。也许大部分男孩子都是这样。</p><p style="margin:0px 0px 20px;padding:0px;">我小时候住在父母执教的中学里。两间平房，门口有一小块地，妈妈在里面种了一些菜。我们一家三口虽然穷，但是过着宁静舒适的生活。我们在这个地方一直住到上初中的时候。这些房屋记录着一个年幼的科学家的探索和实验，直到它们被夷为平地。</p><p style="margin:0px 0px 20px;padding:0px;">妈妈拒绝让我养猫狗，她说凡是会拉屎的都不养---除了我。所以我小时候就喜欢与蚂蚁作伴。我总是试图用各种各样的办法去了解蚂蚁的生活习性。我可以一整天的观察我家屋檐下的蚂蚁来来去去。看见他们用触须碰一碰，然后各自分头走开，我就会想它们到底说了什么。我在想，能不能用一种方法解开蚂蚁语言的密码。我从书中得知蚂蚁洞里有蚁后，她有很大的肚子。为了一睹芳容，我开始试图水漫金山，把水往蚂蚁洞里灌。我有时一个下午就干这种事情，却没有一次成功看到蚁后。后来才知道蚂蚁是如此精明的下水道工程师，水大部分都渗到地底下去了。可是我不甘心，我开始试用别的办法。比如在洞口放一块糖。可是蚁后架子太大，终究不肯出来，让别人帮她送饭进去。</p><p style="margin:0px 0px 20px;padding:0px;">有人说，这个世界最后不是毁在疯子手上，就是毁在科学家手上。世界上如果只有科学家是很可怕的，比如他们会发明高效的杀人武器。我发现疏松的棉絮可以迅速的燃烧，就想出一种惨绝蚁寰的大屠杀实验。我先把糖水滴在地上，等蚂蚁把那个地方围个水泄不通的时候，铺上棉花，点火……现在想起那些勤劳的小黑头都变成灰烬，我仍然心惊肉跳。他们的灵魂会来找我报复吗？后来这个实验有一个升级的版本用的是浸泡过一种化学药品溶液的纸，文火燃烧，由于燃烧速度慢，杀伤力不大，这个实验可以测试蚂蚁的逃跑路线。我还用活蚂蚁进行过心理实验。首先用破袜子摩擦塑料尺产生静电，然后放在一只正在行走的蚂蚁身后不远处。蚂蚁走不动了，我就开始推测它在想什么，它感觉到什么。它可能会觉得有外星人？但是由于尺子拿开以后，它若无其事继续走，我猜它只是有点纳闷，而不惊慌。但是反反复复几次之后，它明显有罢工的意思，似乎忘了自己要去干什么。后来我又发现蚂蚁被吸到塑料尺上之后会由于带上相同的电荷而被&quot;发射&quot;出去，就像人间大炮一样。注：&quot;人间大炮&quot;是日本电视剧《恐龙特急克塞号》里的一种可以把人当作炮弹发射的威力很大的电磁装置。</p><p style="margin:0px 0px 20px;padding:0px;">一点微小的发现，就可以引发大量的探索和实验。这就是我在那个年代的特点。虽然妈妈也逼着我练习书法，绘画，还多次获奖，但我不喜欢这些东西。我似乎生下来就是科学家，不是搞艺术的，不过也许只是妈妈的强迫让我反感了艺术而已。物理是我最喜欢的，因为它让我了解到世界的奥秘。我一般开学前几天就会把物理书上的实验都挑出来，费尽辛苦找到材料实践一番，心里美滋滋的。上学真是快乐！</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">失之交臂</strong></p><p style="margin:0px 0px 20px;padding:0px;">上了高中，由于课业的压力，我的生活逐渐改变了。为了考上清华大学，我努力的学习。抛下我的毛笔，抛下我用来做实验的蚂蚁，电池和线圈，抛下除了考试科目的一切。在老师眼里我是一个听话的好学生，在妈妈眼里我是一个听话的好孩子。每天早上按时起床，吃一大碗妈妈做的面（为了补充一上午学习需要的体力），然后冲进教室，按照预设的程序开始读书，做练习题。似乎一切都有条不紊，顺利进行。可是……</p><p style="margin:0px 0px 20px;padding:0px;">忽然有一天我发现，我的一切活动都是在纸上进行的，看书，做习题。试卷和复习书让我变得变得麻木。我想这样下去我就不再像爱迪生和牛顿了。于是我开始调皮起来。我不但要做考试的题目，还要做更难的题目。做了物理奥林匹克的题目，接着就想看大学的物理书，接着就想恢复我小时候的实验的爱好。老师辅导自习时经常被我缠住问一些不着边际的问题，那其实是我在实验中发现的问题。终于有一天，在我要求他跟我合作制造一个磁悬浮陀螺的时候，他显示出了不耐烦：“王垠，你让我先回答别的同学的问题好不好？你的问题对考试没有好处。” 我呆住了，启发我让我爱上物理的人，尽然对我说出这样的话。后来想一想，他也是无奈啊，不过我从此再也不想问他任何“超纲”的问题。</p><p style="margin:0px 0px 20px;padding:0px;">高二的时候妈妈就拿回一份前一届的高考题让我做，我随手一做就得了一个当时可以考上清华的成绩。我的心里想，清华我来了。明年的这个时候，我就会拿到录取通知书了！从此我就不再把高考放在眼里。我开始钻研越来越难的题目，进行越来越离谱的实验。我想，清华里面应该都是我这样的学生吧，我会有很多志同道合的朋友，不用再跟这群只会做题的呆子在一起了。</p><p style="margin:0px 0px 20px;padding:0px;">可是我的行为总是受到老师的压制，他们要把我们变成考试的机器。他们告诉我，沉下心来做习题，考试才能有把握。妈妈也帮着老师劝导我。看，一班的某某某这次模拟考试数学成绩比你高，多努力一下吧。我哪里听得进去，我才不在乎这点分数，我能解决更难的问题，老师都没法解决的问题。我开始有了逆反心理，开始早上懒床，装病请假不去上课。班主任，校长多次找我谈话，说我要沉下心来准备考试云云。但是我根本就听不进去，我鄙视高考，觉得他们没有资格出题来考我。然后我就有了心理疾病，大概是强迫症。高考语文的时候我居然怀疑监考老师认为自己在作弊，接着好像真的怕被抓住了一样，手发抖，头冒汗。然后我又想要是考不好，以前的优秀会不会也被人怀疑？他们会不会以为我以前的成绩全都是作弊得来的？手就抖得更厉害了。这时候，监考老师可能发现了我的情况，真的走了过来，站在我身后。害得我好几分钟不敢写一个字，因为手已经完全不听使唤。不过他还是走开了，这可怕的高考终于结束了。</p><p style="margin:0px 0px 20px;padding:0px;">我们是考试前填的志愿，我根本不考虑其他学校就只填了清华。后来妈妈研究了一下，帮我添了一个天津大学在第二志愿。以下的志愿全部空白。大家觉得我真够大胆，可是我的心理状态让我发挥完全失常，比清华的最低分数线还差两分。特别是语文，才96分。天津大学第一志愿收满不要我。昔日的好学生，居然到了落榜的下场。我真的那么好吗？我问自己。我太骄傲，才落到如此地步吧。我开始怀疑自己是否应该那样瞧不起高考。看着爸爸的愁眉苦脸，妈妈的唠唠叨叨，真是生不如死。复读吗？那会是噩梦的继续。我不能再在这个学校待下去。再面对题海，我的心理疾病会让我自杀的。碰巧四川大学来招收高分落榜的学生，还给了我随便选择专业的机会。妈妈说，计算机现在很火热，出来好找工作。我虽然对工作不感兴趣，但是我比较喜欢写程序，于是就进了川大计算机系。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">两度退学失败</strong></p><p style="margin:0px 0px 20px;padding:0px;">不能不说进川大是个没有选择中的好选择。大学生活自由一些，我至少不会走上自杀的道路。可是我的毛病仍然在继续，我永远不满足学校里能学到的那么点东西。老师基本是照本宣科，我逐渐不再满足这种知识灌输式的教育。我觉得完全没必要上这个大学。</p><p style="margin:0px 0px 20px;padding:0px;">川大的环境我实在无法忍受。军训的时候受够了同学和教官的委屈，我就想退学。我们的军训是在一个戒备森严的炮兵基地里，心里的苦向谁说啊！有一天我们正在路上齐步走的时候，我忽然看到一个女人挽着一个军官走了过来。那个军官的老婆怎么长的这么像我妈妈！要是妈妈来到我身边该多好！没想到回到营地，团长（原来是连长，我们来军训他就升一级做团长了）说有人来探访。我走过去，居然发现是妈妈！因为听说我想退学，她急忙向学校打听了军训的地点，几经周折跑过来，是那个军官带着她混进来的。我想我妈妈要是转行当间谍一定是个好料子。她说已经帮我办了退学，学校同意了，回去好好复习，准备考上清华…… “好好复习，好好复习”……我的脑海里又浮现出高三的情景，这次我要跟一群更没用的复读的人在一起。脑子一阵疼痛之后，我说：“妈妈，我不想退学了。”</p><p style="margin:0px 0px 20px;padding:0px;">可是军训回到学校，发现宿舍如此差劲，我又想退学。妈妈又来帮我办理手续，可是结果我还是由于懦弱反悔了。害得学校办事的老师都骂我： “你这个人简直神经病！” 对啊，我确实是有病，不过我的是精神病，不是神经病。我恨我的高中，我恨我的大学，我恨高考，我恨中国的教育！是你们让我生病的。可是妈妈，她为了我已经费尽了辛苦。我不能再这样周折下去。我自己在学校里好好努力，准备考上清华的研究生吧。</p><p style="margin:0px 0px 20px;padding:0px;">学校住宿环境很差劲，又经过好多麻烦事，我终于决定在校外去租房子住。后来我开始玩滑板，它让我变得勇敢。我心里逐渐平静下来，可以用心看书了。大二以后，我的学习生活才逐渐进入正常，自信开始恢复。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">梦的复苏</strong></p><p style="margin:0px 0px 20px;padding:0px;">记得川大教Pascal语言的老师第一堂课就对我们说：“我们学校就是落后啊。外面公司里都用C, C++了，我们还在教Pascal。你们以后要出去工作恐怕还是得学学VC什么的。” 于是有的同学开始抱起一本本像“XXX圣经”之类的书开始学习，上数学课也在看这些东西。我当时自愧不如啊。自己就是小学的时候玩过一下学习机，可以说没有任何计算机基础。辅导员也经常夸他们几个动手能力强，以后公司就需要这样的人。他们出口就是Bill Gates, 世界首富云云。军训的时候听着他们说什么DOS, 温95，我就只有张着嘴崇拜的份了。才想起我高中计算机竞赛的时候一道有关DOS命令的题没有做出来，现在听他们说才知道原来DOS是个“操作系统&quot;。那操作系统又是什么，他们说每个电脑上都必须有一个操作系统……我真是愧不如人 -_-!</p><p style="margin:0px 0px 20px;padding:0px;">正在我决定鼓起勇气后来跟上，准备拿起一本DOS大全从头啃起的时候，一次偶然的机会我接触到了Linux。后来又因为The Art of Computer Programming，接触到了Knuth。我才发现，课堂上讲的那些东西原来如此低级，有些东西学了就过时，学它干吗？我并不比别人落后多少。我一再的思考，什么是计算机科学？是什么让我们计算机系的人不同于其他系的。我有时候认为有了答案，但是后来答案又被我自己推翻。在思想的混乱中，我发现我逐渐摆脱了旁人的标准。我不再想像别人那样去考计算机等级考试，对微软的认证也不屑一顾。我自己学会了Linux，还会很多种当时别人听都没听说过的计算机语言。我学会了LaTeX，还因为找出Knuth书里的错误得到两张支票和一些礼物。这并不是什么值得炫耀的，但是这给我对计算机的兴趣很大鼓舞，我从此更加认真的看书。上课要不就逃掉，背地里拿着大部头的“龙书”之类的原版英语书啃。要不就看我打印出来的GNU的一些资料，完全不听老师讲。期末划重点的时候也不去，考试却总能考个八九十分。总有几个女生排名在我上面，不过我不在乎这点分数，考试和分数不再能评价我。同学们大概都觉得我是一个怪人，后来毕业了我才听他们说，他们管我叫“怪才”。我如此努力的学习着，对别的事情充耳不闻。我只有一个目的，就是毕业就离开这个鬼地方，进入清华大学上研究生。虽然大家不理解我在干什么，清华的老师应该挺在乎我学的东西吧。</p><p style="margin:0px 0px 20px;padding:0px;">可是我没有想到，在我死啃书本的时候，我的创造力正在离我远去。在我盲目接受我认为高深的材料的时候，我失去了自己的创造。我成了比别人稍微好一点的技术工人，不再跟爱迪生和牛顿是一类人了。我高中的时候拼命想保存的创造力已经在苦读之下消失殆尽。我看书的方式变得顺序化，总想从头看到尾。我的高中老师们的目的，中国教育的目的，终于快达到了。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">清华，我来了</strong></p><p style="margin:0px 0px 20px;padding:0px;">大三的暑假，我来到清华想拿一些考研的资料。这是我梦中的地方呀，美丽的校园，比川大要大上好多倍吧，脚都走痛了才走到招待所。去系办，一个办事员态度很不好的给我一份资料。哎，学校好，人脾气就该大啊。忍了吧，要是真能考进来就好了。</p><p style="margin:0px 0px 20px;padding:0px;">后来听一个老师说清华有一种学生叫“直博”，可以硕博连读，五年拿到博士学位。只要面试通过就可以进来学习。我心想这种方式好啊，我平生最讨厌的就是考试了。出高考题的那帮人，他们有什么资格考我！考研资料也是遍地飞。写了几本复习材料就自称什么“一代名师”，我最看不起这种人了，就会赚钱。我如果可以获得“直博”的名额，就可以永远摆脱他们了。想一想，要是硕士三年，博士三年，就要六年。现在五年就可以拿到博士学位，还不用考试，真是太好了。可是我又有什么资格获得清华的直博？我在川大从来没听说过这种东西。</p><p style="margin:0px 0px 20px;padding:0px;">于是我就开始打电话联系老师，跟他们谈谈。面对他们的眉头，面对他们的笑脸却无可奈何的说“没有名额”，我都感觉没什么希望了。一个院士甚至对我说：“你们四川大学是什么学校？二流都算不上，最多算个三流大学。你怎么能来我这里！” 我深受打击，可是我还是没有放弃。最后我找到了一个老师，我们一开始就谈的挺投机。他听说我跟Knuth有过联系，挺高兴的说，哦我知道他，好多年前来我们这里做过报告呢。我终于觉得找到了知音，于是决定就跟着他学习。老师找好了之后还有一个面试，是别的老师参加的，我说什么他们似乎没有认真听，就一个劲看我的考试成绩这种我不屑一顾的东西。我面试时特意穿上了Knuth送我的MMIX T-shirt，他们大概根本不知道是什么，我也没有提起。</p><p style="margin:0px 0px 20px;padding:0px;">不过老师只对我的体育成绩提出了疑问，说你怎么才80多分？你的身体能不能胜任繁重的学习任务啊？我笑着回答，我每天还跑5000米呢，我们学校打分比较严，难道清华的学生体育都考90？面试就这样通过了。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">推荐信与散伙饭</strong></p><p style="margin:0px 0px 20px;padding:0px;">面试通过后回到学校还要办一些手续。成绩单，推荐信等等，跟申请外国大学研究生院差不多，让我感觉挺正规的。院长对我挺好的，同意帮我签推荐信。可是签完字之后他对我说：“你别以为他们觉得你是个人才。他们是根本招不到人！他们那里像你这样的学生都出国了，剩下的是最差的。谁想读博士啊？你别太高兴了。” 我笑着应付这突如其来的打击，在心里却不断为自己的选择辩护。清华一定是好样的，不会让我失望。它是我的梦啊。</p><p style="margin:0px 0px 20px;padding:0px;">很多麻烦的手续之后，终于拿到了我梦想的大学的录取通知书，可以离开川大这个鬼地方了。毕业的散伙饭上，看着大家喝得酩酊大醉，还有人在咆哮说居然连川大的文凭都没拿到，我一个人默默地想象着即将到来的清华的快乐生活，暗自庆幸。</p><p style="margin:0px 0px 20px;padding:0px;">散伙饭到了尾声的时候，我诧异的看到一个平时不太熟悉的同学拿着一杯啤酒走过来。我挺紧张，我最不喜欢别人给我敬酒了，说是客气，其实很虚伪。没想到他说：“我敬你一杯，大牛人。听说你被清华大学录取作了博士。我干了，你随意。” 我不知如何回答，我一向不知如何应付别人的恭维。还好他没有让我也干杯，倒是够尊重人。没想到喝完他接着说：“我知道你是怎样的人。我很仰慕你，你是真正喜欢研究的人。可是我要告诉你，清华的人并不会比我们好多少。大部分人也只是想混一个学位，将来找个好工作。没有多少人可以跟你一起研究的，你去了必定很孤独。我就很奇怪你这样的人怎么不出国呢！你会后悔的。”</p><p style="margin:0px 0px 20px;padding:0px;">我有点不高兴了。一个人说你的选择是错误的，你的反应是什么呢？反正我当时为我的“清华梦”作了一番辩护，说我进去自己好好研究，应该还是能够很好的，毕竟这是我从小的梦啊。可是没想到，他说的居然是对的，我现在开始感谢他了。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">计算几何，创造力的复苏</strong></p><p style="margin:0px 0px 20px;padding:0px;">清华还是一样的上课方式，大部分课也是很多人一起上，一起打瞌睡。老师也是照本宣科，我居然发现他们其实跟川大的老师没什么区别。清华的不同之处就是，一到考试的时候原来进行的一切娱乐活动都不见了人影。原本每天晚上都有人一起玩轮滑，考试的时候就只剩下我孤零零的一个人。因为大家都怕考试，开始熬夜复习了。还有就是上课不容易逃课了，有些老师会突然点名，缺席会严重影响最后的成绩。</p><p style="margin:0px 0px 20px;padding:0px;">对于博士生，传说还有一个规定，那就是后10%淘汰。也就是说，不管你成绩如何，如果成绩排名在课程的后10%，那么就要重修。而如果两门功课重修，就会被开除。面对如此残酷的规定，很多同学都惶惶不可终日。我就是在隔壁同学的唠叨声中度过了第一期。不过我还是没有把考试当回事，所以我也没有去验证这个说法的官方真实性。我仍然不去听老师划重点，我仍然不觉得老师出的题目有什么好，我仍然讨厌有人让我们用手算矩阵。可能觉得太残酷，还是觉得要是开除了博士生谁来干活，这条规定后来改成了如果博士生上了80分就可以不重修。我也不知道为什么我觉得考砸的科目也上的了80，故意放我过去的吗？</p><p style="margin:0px 0px 20px;padding:0px;">但是我的生命中出现了这样一门课程。它改变了我对老师的看法，让我觉得上课原来也可以如此有趣。这就是计算几何。上课的人很少，只有十来个人。因为听说这门课很难，很多同学都没有选。但是我就是那种知难而进的人。老师上课的方式跟别的课程很不一样，大家坐在一个小教室里，老师有精美的幻灯片，有动画，不时还插入一段大科学家，大哲学家的名言。上课时老师会停下来很多次让学生提问题，下课大家都积极踊跃的讨论新奇的问题。课程的评分方法也很特别，平时成绩占到30%的分量，作业分为几种分值，可以自己选择做不做，作业的总分数乘以30%，加上最后大作业的分数乘以70%，就是最后的得分。说真的，这门课太有趣了，我就只逃过一次课。但是还是有时候人数不到一半，因为其他课程压力太大，有人都去复习别的课程了。但是邓老师从来不点名，还对逃课的同学表示同情。还问我们在座的有没有其他课特别紧张的，下次课可以不来。真是让人感动。</p><p style="margin:0px 0px 20px;padding:0px;">我就是在这门课上认识了王益，我们亲密无间的合作，让我领略到了什么叫做研究。大作业的时候我们在一个小组，其实是三人一组，但是那第三个人其实什么也没干。我和王益决定写一个3D的Voronoi图扫描算法演示程序。王益的3D图形编程能力很强，所以他做界面，由我负责算法生成数据作为后端。我们分别在自己的机器上编写程序，不时的打电话讨论接口的设计问题。我找到了Bell labs 的 Steven Fortune 的算法程序，决定看懂它，然后改造成演示需要的分部运行的算法。但是 Fortune 的程序几乎没有注释，而且使用了一种奇怪的数据结构，很难理解。Fortune 还在程序里说到，这个算法虽然有效，但是对于程序员来说是一个挑战。所以我email请他给我一份算法论文的拷贝，他同意了。但是一个月之后，信才到我手里，那时我们已经完成了作业。因为我花了一个星期看懂了他的程序，还换掉了他的麻烦又低效的数据结构。随后成功的把后端与王益的前端设计好接口联合。等我看到 Fortune 的论文，发现程序里面其实已经改进了论文的核心内容。其中的parabolic transformation其实完全没有必要实现。我深深体会到实践的重要性，也许先有了他的论文我反而会被误导，写不出实际可以运行的程序。</p><p style="margin:0px 0px 20px;padding:0px;">由于我们的团结努力，老师对我们的大作业非常满意，他给了我们最高的分数 100。由于我们两个都在课下超额完成作业，所以总的分数我们两个都是满分。这是我阔别已久的100分。只有在小学我才拿到过这种分数啊！对于一个对考试成绩满不在乎的人，100 又意味着什么？如果是别的课程我会毫不在乎，就像我得了80分一样。可是这个100分是我们团结研究而来的，它包含了对我们的合作意识，对我们的友谊，对我们的热情的肯定。虽然我觉得我们的东西还有改进的余地，但是我接受这个100分！也只有这样的课程，我才可能得100分。</p><p style="margin:0px 0px 20px;padding:0px;">从此我感觉到了什么叫做研究。这跟我小时候干的那些事情没有什么两样。你在身边发现一个问题，想知道为什么。然后你就想去获得解决这个问题的知识。你去看书，你去问专家，你上网去搜索。如果没有发现答案，那么好啦，你就可以自己试图去发现为什么，这是最有趣的部分。知道了为什么，就想让这个东西有用处，对人们的生活产生好处。这就是研究。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">《完全用Linux工作》与TeX的推广</strong></p><p style="margin:0px 0px 20px;padding:0px;">这么说来我还是对清华有些好感。遇到一个好老师让我从呆头呆脑的技术工人的状态恢复过来，开始追求自己的梦想。可是第一年把所有的课程上完之后，我就发现原来清华所谓的“研究”是如此混沌。其实清华大部分人进行的所谓的“研究”是什么呢？其实就是写作，不是科学研究。这一点以后我会详细叙述。</p><p style="margin:0px 0px 20px;padding:0px;">远远看去外观华丽的有着先进的工作站的实验室，却没有可以安心看书的地方。机器挨着机器人挨着人，书都没地方放。师兄师姐们都在忙着用 word写论文，不时有两个人隔着几行机器大声谈话。实验室通风不好，还有一个大型工作站在嗡嗡作响，我进去一会儿就觉得头晕，所以后来就不想去了。PC 机以前都是公用的，每次都会用不同的机器，却没有我想用的软件，麻烦死了。好不容易实验室买了新机器分配给个人，装上一个 Linux 系统开始写程序，还在Sun工作站上安装了多达1G的GNU程序。却被一个师兄嘲笑说那种跟DOS一样落后的东西你居然也用。于是我写了一篇文章叫做《完全用Linux工作》，放在主页上驳斥这种观点。矫枉过正，确实写的优点偏激，结果引起网上linux界轩然大波。后来我又发现几乎全校的论文都是 word排版的，那些公式质量太差，看起来头痛，才发现很多学生害怕数学的原因之一。所以又写了文章宣传 TeX，希望中国产生更多漂亮的数学书。这下子我出名了，真没想到，出名不是因为我的研究成果，而是因为这些业余的东西。我起初不希望我因此出名，但是看到旁边的人都用上了 TeX，我觉得我还是做了一件好事，至少让论文看起来漂亮了一些。</p><p style="margin:0px 0px 20px;padding:0px;">可是论文的内容，却是我永远的痛！</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">培养计划</strong></p><p style="margin:0px 0px 20px;padding:0px;">我在第一年就把功课全部上完了。本来我想多选几门课，比如法语，可是清华的博士要选课需要提交一个“培养计划”给导师签字。导师同意之后才能修改。导师看到我选了法语，就说这个第二外语还是自己学学就行了吧，旁听也行啊，我主要是怕你课太多了考试不通过就麻烦了。我当时没有说什么，就把法语去掉了，只留下刚够学分的课程。其实我还想选很多的，体育，音乐什么的，都不好意思跟导师说。后来才知道宿舍对门的硕士生选了钢琴课他们导师都不管。为什么我们就受到如此待遇？</p><p style="margin:0px 0px 20px;padding:0px;">可是没有把法语加到培养计划却成了我的遗憾。有一个新学期我去旁听了第一节法语课之后老师就说，我知道很多同学是来旁听的，这样教室里人太多了，效果不好。这对自己对大家都不好，下次请旁听的同学不要来了。我脸皮薄，下次就没有去了。后来自己想自学却又没有老师教，看了十集reflet之后就此作罢。</p><p style="margin:0px 0px 20px;padding:0px;">后来我终于明白了，清华不需要全面发展的博士生，而其实导师还会在某种程度上削弱学生的能力。导师并不是真的为我们好，而是不喜欢我们上课，因为上课不但会花掉研究（或者干活）的时间，而且让他们眼界太开阔，这样学生会很容易有别的选择而走掉。所有的活动：助教，实习，都必须有导师签字。而大部分导师就会找借口不让学生干这些事情。不给他们助教和实习的机会，让他们以后不好找工作，只能为自己服务，或者为自己的熟人服务。甚至这次我去西藏，要办边境证都要有导师签字。办事的老师说，没有导师签字，你跑出去了不回来怎么办？大妈，我跑那种地方干吗？</p><p style="margin:0px 0px 20px;padding:0px;">除了这些，还有两大法宝就是博士学位和违约金。清华的博士学位有多值钱知道吗？不知道？那么博士退学要交几万块钱的违约金，这下大部分穷苦学生怕了吧。这就是你们的卖身契。清华就是这样把研究生牢牢地控制在自己的掌握之下。我对一个如此害怕学生跑掉的不自信的学校还能说些什么？如果你是好样的，就不会害怕我们跑掉！该跑掉的最后终究会跑掉。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">我的自我培养</strong></p><p style="margin:0px 0px 20px;padding:0px;">在学习上，我永远是个吃不饱的人。选不了课，我就去旁听。旁听后觉得老师讲的不好，我就自学。在我有空的时候，我就会去图书馆借书看。在我本科的时候，我就已经发现自己的一个特点，我会很快发现新的东西，并且学会使用它。虽然这些东西并不是创新，但是它们丰富了我的技能，让我有更大的能力去进行创新。我经常顺藤摸瓜似的从一个问题搜索出一大串我想知道的东西。然后借一大堆书回来，每本看一点点，只为找到我需要的答案。</p><p style="margin:0px 0px 20px;padding:0px;">计算几何课的一次作业，我为了写一个算法的演示程序，花了3天时间学了一点Java语言，正好能够完成那个程序。我开始接触到TeX的底层细节，看完了The TeXbook，并且找出一道练习题答案的错误。开始移植gbkfonts程序，作为我的CWEB语言的练习。看完了几乎所有 Xlib 的手册，了解了 XWindow 的工作原理。我接触到 Scheme，并且做完了 SICP 的大部分习题，还自己想出好多问题用Scheme实现算法。后来花了好几个晚上，把MIT课程6.001的录像下载回来。我才发现教授上课可以如此搞笑有趣，上课时戴上巫师的帽子，做一些滑稽的表演。我终于明白，有的计算机科学家居然可以去好莱坞演电影 :) 这个课程让我领会到 LISP 的强大，改变了多年以来对这种古老语言的误解。它让我感觉到在看似纷繁复杂，不断更新的计算机语言的世界，还有那么一种永恒的美！接着我又学会了 Common LISP，并且开始用它来设计研究计算几何的一个函数库。另外还找了一些希奇古怪的程序来玩，写了一些心得体会放在网上给别人看。</p><p style="margin:0px 0px 20px;padding:0px;">我意识到自己数学还不够强，甚至有些怕，就开始看一些数学方面的书。Concrete Mathemtatics, What is Mathematics?, Science and Hypothesis, Godel Escher Bach, ... 虽然每一本都没有看完，但是我逐渐相信自己的数学能力，发现数学原来如此有趣，并不是做习题那么枯燥，也不像一辈子就拼命证明一个定理那么清高。才发现国内很多数学书用难看的符号把学生吓倒了，其实想通了就是很直观的原理。</p><p style="margin:0px 0px 20px;padding:0px;">我看了电影 A Beautiful Mind 之后深受感动，就去买了一本原著的书，它是数学天才John Nash的传记。它描写了20世纪初的Princeton，一群科学家生活的情景。我眼前浮现出在一个房间里，一群人在喝茶聊天下棋讨论问题激烈争论。我发现我从小内心向往的，就是那样的地方。我看到Nash是如何用“头脑暴力”解决一个他没有任何基础知识的问题。原来只要有了问题和探索的精神，就会有动力去获得解决它所需要的知识，最后将问题解决。发现有用的，重要的问题，而不只是寻找困难的问题，这样才会对人类有价值，才会有动力。我还看到一个真正的数学天才是怎样的喜欢恶作剧，又怎样因为过度的傲慢狂妄，想向世人证明自己的天才而发疯。我发现世界上有远比科学更宝贵的东西。我开始悔悟我高中时对待成绩不好的同学的态度。我不是一个天才，但是我要做一个好人。</p><p style="margin:0px 0px 20px;padding:0px;">但是我的研究却没有多少进展，至少我自己这么认为。我发现问题的根源，就是没有真正的讨论，没有真正的问题。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">我们也有讨论，原来是这个样子</strong></p><p style="margin:0px 0px 20px;padding:0px;">上完课，就该开始搞研究啦。可是研究什么呢？老师给我几篇论文看，意思是让我看看有没有什么想法。</p><p style="margin:0px 0px 20px;padding:0px;">我开始感觉没有头绪，就跟导师说能不能找师兄师姐跟我讨论讨论，还有别的人在做这个吗？他说，就你一个人做这个，每个人做一个题目，独立思考，这就是研究。我觉得是啊，我应该独立思考。可是过了一段时间发现不行啊，我想实现一个想法，但是我不知道是不是已经有人试过失败了。实验的时间开销会比较多，所以我想知道那么多厉害的人，为什么都不用这种明摆在那的方法？当我再次提出需要讨论的时候，他似乎有点生气的说：”你为什么总是想有人跟你做一样的东西啊？你不是想抄袭别人的论文吧？” 我不发话了。继续做我的实验，结果确实不理想。虽然自己实践很重要，可是要是能利用别人的经验，何乐而不为呢？这并不是偷懒。如果有人讨论，很多时候一个人提出一个问题，另外的人可能就会告诉他这个问题是不是有人做过，有什么重要性，凭直觉告诉他有什么难度。可是如果没有讨论，连问问“有没有人做过”的机会都没有！</p><p style="margin:0px 0px 20px;padding:0px;">后来我就经常上网看看国外的大学怎么搞研究，发现他们都有 seminar，讨论组。A Beautiful Mind 描述的 Princeton 以前的天才们每天都在一个地方喝茶，讨论问题，争得面红耳赤，回家分头思考，做实验，第二天喝茶时再讨论。那就是我从小梦寐以求的生活啊！计算几何课已经让我爱上了与人合作和讨论的方式，现在却孤零零一个人了。我必须告诉导师，合作和讨论是非常重要的。在我据理陈述之后，他说：“好吧。反正师兄师姐各自有自己的事，你要讨论什么就跟我和你副导师讨论吧。” 于是我就开始了跟他们两个星期一次的见面讨论。每次讨论都感觉他们不知道我在说什么，他们心里想的都只是这个能比别人的好多少呢？能不能投到这个会议呢？如此宏观。我觉得跟他们讨论完全是浪费时间。</p><p style="margin:0px 0px 20px;padding:0px;">后来课题逐渐有了新的同学加入，导师决定跟中科院数学所的人一起申请一个项目来研究。于是我们每两个星期去中科院讨论。不过感觉他们那边也差不多。中科院的老师觉得他们的研究太理论，期望我们能给他们带去一点实际的东西。可是我们也没有什么实际的东西，所有的问题都是从别人的paper里看到的。副导师就开始跟他们说这个问题有多么多么重要…… 他们也借此机会开始研究以前放下的一些问题。总之讨论的感觉就是没有目的，没有主题。有时有人说他在想一个什么问题，说了一会儿就被否决了。有时候就是一个人看了一篇paper之后做一个感想。我坐在那里就在想，我们到底在干什么？我们甚至都不知道什么东西值得研究，还研究什么？后来师弟师妹们就开始考虑把问题变一变，看看能不能产生新的问题。他们的做法，我跟他们开玩笑说就是“有问题也要解决；没有问题，制造问题也要解决！” 他们笑着点点头，“本来就是这样嘛。没办法啊。”</p><p style="margin:0px 0px 20px;padding:0px;">博士生论坛的时候，同学们都觉得有类似的问题，讨论不足，交流不足。所以我提议成立一个类似国外大学的 Common Room，用来讨论问题。可是大部分老师说：“这样一个房间，天天都要有那么多人在里面待着。谁来出这个钱？” 是啊，老师自己的办公室都要钱，哪里可能有什么 Common Room？就算有了 Common Room，在里面讨论的无非还是文章发到哪里的问题。制度决定了行为，我的设想太理想化了。</p><p style="margin:0px 0px 20px;padding:0px;">分析一下，为什么老师不提倡讨论呢？因为问题是有限的。老师辛辛苦苦这么多年搞来搞去都在搞这些问题，分配给你们每人一个，互不冲突。要是两个人都搞一个问题，这下好了。出了成果论文归谁？学校要求必须第一作者才算论文数。要是两个人都写论文，那么投到同一个会议肯定有一个要被 reject。这样对集体发展不利嘛，大家不就是发几篇论文混毕业吗？何苦？</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">paper, paper, 还是paper</strong></p><p style="margin:0px 0px 20px;padding:0px;">说到paper我就痛心。我的方向上我至今还没有看到几篇我觉得像样的文章。我主要进行集成电路布线算法的研究。看起来高深，其实是很简单的问题，一个平面上有一些点是电路里的电极，现在需要用铜线把它们连起来，怎么样让连线的长度或者时延最短？这个问题跟几何上一个有名的问题 Steiner tree 问题有关系。我的导师就是以前写了一篇这样的paper发到IEEE transactions。</p><p style="margin:0px 0px 20px;padding:0px;">已经毕业的一个师兄就在他研究的基础上修改来修改去，发了好几篇paper。英文的不够还翻译成中文，投到国内的期刊。后来一个师姐又在这个师兄的基础上进行修改，又发了好多篇。可是在我看来，他们的论文纯粹就是炒冷饭，没有什么创新。一个问题解决了，那么解决问题的人显示了他们的聪明，至于这个问题对人有什么用，他可以暂时不管（虽然我也严重反对这种做法）。后来又有人来搞这个问题，多半是被老师分配来的。他也小修改一下，修改想法其实不费工夫，主要是你怎样把你的 Introduction 写好？可以让别人觉得你的工作有意义？这就是功夫。作家的功夫。我有一次面见INRIA的头目 Jean-Claude Paul 时，他就对我说：“Tsinghua students are all writers, not scientists.”</p><p style="margin:0px 0px 20px;padding:0px;">现在清华研究生做的事情无非就是，写好paper，然后找个地方投出去。SCI 的最好，EI的其次。偏僻的没人看的杂志也没关系，交钱也没关系。我就知道日本的一个SCI索引的期刊收1000美元的版面费。导师出钱，不投白不投，投了好毕业呵！</p><p style="margin:0px 0px 20px;padding:0px;">现在我也被“分配”来做这个问题。虽然说是一个有名的问题，但是这个有名的问题已经被研究了好几十年了。有很多挺厉害的人做出了很重要的贡献，但是我们为什么研究这个问题？我至今没有搞懂。</p><p style="margin:0px 0px 20px;padding:0px;">开头导师只是给了我两篇paper，据说是以前他一个得意门生写的，美国某大学的副教授。其中有一篇说是如何在不构造 Delaunay triangulation的情况下生成 MST （最小生成树）。看到这篇文章开头说在 rectilinear metric下, Delaunay triangulation 就不能用来构造 MST 了，所以他设计了一个新的算法。这个算法比起 Leo Guibas 的算法更加简单。文章里还提到一次 Matroid，让初出茅庐的我觉得高深莫测。我还专门去借了一本《Matroid Theory》来看，其实他的论文剩下的部分跟Matroid没有任何关系。可是我对“Delaunay triangulation 不能用来构造 RMST” 这个说法产生了怀疑。经过理论分析我觉得即使在 rectilinear metric下，Delaunay triangulation 也可以用来构造 MST 的。我觉得作者只是故意这么写，想为他设计算法的动机找一个借口。我决定实践我的想法，写一个程序从Delaunay triangulation 构造出一个 RMST。这本身不是什么创新的工作，可是我却在想，这样一个东西能不能用来构造 Steiner tree 呢？后来我真的就想出一个办法。实验表明我的算法比以前的算法要快几倍。</p><p style="margin:0px 0px 20px;padding:0px;">这是不是说我的算法是一个值得写paper的东西呢？导师说我应该写一篇，但是我认为我只是在挑别人的毛病时意外想出了一个改进的算法，并不会对将来的研究有什么启发。虽然程序快了一些，但是很少有那么大的线网需要这么快的算法，而且几倍的提高在我眼里不算是一个理论上的改进，而且这个算法不能推广到其他距离空间，可扩展性很低。所以我内心觉得这个结果不令我兴奋，不想写论文。但是在老师的一再要求下，我居然把这个研究写成了两篇 paper。按照他的说法：“应该分阶段总结你的成果。” 起初投出去的时候评委总是说这个东西不实用，导师说这是评委的问题，他们觉得不实用我们就投到理论一点的会议。经过几次投稿，还是失败了。我终于忍不住了，对副导师说出我的想法，我说：“看一个作家的水平，是看他扔在垃圾筐里的纸。就让我把这篇paper永远藏在我的垃圾筐里吧。” 但是他不甘心，说你要相信自己的实力，然后把我的算法胡乱夸奖了一番。我说我不管了，随便你怎么办。我就开始研究我自己喜欢的东西去了。之后他居然真的投中一个欧洲的会议，是被 LNCS 收录的，LNCS 是 SCI 索引的，所以我居然有了一篇 SCI 文章！我自己不喜欢的文章也是 SCI 了！</p><p style="margin:0px 0px 20px;padding:0px;">第二篇论文就更传奇了。几投不中，就其原因，评委说是没有和现在“最先进”的算法程序实验比较。而我没有比较的程序，就是那个让我觉得发 paper动机不纯的人的程序。没办法，求他给我代码。比了一下，确实比他快。不过我估计他程序写的有毛病，老是 core dump。而且从实验数据来看，运行时间增长的速度不符合他论文里声称的时间复杂度。但是没办法，他只给 binary，也不给源代码。程序快几倍，很有可能是实现上的问题，而不是算法更好。我的一个师兄以前就把他自己的算法戏称为“基于bug的优化”。我觉得这样比较对那个算法的作者不公平，完全没有发表的价值了。但是没办法，谁叫我们都是出来混的，没有人在乎这些。我还是记录下数据，添到论文上。一投就中，得了一个最佳论文奖。然后就有一篇校内新闻宣传：“我校王垠同学获得XXX会议最佳论文奖。这是大陆学者首次在如此高级别的会议上获得如此高的奖项。” 这个“高级别”的会议，在我看来就是个垃圾。美国人都把最差的论文投到这里，就是为了来旅游一圈而已。</p><p style="margin:0px 0px 20px;padding:0px;">我对自己的做法产生了深深的负罪感，觉得自己正在进入这团混沌，正在被同化。我决定换一个题目研究。我就开始考虑zero skew tree. 找了20多篇paper来看，发现他们没有什么本质的改进。而且对于问题本身的价值，他们完全就不清楚。有的作者后来甚至说，其实以前他们考虑的问题是没有必要解决的，因为实际应用中不可能遇到，我们其实可以把问题变成这样……本来一句话就可以说清楚的事情，又写成了好几篇paper。我就是这样在 paper的海洋中，找不到目标。</p><p style="margin:0px 0px 20px;padding:0px;">我见过的这种低级别的会议，低质量的论文几乎都是从 IEEE 那里出来的。道理很简单，IEEE 会议多，会议论文集都像两大块砖头，还是双列小字排版，当然能容纳下这么多的垃圾了。所以我对 IEEE 也没有好感。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">火山小规模爆发</strong></p><p style="margin:0px 0px 20px;padding:0px;">第一篇投中了会议之后，副导师很高兴的说“代替我去开会”，到希腊Santorini岛玩了一圈。回来还跟我说希腊不好玩，好苦啊，幸好你没去。然后就继续要我为算法申请一个专利。</p><p style="margin:0px 0px 20px;padding:0px;">写这个论文我都已经焦头烂额了，一点都不感兴趣。现在还要写专利，“要像教小学生做这件事一样，一步一步的把算法写清楚，举出实例”。我觉得快不行了，再这样折腾下去，我到博士毕业也许也就只搞出这些小儿科东西吧！我终于小规模爆发了一次。我坦荡的告诉了副导师我的想法，我觉得做学问应该是什么样，我觉得这么点东西不值得申请专利。我还告诉他我对国内的研究环境很失望。</p><p style="margin:0px 0px 20px;padding:0px;">他慌了，可能以为我想要退学，赶忙找我谈谈。对我说，我知道你心中有很大抱负。所以这次就不写专利了。我知道你想有更好的研究环境，但是不踏踏实实做好现在的工作，又怎么能有大的创造呢？然后就开始举爱因斯坦，居里夫人的例子…… 然后说，其实你在这里好好努力，将来出国的机会多的是，你想去Harvard也行，你想去Princeton，都行啊！</p><p style="margin:0px 0px 20px;padding:0px;">你说行就行？你去去给我看看？我们实验室从来就没有去这些地方的。继续这样做下去，以后哪个真正的科学家还会要我？</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">全面发展</strong></p><p style="margin:0px 0px 20px;padding:0px;">在对清华的研究完全失望了之后。我就准备考GRE，TOEFL出国了。我去上了一个新东方的班，没学到什么英语方面的东西，倒是接触了很多新的思想。老罗的言论特别有趣，虽然我不是完全赞同他的意见。写GRE作文特别培养思维能力。我为了写GRE作文，常常为了一个不明白的问题到图书馆翻阅英文的哲学书籍，有关教育的书籍…… 对于很多问题我得到了完全不同的观点。大学的目的是什么？人的价值观是由理性决定的吗？等等等等。我读到了亚里士多德，柏拉图，康德等人的言论。甚至有个哲学家说 &quot;All Animals Are Equal&quot;. 我看了他的文章觉得有很多可以批驳的观点。我看到迪卡尔的文章，说“要掌握科学就要掌握它的全部”，这句话真合我心意，我就是想做一个懂很多东西的人啊。我想结合艺术与科学。虽然我这个观点得到一些人的批判，但是我仍然相信迪卡尔。</p><p style="margin:0px 0px 20px;padding:0px;">从这些互相矛盾的观点中，我有了自己的判断力。我开始能够揭开从小蒙在我眼睛上的有色眼镜看问题。我开始检查我自己的思维，我以前的观点。看看它们是否是未经判断就盲目放进去的。我检查到很多很多的错误。我的待人接物，我对他人的理解上，都有不足之处。我还检查到妈妈传递给我的一些有色眼镜，小学课本给我们的有色眼镜。我开始学会用自己新的方式对待他人，看待事物。我不再盲目相信权威，哪怕他是诺贝尔奖得主，图灵奖得主。我有了自己的自由思维。</p><p style="margin:0px 0px 20px;padding:0px;">在那段时间，我感觉我的心智大门被开启了。我开始尝试从来没有做过的事情，以及从来不认为我能做好的事情。我一次又一次的相信我能。我能学会画画，我能打好太极拳，我能理解古典音乐…… 世界还有那么多美好的事情等着我去学习去开发啊！</p><p style="margin:0px 0px 20px;padding:0px;">可是，我们却像囚犯一样被判了5年在清华。博士学位就是我们的枷锁。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">醒悟，paper的奥秘</strong></p><p style="margin:0px 0px 20px;padding:0px;">清华研究生谈论的重点是什么？是 paper。吃饭的时候谈，喝茶的时候谈，睡觉的时候也谈。隔壁的同学在进校第一年就为paper惶惶不可终日，说：“你知道吗，他们要求我们发SCI，怎么办呢？我几个师兄都是因为没有paper延期毕业的。” 这恰好就是那个为后10%淘汰惶惶不可终日的同学。他的老师是个院士，可是他在手下就干一些写word文档之类的杂活还忙得要命，根本没有时间思考问题。</p><p style="margin:0px 0px 20px;padding:0px;">后来听说学校有规定，博士生必须发4篇paper才能毕业，其中必须有一篇是SCI索引，或者两篇EI索引。看上去冠冕堂皇的SCI, EI，不就是跟 google 差不多的东西吗？被它索引了怎么样了？特别是对文章的篇数作要求，而对质量没有判断。我其实读了两年都还不知道学校是这样规定毕业标准的。当我知道的时候，已经有人告诉我SCI=Silly Chinese Index。真是让人啼笑皆非。</p><p style="margin:0px 0px 20px;padding:0px;">学校没有能力评价学生的水平，就拿文章数来衡量。这样的毕业标准造就的是怎样的学生，怎样的实验室呢？难道导师真的没有能力判断 paper的好坏吗？有些是，但是有些不是。即使他知道你的论文没什么价值，也会叫你发表。我发现paper数量的背后，是某些人的如意算盘。想一想是怎么回事吧。国家看什么来拨款研究？看paper。看什么来评价一个学校的水平，也是paper。国家没有能力评价你的能力，当然只有看你有多少 paper。所以有了paper就有了钱。只要你能写paper，培不培养你，你将来的发展，关我们什么相干？你写的paper别人能不能看懂，能不能转化成生产力，管我们什么相干？怪不得有的院士想尽办法也要多收学生，宁愿自己帮学生出学费也要他进来。因为学生就是财源。paper可以带来基金，可以在美国买小车洋房，没有基金就让学生干活吧。一个月几百块钱吊着一条命在那里为你拼命，谁叫他们想要那个博士学位呢！</p><p style="margin:0px 0px 20px;padding:0px;">该清醒了，博士无产阶级！</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">告别清华的博士学位</strong></p><p style="margin:0px 0px 20px;padding:0px;">现在我已经厌烦了国内所谓的“学术”。我准备放弃清华的博士学位，出国找个好老师，进行真正的研究。博士第4年了，做出这样的决定真是不容易。有人告诉我不要放弃，你知道有多少人正在羡慕你？你知道一个清华的博士学位有多么值钱吗？但是我不能这么沉默下去了！</p><p style="margin:0px 0px 20px;padding:0px;">博士学位，累坏了多少年轻的中国人！我不再为它浪费我的青春。我知道国外大部分研究也不是那么好，如果国外也找不到好的老师，我就找一个简单的工作，和我心爱的人一起生活。有人说这是浪费人才？在清华混沌的过日子才是浪费呢！当一个侍者至少也让我感到对社会有贡献，看着顾客满意，我会露出笑容。可是做一个博士却没有。我感觉自己是个没用的人。</p><p style="margin:0px 0px 20px;padding:0px;">我已经完全看透了中国教育的失败。我高中的时候就受到它的伤害，这种伤害延续到现在。中国教育已经成为埋没人才的祸首。留在这个圈子里就是屈服，我不出声，大家都不出声，这个世界就会继续这样郁闷的运转下去。我今天要对这个系统大声地说一声“不！”</p><p style="margin:0px 0px 20px;padding:0px;">我离开了。可是中国永远也不缺少为清华拼命的人！因为他们的妈妈会告诉他们，清华是全中国最好的学校。你要考上清华，为我们光宗耀祖……</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">行动</strong></p><p style="margin:0px 0px 20px;padding:0px;">2005年9月22日下午3点，我在东主楼导师的办公室里跟导师和副导师再次重申了我的想法。包括以上的一切，和我准备退学，准备10月份考托福的打算。导师经过一番举例爱因斯坦，居里夫人，叫我踏踏实实的说教无效之后，严厉的批评了我只顾自己，不顾及教研组为我付出的心血。然后说：“要是你不能再为实验室作研究，我们就不能支持你了，前两个月实验室发的钱我收回。你可以马上写退学申请，我们实验室没有什么损失，我们有的是人干你的事情。不过我要告诉你，你一旦退学，连学校的住宿都要被收回！”</p><p style="margin:0px 0px 20px;padding:0px;">接着是副导师尖声的咆哮：“是啊，你瞧不起我们。我们是没有你聪明，可是我们勤勤恳恳……你知道你得的那个best paper award，我们付出了多少努力吗？你认为这么容易拿到吗？那是多少国外专家鉴定……”</p><p style="margin:0px 0px 20px;padding:0px;">我安静的等他说完。真像是一场闹剧，一场梦。他平息下来之后，我说了一声“再见”，然后默默地走出了办公室。</p><p style="margin:0px 0px 20px;padding:0px;">你们要退学申请？这里就是我的退学申请。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">尾声</strong></p><p style="margin:0px 0px 20px;padding:0px;">晚上收到副导师的email说：“还有一件事需要向你说一下：你在学校学习期间所取得的成绩包含你的努力、导师的指导帮助、同学们的帮助，还有学校和国家的支持。你作为博士生学习阶段取得的成果属于教研组、学校和国家。正如同我们作为职务发明的专利属于学校一样。</p><p style="margin:0px 0px 20px;padding:0px;">你在MST、SMT等方面取得了结果，它属于教研组、学校和国家。单位有责任进行合理的应用，为国家建设、国家荣誉服务。有责任进行进一步的整理丰富、向高水平的刊物投送。这里我们想说明一下上述的情况，同时，也告诉你一下：你若愿意将这些成果进行进一步的整理、我们已经给你提出了具体的修改意见，欢迎你按照进行修改。你若放弃，我们将进行具体的改进、投递。我们将尊重你的意见。谢谢。”</p><p style="margin:0px 0px 20px;padding:0px;">最后还是没有忘了paper的剩余价值。进一步验证了我的判断，他们在乎我吗？不。他们只在乎paper。至于我流离失所，又有何相干？我不知道有多少无知的弟弟妹妹又会把他们的研究建立在我不屑一顾的paper之上。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">Segmentation fault ! Core dumped —我写本文的目的</strong></p><p style="margin:0px 0px 20px;padding:0px;">Repair what you can — but when you must fail, fail noisily and as soon as possible. —Basics of The UNIX Philosophy</p><p style="margin:0px 0px 20px;padding:0px;">修复你能修好的—但是如果你必须失败，那就尽快喧闹的退出。—UNIX基本哲学</p><p style="margin:0px 0px 20px;padding:0px;">我不是一个中国教育操作系统下优良的程序。我在系统里运行了将近20年，快到最后的时候才喧闹的退出，Dump出这么大一个core file。我知道有的程序很早就退出了，我自愧不如他们。但是有的程序一声不响就退出了，还有很多的程序成为了zombie，永远的驻留在系统中成了系统的负担，在这一点上我又比他们好一些。至少我让程序员有机会用调试器检查core文件，调查这个程序运行中哪里出了问题。</p><p style="margin:0px 0px 20px;padding:0px;">“你退学就退学，干吗大惊小怪，牢骚满腹的？” 如果只是有牢骚，我就把隔壁同学拉过来一起发发牢骚就完事了。可是我虽然不是优秀的程序，我觉得应该为修复这个系统，修复自己做点什么。我希望国家的教育和研究环境好起来，这样大家就安心的生活，不用出国搞得奔波流离。有多少恋人由于一个人出国了而痛苦的分手，有多少父母在盼望海外游子的归来？我不能像很多人那样申请了国外的学校，拍拍屁股就走人。我一年前就考GRE想出国，可是我总是自欺欺人的幻想国内的境况会好起来，有时我觉得看到希望，可是马上希望又破灭了。一个个大师来了，让我一次次燃起希望，可是发现他们对环境的作用也不大。一些大师不满意，又走了。我自己也想尽力改造环境，结果经过多次努力无效，自认能力不够，终于放弃了。</p><p style="margin:0px 0px 20px;padding:0px;">在发现大家都忙着发表paper而没有讨论时，我曾经建议设立一个清华的THU-Technical Report。我的想法是：最差的草稿扔在垃圾堆里；可能有用但是还不值得向所有人公开的东西发到THU-TR，供系内查阅；如果发现THU-TR的东西会有用，再好好修改了转投会议或者期刊。系学术助理王磊很高兴的采纳了我的建议，并且自愿维护一个THU-TR的编号。可是根本没有人愿意把自己好不容易写出来的但是确实又不值得发表的东西投到这里，因为世界上总有地方可以把这个东西投出去，还是SCI和EI，而这个THU-TR连正式刊物都不算。后来有人告诉我，如果学生都把东西投到我们这里，不知道有多少导师会跟我们急。所以THU-TR的计划就这么告罢。</p><p style="margin:0px 0px 20px;padding:0px;">我一年前写信给Knuth，这个我相信是真正的大师。我说我想退学，想请他推荐一些真正的研究者给我做老师。他回信说“你先找精通中国文化的长者谈谈”。我意识到他可能觉得这是一个文化的问题。我于是想知道中国的科技为什么搞不好，就开始看一些有关文化的东西。后来居然跑到中国社会科学院去听新竹清华大学人文学院的院长讲座，后来又在清华参加了人文学院的研讨会。会上一个老师说的好，当一个制度没法衡量学术水平本身，它就会用一个似乎等价的标准，比如paper数或者高考分数。但是一旦这个标准被确立，人们就会向着这个标准努力，而不是向学术水平本身。他们总会发现制度的很多问题，找出破绽，去达到这个标准，而不是提高自己的学术水平。最后，这个标准已经完全不能反映水平本身。我就在想，这个问题大了，这不仅是环境，制度，而且还是长久以来的文化造成的。从新竹清华大学院长的讲座里，我发现英国人是怎样用科学技术打开了中国的大门，而乾隆皇帝是如何对科学不感兴趣。中国似乎从古到今就不重视科学技术的，中国有自己的优势，自己的文化。对啊，科学技术是个双刃剑，如果照美国那样发展下去也不知道会怎么样。我们中国的文化是瑰宝，但是它已经被外国的坚船大炮打得遍体鳞伤。这不是我们的错，但是我们要努力恢复自己的文化，不能总是怨天尤人。我就开始看道德经之类的东西，还去西麓学社参加古代文化讨论活动，后来又开始打太极拳。</p><p style="margin:0px 0px 20px;padding:0px;">我觉得再没有从实际出发的目标，我的研究就会完全变成纸张了，就像我高中感觉到的一样。所以后来我就自己设立了一个研究方向，我把自己称为“研究博士生”，我要去了解博士生都是怎么样生活的。我就想知道有多少学生有跟我类似的困境。我跟很多朋友谈过，去了解他们的苦衷，研究生也有，本科的也有。我觉得我还应该了解更多的人，就试图到研究生通讯社做记者，心想挂一个记者证，就好跟人套磁问一些问题了。结果他们说我口才不好，所以做了一个秘书。后来记者们告诉我，他们是由上级分配任务的，根本不可能让你去报道学生真正的想法。我为了多多接触外国文化，比较中西文化的不同，又加入了学生对外交流协会(ASIC)，我在ASIC有了很多好朋友。博士生论坛的时候也有很多同学跟我反映研究上的问题。讨论成立特别兴趣小组（SIGs）的时候，我就提议成立一个Common Room，一个同学说她去 Stanford 的时候那里就有很好的 Common Room，很多人在一起讨论，这是国外大学斯通见惯的东西。我告诉Oxford的朋友我的想法，他很惊奇地说：“你们居然没有 Common Room？” 后来吃饭时我又找一些老师谈话，发现他们也对这个事情无可奈何。老师自己的办公室都要自己出钱，谁还能支持你们有这么大一个房间？而且即使有了房间，谁来讨论？还不就是拿着别人的paper，试图找点可以改进的地方，或者就讨论哪个会议好发paper。Common Room只是一个形式，只要有人感兴趣，随便找个茶馆也能讨论。问题就在于没有人有精力有心情进行真正的讨论，制度决定一切。我们无能为力。我觉得自己一个学生力量太小，曾经试图找大师帮忙。我找到Andy Yao，述说我的苦衷。结果他对我说：“别试图去改造环境！你没有这个能力，连我都没有！改造好你自己就不错了。&quot; 改造好我自己，可是怎么改？所以我决定先换一个环境，到一个真正搞研究的地方去体会，去学习。</p><p style="margin:0px 0px 20px;padding:0px;">其实我不后悔进入川大，不后悔来到清华，珍惜一切的历史，因为没有它们，我也许就不是现在的我，有着自己想法的我。我也许就在安逸的生活中变得堕落。它们不完美甚至给我痛苦，但是我还是珍惜，珍惜这里的朋友，这里的一草一木。也许这就叫做爱。我会变得更好，我会挂念我的满目苍夷的祖国母亲。我会回来告诉你我学到的一切，我会给你和其他儿女真正的幸福，一定的！</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1067"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47a172" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">对博士学位说永别</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">经过深思熟虑之后，我决定再次“抛弃”我的博士学位。这是我第三次决定离开博士学位，也应该是最后一次了。这应该不是什么惊人的消息，因为我虽然读博士 10 年了，可是我的目标从来就不是博士学位。我在寻找更重要的东西，而且那个东西已经被我找到了。所以我的“博士生涯”其实完成了它的使命，基本上可以圆满结束了。</p><p style="margin:0px 0px 20px;padding:0px;">　　如果你从我之前的博文判定我现在生活在我所向往的环境中，那么你就误会了。我学到了我想要的东西，但是却发现学术界不再是我向往的地方。相反，它阻碍了我的前进。很显然，博士学位这个东西其实已经被学校和学术界作为利用廉价劳动力的“无形枷锁”。你想要“博士”的头衔，那么就廉价给我们干活吧，能出论文的就出论文，能写代码的就写代码。我根本不需要“博士”这个头衔来显示自己的价值，所以我抛弃学位，离开学校，离开学术界，是一点都不心痛的。<strong style="font-style:normal;font-weight:bold;font-size:100%;">　　</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">思想的监狱</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　如果你以为学术界意味着思想的解放，对真知的无私分享，那么你就错了。涉猎不深的人往往有一种美好的幻觉，觉得老师都是在无私的传授知识。可是等你深入到一定程度，就会发现其实没有人对于知识是无私的。这对世界顶尖的科学家们也不例外，他们“分享”给你的东西，往往是一堆琢磨不透的符号和公式，他们提出一堆可怕的术语来吓唬你。他们告诉你的只是思维的“结果”，而不是思维的“方法”(也就是所谓“直觉”)。等你通过自己的独立思考得到同样的东西，却发现这些大师们其实一直把直觉隐藏在很深的地方，故意的让你知其然而不知其所以然。他们甚至会诋毁直觉本身的价值，试图让你相信他们想出那些公式没有通过使用直觉，试图让你相信只有那些吓人的公式，定理和证明才是可靠的，而直觉是不可靠的。可是真正的直觉却是非常强大的，只要得到了它，你就可以完全的理解那些公式，而且会知道它们是怎么来的，甚至发现里面存在的问题，想出新的公式。</p><p style="margin:0px 0px 20px;padding:0px;">　　然后你就会恍然的发现，你曾经认为的“思想的天堂”，其实是“思想的监狱”。你会发现你心目中的很多大师们其实不是真正的科学家，而是政治高手。你会发现身边有很多人其实是故意在你面前提起一些术语，以此来显示自己的“高深”。当你直言不讳的道出这些东西背后的秘密，他们就不说话了，然后就对你怀恨在心，希望你早点消失。当你给那些提出这些术语的大牛们发 email，试图核实自己发现的这些术语背后的直觉，他们会很快的停止回复你的邮件。当你试图从教授们口中得到这种直觉，他们会不耐烦的对你说：“你问这种问题有什么意义吗？这东西就是这样的！”这说明了什么呢？这说明他们害怕了。他们害怕自己的地位受到威胁，他们害怕这种直觉一旦被大多数人掌握，他们就不再是高高在上的“学术权威”了。人们就会说：“那个东西其实不过是……”</p><p style="margin:0px 0px 20px;padding:0px;">　　这就是我这些年来所亲身经历的。我的同事们其实都不知道，他们所景仰的大师们提出的高深的理论，好些已经在我心目中被默默的“杀死”了。对我来说，它们不过是用一堆吓人的数学公式，翻来覆去的表达一些用几句话就可以说清楚的东西，而且它们好多其实已经被另外的东西所超越。所以大师们常做的一件事就是招收“门徒”，只要有人愿意做他们的接班人，把自己的工作“基于”他们的理论，他们提出的空洞的概念就可以一直存活下去，而他们就可以保持自己的地位。所以你就发现一些可笑的现象，本来一个新概念跟某个老概念没有关系，却被生拉硬拽在一起。本来一个概念可以被独立的理解，却被牵扯到一堆的老概念中，被搞得无比复杂。</p><p style="margin:0px 0px 20px;padding:0px;">　　这就是为什么我曾经提到，我经常用两个星期的时间就“灭掉”了某些领域长达 20 年的研究。这并不说明我是天才，这只是说明很多人在玩弄学术的把戏，而我看透了他们的把戏。看透了这些把戏并不能带来实际的效益，却可以让我自己节省下时间来解决真正重要的问题。但是我看不到学术界在这方面有任何改进的希望。所以，为了思想的自由，我不能生活在学术界。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">论文的游戏</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　我曾经以为我的专业（程序语言）是计算机科学里面论文水分最少的地方，但是其实并不是这样的，天下乌鸦一般黑。程序语言专业的论文与其它专业唯一的区别是，这个领域的人玩的把戏更加巧妙。这些论文动不动就触及 Church，图灵这样的人物提出的概念，所以就算里面没有任何新的内容，你早就被吓倒了，就别提看出里面的把戏。可是由于我看穿了一些核心概念的本质，所以经常浏览一些论文都发现其实没有任何新东西。这些论文有些甚至来自某些本领域众所皆知的“巨星”。由于他们地位显赫，这里我就不点名冒犯了。</p><p style="margin:0px 0px 20px;padding:0px;">　　很常见的一个套路就是，把一些很简单的“程序”用一堆“数学符号”改头换面写出来，把它们叫做“逻辑”或者“类型系统”。人们都崇拜数理逻辑，因为他们看不懂那一堆的符号和推理规则。可是经过自己的努力，我却看透了很多逻辑学家的把戏。我也可以玩这种把戏，我知道如何设计出新的逻辑。可是我也知道其实我们并不需要这些逻辑，所以我从来不为此发表论文。可是这样的关于“程序逻辑”的论文，仍然频繁的出现在最高档次的学术会议。一眼就知道他们在干什么，让我觉得非常无聊。</p><p style="margin:0px 0px 20px;padding:0px;">　　上个学期，我跟导师做了一个学期的研究，内容是关于“类型系统”。说是“跟导师”，但是其实他只起到绊脚石的作用。他不但没有真正的参与讨论，而且明显的对于我深入的发现有抵触情绪，并且不断的打击我。我用于“说服”他所使用的精力，比我用来研究的精力还要大好几倍。到头来我却发现，原来他根本没有听我在说什么！我总是发现一些复杂的类型系统的功能，要么就是完全不可能实用，要么就是可以用已有的更简单的方法实现。所以这些发现，虽然从实际意义上“杀死”了好几个长达几十年的领域，把它们归并为同一个非常简单的东西。也就是说，这些发现消灭了一些不必要存在的东西，而没有带来任何“新东西”。所以他总是对我说：“你的这些想法有什么用吗？”然后我才发现，原来他所要的，并不是深入的理解，而是别的东西。这个“别的东西”，当然就是论文和经费。很显然，导师们只是把学生作为可能给他带来论文和经费的人。他们更喜欢那种看不透事物本质的，对什么“新概念”都持手舞足蹈态度的学生。因为这些学生可以很快的写出一些看似高深却没有真东西的论文，然后从 NSF 等研究机构要到钱。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以说，深入本质的认识，其实在学术界是不受尊重的。因为深入的认识往往是无比简单的。如此简单的东西，又怎么拉得到经费呢？</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">政治的泛滥</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　我可以不谦虚的说，我是这里最好的学生。我身边的同学，没有一个可以超越我所能做到的事情。而他们能做的事情，却没有一件是我不能做的。在 Dan Friedman 的两门高难度的课程都得到 A+， 在 R. Kent Dybvig 的 Scheme 编译器课程得到A+，并且在某种程度上超越了他们。在两个星期之内，完全凭自己的思考写出正确的 CPS 变换（10多年的研究成果），以及 ANF 变换（我导师的最重要成果）。多次在两个星期之内，“灭掉”某些领域 20 多年的研究。对很多东西有自己独到深入的见解。在工程上有Google 的那个项目，以及我自己的一些项目，……</p><p style="margin:0px 0px 20px;padding:0px;">　　可是这所有的一切，都没有让我受到同行们的尊敬。相反，由于我喜欢说真话，他们恨我又怕我。他们都怕把自己的东西给我看，因为我总是能很快的道出它们的本质。那些精于玩弄政治的人，显然更加得到人们的赏识。我本来不想把这些“业绩”摆出来的，实际上这些事情我一直以来都没有在同学面前提起过。可是显然，在 Friedman 和 Dybvig 的课程上挣扎不堪的同学，在某些会议发过一点鸡毛蒜皮文章的同学，现在很是趾高气昂，他们当然希望别人都不知道我的优秀。</p><p style="margin:0px 0px 20px;padding:0px;">　　可是我没有告诉他们的实在是太多了。他们的论文里面的内容，其实好些是我几年前就得到了的结果，只不过我懒得为这些鸡毛蒜皮的东西写论文。记得有一次，几个 Friedman 课上的同学想做一个暑期项目，试图改进 miniKanren (Dan Friedman 设计的逻辑语言)的效率。那个时候我已经重新实现了 miniKanren，并且独立的加入了一些扩展的功能，比如 constraint logicprogramming。我一听到他们这个计划，立即就告诉他们，miniKanren 所使用的 substitution 的数据结构是 associationlist，查找时间是线性的，显然效率很低。使用另外一种“函数式数据结构”，比如函数式的平衡树就会好很多。可是当他们听到这些的时候，居然保持了一种可怕的沉默，完全把我的话忽略了，就像我并不存在于他们面前！一年多之后，他们发表了一篇论文，里面的基本内容就是我告诉他们的那些话。当然，署名里面没有我。我根本不在乎这么小的想法，我本来就觉得他们根本不应该为此写论文。可是一点谢意也没有表达，倒觉得是他们自己了不起，真是让人难以接受。</p><p style="margin:0px 0px 20px;padding:0px;">　　另外还有好几次类似的情况，我都不想说了。后来我才从一个同学口中得到一些真正的信息。他说，某些人喜欢在听到别人好的想法的时候，进行故意的打击，或者莫不关心的样子。等别人对他们自己的想法失去兴趣之后，他们却把他的想法拿出来署上自己的名字发表。这种事情就曾经发生在他的身上。他的导师一直打击他，以至于他写出来的论文两年都没有发表。等他决定离开之后，却发现自己的想法被导师和另外一个人发表了。没有署上他的名字。</p><p style="margin:0px 0px 20px;padding:0px;">　　这是对知识的公然的盗窃甚至抢劫！这也是我越来越不喜欢跟人讨论的原因，因为很多人得到那些想法，就会想玩弄一些花招把它们据为己有，以此出名，却连个谢字都不说一声。我看到这种现象不只存在于我的身边，而且存在于整个学术界。有这样的政治和勾心斗角，我留在这里还有什么意义呢？我在这里，以至于整个学术界，其实已经没有什么值得合作的人了。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">何去何从</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　当然接下来我需要思考的是，我应该做什么。显然，我所学到的知识可以轻而易举的给我带来高薪的工作。可是我也知道，我知道的这些东西，其实归根结底就是那么几个小把戏。所以我更愿意探索更加广阔的世界，学会新的东西，找到真正值得合作的人，创造真正的价值。另外，我也会逐渐把我知道的这些“把戏”以直观而容易理解的方式公诸于众。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1073"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_4f629c" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">“解决问题”与“消灭问题”</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">一直以来，人们都重视“解决问题”的能力，却忽视了另一种重要的能力：“消灭问题”的能力。各种各样的竞赛，分数和排名，让很多人从小就片面的认为，能“解决问题”的人，就是最厉害的人。拿到一个问题就埋头求解，很少考虑这问题到底有什么意义。这种呆板的思维方式，不仅存在于低级的“应试”和“解题”过程，而且蔓延到了很多艰深的研究领域。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">如果你仔细观察就会发现，很多“难题”，其实是“人造”出来的，而不是“必然”的。它们的存在，往往是由于一些早期的“设计错误”。人造的东西里面往往有设计上的错误，如果你把这些东西看成是不可改变的东西，那你就会遇到很多不必要的问题。打个比方，如果当初轮子被设计成方形的，而没有人质疑这样做的“必要性”，那么也许人类早就因为“能源问题”而灭绝了。有点夸张，但它却形象的说明了，为什么错误的设计会导致不必要的难题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">其实如果我们转换一下思路，或者改变一下“设计”，很多问题就可以不解自消。这就是我所谓的“消灭问题”的能力。这种“消灭问题”的能力，表面上容易其实难，有点像脑经急转弯，所以经常受到人们的忽视。看到一个问题轻而易举的消失了，总有人满不在乎的说：“这个容易。我也能做到。” 可问题就在于，你怎么没想到？说这种话的人，完全没有意识到，他们的思维里面其实缺少了非常重要的东西。由于喜欢炫耀自己的“头脑暴力”，他们经常解决（甚至制造）错误的问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以，在解决问题之前，我们应该先问自己三个问题：</p><p style="margin:0px 0px 20px;padding:0px;">1. 这问题是否真的“存在”？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">也许你已经看出来了，很多问题，即使众人都认为它存在，其实也可能是不存在的。在这一点上不能相信任何人或者机构，不管他有多么的“权威”。就像小马过河的道理，只有靠自己的实践。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">2. 如果解决了这个问题，会给我和他人带来什么实际的好处？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">世界上不存在“永远”，也不存在“无穷”。如果一个“科学算命家”花100年才能算出我的未来，那我还不如坐等“未来”的到来。所有的人，都不过是来这世界上做短暂的旅行。所以，问题的答案，应该能在合理的时间之内给人带来实际的好处。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">3. 这问题是否可以在简单的改变某些“设计”或者“思路”之后，不复存在？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多问题的“存在”，其实是因为人们的“思维定势”。他们看不到问题的“根源”和因果关系，而是经常在下意识里假定某种“先决条件”（A）的存在，然后坚定不移的相信由此“导致”的问题（B）的存在，如下图：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">            A -----&gt; B</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然后，他们开始呆头呆脑的解决 B，完全忘记了质疑 A 存在的必要性。他们从来没有想过，如何消除 A，或者切断 A 与 B 之间的关系。他们没有发现，一旦这前提 A 不复存在，问题 B 就可以不解自消。</p><p style="margin:0px 0px 20px;padding:0px;">对这一点，我想起一个有趣的故事。有人在饭桌上给大家出了一道“难题”，要他们把自己盘子里的鸡蛋立起来，最后只有一个人做到了。这个人把蛋壳打破了。所有其他人都没有想到这个做法，却说他“犯规”。可是应该检讨的其实应该是他们自己，因为出题的人根本没有说不能打破蛋壳，他们却对此做出了错误的假设。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我经常发现计算机科学界存在这样的问题。研究了几十年，结果到最后才发现，辛辛苦苦解决的问题，其实包含了错误的假设。如果换一个角度来看，或者稍微改一改设计，这问题就基本不存在了。其中一个例子，就是编译器里面的“语法分析”（parsing）问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">语法分析成为一个问题的原因，就在于很多人错误的以为程序语言应该有复杂的语法。正是这些复杂的语法，造成了这个问题研究了很多年，仍然没有一个很好的解决方案。可是一旦语法设计被简化（比如像 Lisp 那样），语法分析就变成一个非常容易的问题。实际上计算机系统（比如 Unix）里的很多问题都是由此引发的，想要利用字符串来进行数据交换，却又设计了一些非常不方便的“数据格式”。简单的语法设计，会让这些问题一并消失掉。关于这个问题，我不想重复发文，细节请见另一篇博文《<a href="http://blog.sina.com.cn/s/blog_5d90e82f0101irad.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">谈语法</a>》。</p><p style="margin:0px 0px 20px;padding:0px;">爱因斯坦说“想象力比知识更重要”，也许就是这个道理。没有想象力的人，经常钻牛角尖，走死胡同，忘记了自己其实还有另外的路可走。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">（后记：在原文里面我举了“P=NP?”问题作为“消灭问题”的例子。但是仔细一想，其实它不是一个好的例子。要“消灭”的问题需要首先存在，并且有必要消灭。“消灭问题”并不意味着光说不做，相反，它可能包含巨大的工作量。“P=NP?”不符合“被消灭问题”的范畴，因为它其实基本不是一个问题，所以连消灭的必要都没有。我会整理之后发另外一篇博文，专门讨论“P=NP?”的问题。）</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1074"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47beeb" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">理论是围城</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">发了<a href="http://news.cnblogs.com/n/157058/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">上一篇博文</a>之后，很多人来信表示慰问。在此深表感谢。回想这么多年来的经验，真是有点乾坤扭转的感觉。曾经认为是错误的东西，后来又觉得是正确的，过一段时间它又好象确实是错误的。真是捉摸不定。</p><p style="margin:0px 0px 20px;padding:0px;">　　就拿之前遇到的问题来说吧，其实就是一个对待理论的态度问题。人们往往对数学一类的“纯理论”学科充满了敬畏和盲目的崇拜，看到别人论文里出现一堆数学公式就觉得很了不起。可是殊不知，理论的东西作假的可能性其实比“coding”这种“低等活”要大很多。程序的代码都是可以运行的，直接一跑，谁快谁慢，谁正确谁错误，经常都一目了然。可是理论的东西却说不准，里面如果有错误甚至“抄袭”，就算你是顶尖的研究者，都不一定看得出来。</p><p style="margin:0px 0px 20px;padding:0px;">　　这就是为什么某些完全不可能有实用价值的理论能够在某个时期风靡学术界，甚至召开自己的会议。举一个例子就是上学期被我判“死刑”的一种类型系统，叫做 intersection types，到现在都还存在它的 workshop（通常跟 <a href="http://www2.informatik.hu-berlin.de/lics" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">LICS 会议</a>在同一个地方召开）。可是这个类型系统却几乎是完全不能实用的，因为它的类型检查需要的时间跟运行这个程序是一样的。类型系统的初衷就是在程序运行之前迅速的查找出错误，如果你花跟运行这个程序同样多的时间来检查它，那么你还不如就直接运行这个程序！我很惊讶的是人们花了 20 多年才发现这个问题，而且在发现了这个问题之后还继续研究这个东西。幸运的是，我只在上面花了两个星期不到就实现了这个系统，并且发现了这个问题。后来看了著名的 Benjamin Pierce 的博士论文，就是关于 intersectiontypes。铺天盖地的公式，其实基本没有任何意义。后来又跟这领域的某头号大牛（不是 Benjamin Pierce）发 email，试图得知这个系统是否能够实用。来回一趟之后，就再也没有了消息 :)</p><p style="margin:0px 0px 20px;padding:0px;">　　“抄袭”的判定在理论的领域也很纠结。到底谁的思想是原创的？什么样的行为算作抄袭？这是无法说清楚的。很多当今程序语言界最时髦的话题，其实在几十年前早就有人提出来了。很多时候做理论的人都在“重复发现”以前的结果，到头来很难说清楚他们的论文里有什么“新东西”。你甚至不可能跟他们“理论”。如果你说理论A跟理论B，实际效果是完全一样的，你有什么证据呢？有趣的是，就算你觉得是几句话就说得清楚的事情，它们的支持者也会视而不见，要求你用“数学证明”的方式证明你的说法。可是某些人的公式和证明是如此的丑陋，就像一个人写的程序代码毫无章法。你愿意花功夫去证明他的理论跟另一个是等价的吗？所以你就懒得去跟他们说了。你就说，你们信就信，不信就算了。</p><p style="margin:0px 0px 20px;padding:0px;">　　其实学术界最严重的问题就是总是要求“新”的东西，“独创”的东西。研究了快一百年的领域，每年有那么多的会议，哪里可能有那么多新东西啊。所以大家就开始给老的概念起新的名字。</p><p style="margin:0px 0px 20px;padding:0px;">　　理论就像一个围城，外面的人想进来，里面的人想出去。其实我最想做的事情是做一些实际对人有用的，工程性质的东西。当然，之前学会的理论很可能在里面会起到重要的作用。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1082"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bddf" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">为什么需要正则表达式</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">学习Unix最开头，大家都学过正则表达式(regexp)。可是有没有人考虑过我们<strong style="font-style:normal;font-weight:bold;font-size:100%;">为什么</strong>需要正则表达式？</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">正则表达式本来的初衷是用来从无结构的字符串中提取信息，殊不知这正好是Unix的缺陷所在。Unix用无结构的字符串来表示数据，导致了诸多复杂的基于regexp的软件的诞生。sed, AWK, Perl, ... 都是为了同样的目的来到这个世界上的。如果不是因为Unix用字符串来表示数据，我们就会拥有按数据结构类型的直接存储，而不需要折腾regexp。正则表达式有它自己的价值（针对自然语言），但是我们其实不需要把它应用到程序语言和操作系统里面。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">正则表达式本身用一个字符串来表示，这带来另外一些问题。因为正则表达式的本质不是字符串，而是一个数据结构。学过计算理论的人可能知道这个数据结构叫做NFA（nondeterministic finite automaton，非确定性有限自动机）。所有的数据结构应该由程序语言本身来表示，就像用Java构造一个对象用 new ClassA(&quot;a&quot;) 一样。但是正则表达式强迫你把这个简单的构造函数调用写成一个字符串。所以在这个比方之下，你得写成 &quot;new ClassA(\&quot;a\&quot;)&quot;。这样当你想要组合这些表达式的时候就发现，正则表达式几乎都是不可组合(compose)的。你几乎不可能不能把两个regexp的变量A和B安全拼接成一个，比如用Java的字符串拼接A+B。因为你不知道这两个字符串拼在一起之后，那些稀奇古怪的符号会出现什么交叉反应，使得最后的识别的东西根本不是你想要的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在正则表达式中，由于正则表达式本身的构造函数与数据本身合并到一起，我们不得不对某些“特殊字符”进行escape。这些特殊字符，其实是用来描述NFA的记号，它们属于更高一层的<strong style="font-style:normal;font-weight:bold;font-size:100%;">语言</strong>。可是在正则表达式里，它们与NFA节点里的字符混为一谈。比如很简单的一个block comment的正则表达式，却要写成这个样子：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">&quot;/\\*([^\\*]|[^/])*\\*/&quot;</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">显然这样的表达式很容易出错。 如果我们用程序语言的表达式来构造这个表达式，它应该是这样：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://s14.sinaimg.cn/orignal/5d90e82fgc042da2bdf2d" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgc042da2bdf2d&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/>
在这个我自己设计的Scheme表达式里，以@开头的标识符都是构造函数。其中 @...是构造sequence，@* 是构造一个zero-or-more的匹配，@!构造一个否定匹配。这个表达式是说：“以 / * 开头，接着零个或者多个不是 * / 的字符，最后接着一个 * /。这样一来清晰明了，什么表达式在什么“层次”都很清楚，不需要什么反斜杠escape，而且这样的表达式可以compose。比如:</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://blog.photo.sina.com.cn/showpic.html#url=http://s14.sinaimg.cn/orignal/5d90e82fgc042e6eb28bd" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgc042e6eb28bd&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;"><span>定义这三个表达式之后，我们之后可以用像 <a href="http://yinwang0.lofter.com/post/183ec2_47bddfmailto:(@..." style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">(@...</a> reg1 (@or reg2 reg3)) 这样的表达式来连接3个不同的表达式，构造出更大的表达式。这样的构造可以无限的扩展。从这里以及以往的经验，我总结出一个普遍适用的程序设计的教训：尽量不要把多个层次的语言“压缩”到一层。我们也看到正则表达式与“Unix哲学”有很大关系。我没有考古，所以不知道孰先孰后，但是它们肯定有直接的因果关系。两者都是Unix复杂性的来源。</span></p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1088"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c55fa" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Hindley-Milner 类型系统的根本性错误</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">之前的一个时间，我曾经公开过这样一段<a href="http://www.tudou.com/programs/view/GU9GtDuWSMk/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">幻灯片</a>，它是2012年10月的时候，我在 Indiana 大学做的最后一次演讲。由于当时的委婉，我并没有直接说出这些结论的重要性。其实它揭示了 ML 和 Haskell 这类基于 Hindley-Milner 类型系统的语言的一个根本性的错误。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这个错误来源于对一阶逻辑的“全称量词”（universal quantifier，通常写作∀）与程序函数之间关系的误解。在 HM 系统里面，多态（polymorphic）的函数能够被推导为含有全称量词的类型，比如 \x-&gt;x 的类型被推导为 ∀a.a-&gt;a，但 HM 系统决定这个全称量词的位置的方式，却是没有原则的。这就导致了类型变量（type variable）的作用域（scope）的偏差。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我的研究显示，这个错误来源于 HM 系统最初的一项重要的设计，叫做 let-polymorphism。如果右边的函数是一个多态的函数，比如：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">let f = \x-&gt;x in</p><p style="margin:0px 0px 20px;padding:0px;">  ...</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">let-polymorphism 总是会把全称量词的位置确定在 let 的“=”右边。然而这是一个非常错误的做法，它的错误程度近似于早期的 Lisp 所采用的 dynamic scoping。这样做的结果是，全称量词的位置会随着程序的“格式”，而不是程序的“结构”，而变化。至于什么是 dynamic scoping，你可以参考我的这篇<a href="http://blog.sina.com.cn/s/blog_5d90e82f0101jo6r.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为了弥补这个错误，30多年来，许多的人发表了许多的论文，提出了很多的“改进措施”，比如 value restriction，MLF，等等。但是我的研究却显示，所有这些“改进措施”都是丑陋的 hack。因为他们没有看到问题的根源，所以他们的方案只对一些特殊情况起作用，而不能通用。为此，我可以轻而易举的写出正确的程序，而让它不能通过这些类型系统的检查，比如像我这篇英文<a href="http://yinwang0.wordpress.com/2012/03/05/ghc-type/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">博文</a>所示。如果你看到了问题的根源，就会发现 HM 系统的这个错误是无法弥补的，因为它触及了 HM 系统的根基。为了根治这个问题，let-polymorphism 必须被去除掉。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我为此提出了自己的解决方案：在 lambda 的位置进行“generalization”，也就是说把 ∀ 放在 lambda 的位置，而不是 let。这样一来 let-polymorphism 就不存在了。但是这样一来，HM 系统就不再是 HM 系统，因为它的“模块化类型推导”的性质，就会名存实亡。由于类型里面含有程序的“控制结构”，这个类型系统表面上看起来是在进行“模块化类型检查”，而本质上是在做一个“跨过程静态检查”（interprocedual static analysis）。也就是说，模块化的类型推导，在 HM 这样的没有“类型标记”的体系下，其实是不可能实现的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">为了达到完全通用的模块化类型检查，却又允许多态函数的存在，我们终究会需要在函数的参数位置手工写上类型，这样我们就完全的丧失了 HM 系统设计的初衷。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1089"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47a118" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Cornell 感受</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">Cornell 感受(1)<br/>早就有人问起我的学习情况，问我有没有找到理想的研究环境。我却总是弄一些小动物，要不就是好玩的内容在这上面。真是惭愧，因为一直觉得自己还没有什么发言权，一直觉得是不是自己搞错了。不过来了 Cornell 已经一年半，也可以说一下对美国教育的感想了。我的感觉可能是错的，或者局限于我的专业或者学院。不过总的感觉就是，美国教育其实很大部分是商业性的应试教育，而外国研究生基本上是用来骗本科生钱的廉价劳动力。本科生能学到的真东西，相对于他们交的学费，也是少而又少的。巨大的作业和应试压力，已经剥夺了学生思考的自由，真正潜心研究的环境是很难求的。<br/><br/>还是让我慢慢的回忆一下这一年半的经历吧……<br/><br/>2006 年的8月3号，我们经过20多小时的飞行，来到了 Ithaca。面对这个小山村，我们是非常新奇的。这里的夏天是如此的美，到处是绿草，到处是瀑布，自来水都是可以直接喝的，房间里全都有地毯。貌似一切都是那么的美好，人都是那么的有礼貌。刚走到人行道边上，路上的汽车就缓缓停下来，让行人过马路。路上遇到一个不认识的人，他会莫名其妙跟你打招呼，说： “Isn't it beautiful?” 总之 Ithaca 的美是不用多说了的，居民的总体素质还是比较高的。不过很快，这种新鲜感就随着在 Cornell 遇到的各种事情消失了。Cornell 给我的第一印象就是非常差的。<br/><br/>其实正式开学是在20多号，我们之所以这么早的来，原因是需要参加一个所谓 ITADP Summer Program。ITADP 也就是 International Teaching Assistant Development Program，也就是对 TA 的培训。这个培训是强制性的，不参加就不能做 TA，也就得不到经济支持了。我们连时差都还没倒过来就参加这么一个课程，每天从上午9点到下午3点。我也不记得申请 Cornell 的时候他们提到过这个东西，而是在接受了 offer 之后才收到一封信，说要所有外国TA参加这个培训。没想到 Cornell 的印象就从此在我心中一落千丈。<br/><br/>首先，经过培训的，或者仍然在接受培训课程煎熬的中国同学，我们都痛恨这个东西。我们得出的一致结论就是，这个培训对提高英语水平的效果是微乎其微的，纯粹就是浪费时间和精力。夏天的培训只有一个星期，分小班进行，在培训的末尾老师会进行评定。如果不通过，就需要强制性的修一期的课，叫做 EDUC 578。EDUC 578 期末会有一个评定，如果不通过，就需要修 EDUC 579。接着是 EDUC 580, ... 课号换了，但是课程的内容基本没有换，不断反复，无聊之极。总之，这个课耗费大量精力，影响学业。中国学生大多都对这个课程叫苦不迭。很多人都把牢底坐穿了，上了两年还没有通过。如果真能留下来，那还算不错的，各个系情况不一样。我认识有一个电子系的博士生在第一期评定没有通过就被取消了经济支持，他只好自己掏钱转成了计算机系的硕士。<br/><br/>再来看看这个课程的性质呢？我还深刻的记得在 Summer Program 的时候，ITADP 的主要负责人给我们讲的话：“You know why you are here? ... You know how important the undergraduate students are to us? You might even find a prince or princess in your class one day, from another country! ” 那个语气呀，就跟大老板差不多。我们是Ivy！是贵族学校！这不是很清楚的暴露了我们的用途吗，是为本科的“公主”和“王子”们服务的。后来我听说，的确是这样的，这个 ITADP 就是在本科生家长的强烈要求下成立的。而王子和公主们，可能还是没有得到他们想要的。<br/><br/>这个课是不可以旷的，旷课两节就会 fail 掉，从而取消 TA 的资格。这个课也是不可以迟到的，否则老师在下课的时候会警告你，要是再迟到就会给你 fail。这个课的规则是如此的严格，真是非常特殊。没有任何专业和非专业的课程有如此的军事化管理。再来看这个课程是什么内容。其实主要的内容就是告诉大家什么是好的 teaching，什么是坏的，大多都是废话。我记得在讨论教育的时候我提到，一个好的老师应该引导学生去思考，告诉他们知识是怎么获得的，而不是把知识灌输给学生；应该减轻学生的压力，鼓励他们创新。结果老师对我的这些说法很木然。很显然我的说法，她丝毫没有预料到过。她所期望的只是写黑板时字不要写得太小之类的。<br/><br/>然后我们做很多所谓的 microteaching 练习。microteaching 就是在课堂上对其他参加课程的同学讲授一些自己专业上最基本的常识。拿我来说吧，我第一次讲的内容就是二叉树。这个练习有一定的好处，就是让我明白了其实很多时候老师认为学生明白了，其实老师只知道自己明白了，而不知道学生其实是不明白的。但是我后来发现，对于 Cornell 的本科生，基本是没法知道他们是否明白。不论是我讲课，或者我和本科生一起听课，很普通的情况是这样：老师经过一段精彩的讲述之后，问：“你们明白了吗？”没有人吭声。再问：“有人没有明白的请举手。”也没有人举手，一片寂静。老师无可奈何，只好继续讲下去。总之，大家都以为别人都听懂了，都很害怕别人笑话自己不懂，感觉非常像国内的高中。不过总的说来，microteaching是很费精力的。讲一两次还行，反复的做就很烦了。课程的另一个内容是对自己的话进行录音，每次10分钟以上，一个星期三次，必须及时提交给老师评语。这个对于英语有一些帮助，不过费时间太多了，为了那10分钟，经常需要准备一两个小时。而且经常找不到有趣的话题，所以觉得很无聊。<br/><br/>因为第一期的时候，系里有一个教授碰巧给我一个 RA ，所以我没有参加 EDUC 578 （当然，像所有中国学生一样，我夏天的评定是没有通过的），所以第二期的时候我才被迫参加了这个课程。每个星期这个课程都耗费我太多的精力，以至于我在第二期的时候选的唯一的一门理论课后来没有精力完成。一方面这也是由于教课老师的问题，他只会在黑板上写定理……证明…… 所以后来我drop掉了那门传说中的牛人讲的课程，导致第二期就只修了 ITADP 的课程。一个系里都不认为是课程的课程，就这样占用了我一学期。<br/><br/>幸亏我表现还好，每次都貌似很积极的样子，很配合老师，其实心里在骂这个 program。同时我也比较同情老师，因为她也是打工的，讲了这么久这个课也觉得有点无聊了，虽然她没有直说 ;-) 所以很幸运的在期末勉强通过了评定，以后就再也不用上那个可怕的课了。不过还有不知道多少中国学生仍然在经受 ITADP 的煎熬……<br/></p><p style="margin:0px 0px 20px;padding:0px;">Cornell 感受 (2)<br/>再谈一下本科教育吧，因为我感觉“王子”和“公主”其实挺苦的，跟在中国上高中差不多。因为Cornell本科生太多，有两万多人，而每个人都可以选修任何一门基础课，所以经常人满为患。我第一学期做 CS 100m 的 TA。100m是一门最基础的编程课，前一半讲授 Matlab，后一半讲授 Java。天知道 Matlab 怎么被当成“编程语言”来教了，以至于在后一半的时候学生还经常继续被 Matlab 误导，用那种思维方法来写 Java。不过现在100m已经去掉了Java的内容，变成了纯 Matlab 的课程。要学 Java 就去上 100j.<br/><br/>那一期总共登记的学生有280多个，课堂我第一堂课去过一次，教授让我们去跟学生们见个面。结果只去了两个TA，一个大礼堂坐满的人，教授差点都不知道我在那里。学生们都很懵懂，所以老师讲什么基本上没有什么关系。因为基本没有什么互动，所以感觉还不如用个摄像机拍下来，这样学生一遍看不懂还可以倒回去再看。不过我知道他们不会那么做的，要不然大家都不来上课了。<br/><br/>我们总共有9个TA和十来个本科 consultant，负责批改作业，试卷和答疑。编程作业是两星期一次，期中考有两次，期末考一次。每次作业提交之后，大家都会马不停蹄开始组织批改。那三次考试就更加军事化了，每次都是当堂闭卷考试，一个大礼堂楼上楼下全都坐满。考考考啊…… 监考完之后，大伙就按姓名字母把试卷分批收上来，然后“押送”到一个房间开始流水作业。在黑板上画一个流程表，改完一个字母就在上面画一个X。一般会从晚上9点半一直弄到半夜一两点钟，才能完成任务。<br/><br/>我改作业都很慈悲，不忍心为了一点小错就扣分。如果思路是对的，我就不会扣很多分。但是不是所有 TA 都这么好，有些特别刁钻，会想方设法把分扣下来，以显示自己比别人懂得多。如果要求重判分数，还需要提交书面申请。很多高年级课程居然还会课堂点名，有些每星期都有一次作业，需要在课堂当堂交作业，如果迟交就会被拒绝接受，没有商量。有些交作业需要把每道题分开放在不同的信封里，这样他们方便分给TA，每个人只改一道题。一切都机械化了。所以本科生基本上生活在作业，考试与分数的恐惧之中。这样的环境下，所谓的西方 critical thinking，只不过是一个笑话。这种待遇是我在川大都没有遇到过的，现在比较一下，川大才算是真正的大学呀 ;-)<br/><br/>每学期中和学期末都有学生对 TA 的评定。会对各方面进行打分。不过从来没见过这个分数起了什么作用就是。另外据说 Cornell 对本科生有各种奇怪的隐性收费的做法以增加收入，因为学校有很大的财政赤字。<br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1090"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47c086" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">最后一篇博文</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　　这段时间心里有话说，写了不少博文，可是最后发现，真正对人有价值的其实没有几篇。大部分不过是一个技术人员的无病呻吟。有句话说得好，我曾经为自己没有鞋而苦恼，直到我看见一个没有脚的人。</p><p style="margin:0px 0px 20px;padding:0px;">　　早上把《<a href="http://www.tianyabook.com/luxun/lh/002.htm" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">狂人日记</a>》拿出来看了一遍，发现其实国人并不需要我的博文，也不需要先进的技术，因为中国社会实质上正在再次沦为一个人吃人的社会。这个社会需要的书和文章，早在一百年前就已经有人写好了，我在这里凑个什么数。技术再好，有世界上最快的超级计算机，发射了宇宙飞船，有什么用呢？不要忘了，人活着不是为了技术，也不是为了国家的荣耀，人活着是为了自己。现在国人连放心的食物都没得吃，放心的房子都没得住，无论什么先进技术，其实都没什么用。中国需要的不是科学家和工程师，而是文化，法律和正义。一想起这些，就感觉不可承受之重，而这些，我都无能为力。</p><p style="margin:0px 0px 20px;padding:0px;">　　我不得不说，博客和微博，是传播愚昧最有效的工具。只看新浪博客和微博那些随处冒出来的低俗广告就知道。说的越多，做的越少，所以我不想写了。写了也是白写，看了也白看。只留下一篇博文《<a href="http://blog.sina.com.cn/s/blog_5d90e82f01018ge9.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">怎样写一个解释器</a>》，是我觉得唯一有价值的。</p><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">　　文章：怎样写一个解释器</strong>　</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">　　卖了好久关子了，说要写一个程序语言理论的入门读物，可是一直没有下笔。终于狠下心来兑现一部分承诺。今天就从解释器讲起吧。</p><p style="margin:0px 0px 20px;padding:0px;">　　解释器是比较深入的内容。虽然我试图从最基本的原理讲起，尽量让这篇文章不依赖于其它的知识，但是这篇教程并不是针对函数式编程的入门，所以我假设你已经学会了最基本的 Scheme 和函数式编程。如果你完全不了解这些，可以读一下 <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">SICP</a> </p><p style="margin:0px 0px 20px;padding:0px;">　　的第一，二章。当然你也可以继续读这篇文章，有不懂的地方再去查资料。我在这里也会讲递归和模式匹配的原理。如果你已经了解这些东西，这里的内容也许可以加深你的理解。</p><p style="margin:0px 0px 20px;padding:0px;">　　解释器其实不是很难的东西，可是好多人都不会写，因为在他们心目中解释器就像一个 Python 解释器那样复杂。如果你想开头就写一个 Python 解释器，那你多半永远也写不出来。你必须从最简单的语言开始，逐步增加语言的复杂度，才能构造出正确的解释器。这篇文章就是告诉你如何写出一个最简单的语言(lambda calculus) 的解释器，并且带有基本的的算术功能，可以作为一个高级计算器来使用。</p><p style="margin:0px 0px 20px;padding:0px;">　　一般的编译器课程往往从语法分析(parsing)开始，折腾 lex 和 yacc 等工具。Parsing 的作用其实只是把字符串解码成程序的语法树（AST）结构。麻烦好久得到了 AST 之后，真正的困难才开始！而很多人在写完 parser 之后就已经倒下了。鉴于这个原因，这里我用“S-expression”来表示程序的语法树（AST）结构。S-expression 让我们可以直接跳过 parse 的步骤，进入关键的主题：语义(semantics)。</p><p style="margin:0px 0px 20px;padding:0px;">　　这里用的 Scheme 实现是 <a href="http://racket-lang.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Racket</a>。为了让程序简洁，我使用了 Racket 的<a href="http://docs.racket-lang.org/reference/match.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">模式匹配</a>（pattern matching）。如果你用其它的 Scheme 实现的话，恐怕要自己做一些调整。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">解释器是什么</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　首先我们来谈一下解释器是什么。说白了解释器跟计算器差不多。它们都接受一个“表达式”，输出一个 “结果”。比如，得到 '(+ 1 2)之后就输出3。不过解释器的表达式要比计算器的表达式复杂一些。解释器接受的表达式叫做“程序”，而不只是简单的算术表达式。从本质上讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p><p style="margin:0px 0px 20px;padding:0px;">　　需要注意的是，我们的解释器接受的参数是一个表达式的“数据结构”，而不是一个字符串。这里我们用一种叫“S-expression”的数据结构来表示表达式。比如表达式'(+ 1 2) 里面的内容是三个符号：'+， '1 和 '2，而不是字符串“(+ 12)”。从结构化的数据里面提取信息很方便，而从字符串里提取信息很麻烦，而且容易出错。</p><p style="margin:0px 0px 20px;padding:0px;">　　从广义上讲，解释器是一个通用的概念。计算器实际上是解释器的一种形式，只不过它处理的语言比程序的解释器简单很多。也许你会发现，CPU 和人脑，从本质上来讲也是解释器，因为解释器的本质实际上是“任何用于处理语言的机器”。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">递归定义 (recursive definition)</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　解释器一般都是“递归程序”。之所以是递归的原因，在于它处理的数据结构（程序）本身是“递归定义”的结构。算术表达式就是一个这样的结构，比如：'(*(+ 1 2) (* (- 9 6)4))。每一个表达式里面可以含有子表达式，子表达式里面还可以有子表达式，如此无穷无尽的嵌套。看似很复杂，其实它的定义不过是：</p><p style="margin:0px 0px 20px;padding:0px;">　　“算术表达式”有两种形式：</p><p style="margin:0px 0px 20px;padding:0px;">　　1) 一个数</p><p style="margin:0px 0px 20px;padding:0px;">　　2) 一个 '(op e1 e2) 这样的结构（其中 e1 和 e2 是两个“算术表达式”）</p><p style="margin:0px 0px 20px;padding:0px;">　　看出来哪里在“递归”了吗？我们本来在定义“算术表达式”这个概念，而它的定义里面用到了“算术表达式”这个概念本身！这就构造了一个“回路”，让我们可以生成任意深度的表达式。</p><p style="margin:0px 0px 20px;padding:0px;">　　很多其它的数据，包括自然数，都是可以用递归来定义的。比如常见的对自然数的定义是：</p><p style="margin:0px 0px 20px;padding:0px;">　　“自然数”有两种形式：</p><p style="margin:0px 0px 20px;padding:0px;">　　1) 零</p><p style="margin:0px 0px 20px;padding:0px;">　　2) 某个“自然数”的后继</p><p style="margin:0px 0px 20px;padding:0px;">　　看到了吗？“自然数”的定义里面出现了它自己！这就是为什么我们有无穷多个自然数。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以可以说递归是无所不在的，甚至有人说递归就是自然界的终极原理。递归的数据总是需要递归的程序来处理。虽然递归有时候表现为另外的形式，比如循环(loop)，但是“递归”这个概念比“循环”更广泛一些。有很多递归程序不能用循环来表达，比如我们今天要写的解释器就是一个递归程序，它就不能用循环来表达。所以写出正确的递归程序，对于设计任何系统都是至关重要的。其实递归的概念不限于程序设计。在数学证明里面有个概念叫“归纳法”(induction)，比如“数学归纳法”(mathematicalinduction)。其实归纳法跟递归完全是一回事。</p><p style="margin:0px 0px 20px;padding:0px;">　　我们今天的解释器就是一个递归程序。它接受一个表达式，递归的调用它自己来处理各个子表达式，然后把各个递归的结果组合在一起，形成最后的结果。这有点像二叉树遍历，只不过我们的数据结构（程序）比二叉树复杂一些。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">模式匹配和递归：一个简单的计算器</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　既然计算器是一种最简单的解释器，那么我们为何不从计算器开始写？下面就是一个计算器，它可以计算四则运算的表达式。这些表达式可以任意的嵌套，比如'(* (+ 1 2) (+ 3 4))。我想从这个简单的例子来讲一下模式匹配(pattern matching) 和递归(recursion) 的原理。</p><p style="margin:0px 0px 20px;padding:0px;">　　下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果，正如上一节所示。</p><p style="margin:0px 0px 20px;padding:0px;">　　(define calc</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (exp)</p><p style="margin:0px 0px 20px;padding:0px;">　　(matchexp                               ; 匹配表达式的两种情况</p><p style="margin:0px 0px 20px;padding:0px;">　　[(? number? x)x]                      ; 是数字，直接返回</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(,op ,e1,e2)                        ; 匹配并且提取出操作符 op 和两个操作数 e1, e2</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([v1 (calce1)]                  ; 递归调用 calc 自己，得到 e1 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　[v2 (calce2)])                 ; 递归调用 calc 自己，得到 e2 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　(matchop                           ; 分支：处理操作符 op 的 4 种情况</p><p style="margin:0px 0px 20px;padding:0px;">　　['+ (+ v1v2)]                    ; 如果是加号，输出结果为 (+ v1 v2)</p><p style="margin:0px 0px 20px;padding:0px;">　　['- (- v1v2)]                    ; 如果是减号，乘号，除号，相似的处理</p><p style="margin:0px 0px 20px;padding:0px;">　　['* (* v1 v2)]</p><p style="margin:0px 0px 20px;padding:0px;">　　['/ (/ v1 v2)]))])))</p><p style="margin:0px 0px 20px;padding:0px;">　　这里的 match 语句是一个模式匹配。它的形式是这样：</p><p style="margin:0px 0px 20px;padding:0px;">　　(match exp</p><p style="margin:0px 0px 20px;padding:0px;">　　[模式结果]</p><p style="margin:0px 0px 20px;padding:0px;">　　[模式结果]</p><p style="margin:0px 0px 20px;padding:0px;">　　...  ...</p><p style="margin:0px 0px 20px;padding:0px;">　　)</p><p style="margin:0px 0px 20px;padding:0px;">　　它根据表达式 exp 的“结构”来进行“分支”操作。每一个分支由两部分组成，左边的是一个“模式”，右边的是一个结果。左边的模式在匹配之后可能会绑定一些变量，它们可以在右边的表达式里面使用。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">一般说来，数据的“定义”有多少种情况，用来处理它的“模式”就有多少情况。</strong>比如算术表达式有两种情况，数字或者 (op e1e2)。所以用来处理它的 match 语句就有两种模式。“你所有的情况，我都能处理”，这就是“穷举法”。穷举的思想非常重要，你漏掉的任何一种情况，都非常有可能带来麻烦。所谓的“数学归纳法”，就是这种穷举法在自然数的递归定义上面的表现。因为你穷举了所有的自然数可能被构造的两种形式，所以你能确保定理对“任意自然数”成立。</p><p style="margin:0px 0px 20px;padding:0px;">　　那么模式是如何工作的呢？比如 '(,op ,e1 ,e2) 就是一个模式（pattern），它被用来匹配输入的 exp。模式匹配基本的原理就是匹配与它“结构相同”的数据。比如，如果 exp 是 '(+ 1 2)，那么 '(,op ,e1 ,e2)就会把 op 绑定到 '+，把 e1 绑定到 '1，把 e2 绑定到 '2。这是因为它们结构相同：</p><p style="margin:0px 0px 20px;padding:0px;">　　'(,op ,e1 ,e2)</p><p style="margin:0px 0px 20px;padding:0px;">　　'( +  1  2)</p><p style="margin:0px 0px 20px;padding:0px;">　　说白了，模式就是一个可以含有“名字”（像 op, e1 和 e2）的“数据结构”，像 '(,op ,e1,e2)。我们拿这个带有名字的结构去“匹配”实际的数据（像 '(+ 12))。当它们一一对应之后，这些名字就自动被绑定到实际数据里相应位置的值。模式里面不但可以含有名字，也可以含有具体的数据。比如你可以构造一个模式'(,op ,e1 42)，用来匹配第二个操作数固定为 42 的那些表达式。</p><p style="margin:0px 0px 20px;padding:0px;">　　看见左边的模式，你就像直接“看见”了输入数据的形态，然后对里面的元素进行操作。它可以让我们一次性的“拆散”(destruct)数据结构，把各个部件（域）的值绑定到多个变量，而不需要使用多个访问函数。所以模式匹配是非常直观的编程方式，值得每种语言借鉴。很多函数式语言里都有类似的功能，比如 ML 和 Haskell。</p><p style="margin:0px 0px 20px;padding:0px;">　　注意这里 e1 和 e2 里面的操作数还不是值，它们是表达式。我们递归的调用 interp1 自己，分别得到 e1 和 e2 的值 v1 和 v2。它们应该是数字。</p><p style="margin:0px 0px 20px;padding:0px;">　　你注意到我们在什么地方使用了递归吗？如果你再看一下“算术表达式”的定义：</p><p style="margin:0px 0px 20px;padding:0px;">　　“算术表达式”有两种形式：</p><p style="margin:0px 0px 20px;padding:0px;">　　1) 一个数</p><p style="margin:0px 0px 20px;padding:0px;">　　2) 一个 '(op e1 e2) 这样的结构（其中 e1 和 e2 是两个“算术表达式”）</p><p style="margin:0px 0px 20px;padding:0px;">　　你就会发现这个定义里面“递归”的地方就是 e1 和 e2，所以 calc 在 e1 和 e2 上面递归的调用自己。如果你在数据定义的每个递归处都进行递归，那么你的递归程序就会穷举所有的情况。</p><p style="margin:0px 0px 20px;padding:0px;">　　之后，我们根据操作符 op 的不同，对这两个值 v1 和 v2 分别进行操作。如果 op 是加号 '+，我们就调用 Scheme 的加法操作，作用于 v1 和 v2，并且返回运算所得的值。如果是减号，乘号，除号，我们也进行相应的操作，返回它们的值。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以你就可以得到如下的测试结果：</p><p style="margin:0px 0px 20px;padding:0px;">　　(calc '(+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 3</p><p style="margin:0px 0px 20px;padding:0px;">　　(calc '(* 2 3))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">　　(calc '(* (+ 1 2) (+ 3 4)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 21</p><p style="margin:0px 0px 20px;padding:0px;">　　一个计算器就是这么简单。你可以试试这些例子，然后自己再做一些新的例子。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">什么是 lambda calculus？</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　现在让我们过渡到一种更强大的语言：lambdacalculus。它虽然名字看起来很吓人，但是其实非常简单。它的三个元素分别是是：变量，函数，调用。用传统的表达法，它们看起来就是：</p><p style="margin:0px 0px 20px;padding:0px;">　　变量：x</p><p style="margin:0px 0px 20px;padding:0px;">　　函数：λx.t</p><p style="margin:0px 0px 20px;padding:0px;">　　调用：t1 t2</p><p style="margin:0px 0px 20px;padding:0px;">　　每个程序语言里面都有这三个元素，只不过具体的语法不同，所以你其实每天都在使用 lambda calculus。用 Scheme 作为例子，这三个元素看起来就像：</p><p style="margin:0px 0px 20px;padding:0px;">　　变量：x</p><p style="margin:0px 0px 20px;padding:0px;">　　函数：(lambda (x) e)</p><p style="margin:0px 0px 20px;padding:0px;">　　调用：(e1 e2)</p><p style="margin:0px 0px 20px;padding:0px;">　　一般的程序语言还有很多其它的结构，可是这三个元素却是缺一不可的。所以构建解释器的最关键步骤就是把这三个东西搞清楚。构造任何一个语言的解释器一般都是从这三个元素开始，在确保它们完全正确之后才慢慢加入其它的元素。</p><p style="margin:0px 0px 20px;padding:0px;">　　有一个很简单的思维方式可以让你直接看到这三元素的本质。记得我说过，每个程序都是一个“机器的描述”吗？所以每个 lambdacalculus 的表达式也是一个机器的描述。这种机器跟电子线路非常相似。lambda calculus 的程序和机器有这样的一一对应关系：一个变量就是一根导线。一个函数就是某种电子器件的“样板”，有它自己的输入和输出端子，自己的逻辑。一个调用都是在设计中插入一个电子器件的“实例”，把它的输入端子连接到某些已有的导线，这些导线被叫做“参数”。所以一个 lambda calculus 的解释器实际上就是一个电子线路的模拟器。所以如果你听说有些芯片公司开始用类似 Haskell 的语言（比如 Bluespec System Verilog）来设计硬件，也就不奇怪了。</p><p style="margin:0px 0px 20px;padding:0px;">　　需要注意的是，跟一般语言不同，lambda calculus 的函数只有一个参数。这其实不是一个严重的限制，因为 lambdacalculus 的函数可以被作为值传递 (这叫 first-classfunction)，所以你可以用嵌套的函数定义来表示两个以上参数的函数。比如，(lambda (x) (lambda (y) y))就可以表示一个两个参数的函数，它返回第二个参数。不过当它被调用的时候，你需要两层调用，就像这样：</p><p style="margin:0px 0px 20px;padding:0px;">　　(((lambda (x) (lambda (y) y)) 1) 2)</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 2</p><p style="margin:0px 0px 20px;padding:0px;">　　虽然看起来丑一点，但是它让我们的解释器达到终极的简单。简单对于设计程序语言的人是至关重要的。一开头就追求复杂的设计，往往导致一堆纠缠不清的问题。</p><p style="margin:0px 0px 20px;padding:0px;">　　lambda calculus 不同于普通语言的另外一个特点就是它没有数字等基本的数据类型，所以你不能直接用 lambdacalculus 来计算像 (+ 1 2) 这样的表达式。但是有意思的是，数字却可以被 lambda calculus 的三个基本元素“编码”(encoding)出来。这种编码可以用来表示自然数，布尔类型，pair，list，以至于所有的数据结构。它还可以表示 if 条件语句等复杂的语法结构。常见的一种这样的编码叫做 <a href="http://en.wikipedia.org/wiki/Church_encoding" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Church encoding</a>。所以 lambda calculus 其实可以产生出几乎所有程序语言的功能。中国的古话“三生万物”，也许就是这个意思。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">求值顺序，call-by-name, call-by-value</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　当解释一个程序的时候，我们可以有好几种不同的“求值顺序”(evaluationorder)。这有点像遍历二叉树有好几种不同的顺序一样（中序，前序，后序）。只不过这里的顺序更加复杂一些。比如下面的程序：</p><p style="margin:0px 0px 20px;padding:0px;">　　((lambda (x) (* x x)) (+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　我们可以先执行最外层的调用，把 (+ 1 2) 传递进入函数，得到 (* (+ 1 2) (+ 12))。所以求值顺序是：</p><p style="margin:0px 0px 20px;padding:0px;">　　((lambda (x) (* x x)) (+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; (* (+ 1 2) (+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; (* 3 (+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; (* 3 3)</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; 9</p><p style="margin:0px 0px 20px;padding:0px;">　　但是我们也可以先算出 (+ 1 2) 的结果，然后再把它传进这个函数。所以求值顺序是：</p><p style="margin:0px 0px 20px;padding:0px;">　　((lambda (x) (* x x)) (+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; ((lambda (x) (* x x)) 3)</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; (* 3 3)</p><p style="margin:0px 0px 20px;padding:0px;">　　=&gt; 9</p><p style="margin:0px 0px 20px;padding:0px;">　　我们把第一种方式叫做 call-by-name (CBN)，因为它把参数的“名字”（也就是表达式自己）传进函数。我们把第二种方式叫做 call-by-value (CBV)，因为它先把参数的名字进行解释，得到它们的“值”之后，才把它们传进函数。</p><p style="margin:0px 0px 20px;padding:0px;">　　这两种解释方式的效率是不一样的。从上面的例子，你可以看出 CBN 比 CBV 多出了一步。为什么呢？因为函数 (lambda (x)(* x x)) 里面有两个 x，所以 (+ 1 2) 被传进函数的时候被复制了一份。之后我们需要对它的每一拷贝都进行一次解释，所以(+ 1 2) 被计算了两次！</p><p style="margin:0px 0px 20px;padding:0px;">　　鉴于这个原因，几乎所有的程序语言都采用 CBV，而不是 CBN。CBV 常常被叫做“strict”或者“applicativeorder”。虽然 CBN 效率低下，与它等价的一种顺序 call-by-need 却没有这个问题。call-by-need 的基本原理是对 CBN 中被拷贝的表达式进行“共享”和“记忆”。当一个表达式的一个拷贝被计算过了之后，其它的拷贝自动得到它的值，从而避免重复求值。call-by-need 也叫“lazy evaluation”，它是 Haskell 语言所用的语义。</p><p style="margin:0px 0px 20px;padding:0px;">　　求值顺序不只停留于 call-by-name, call-by-value,call-by-need。人们还设计了很多种其它的求值顺序，虽然它们大部分都不能像 call-by-value 和 call-by-need 这么实用。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">完整的 lambda calculus 解释器</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　下面是我们今天要完成的解释器，它只有 39 行（不包括空行和注释）。你可以先留意一下各个部分的注释，它们标注各个部件的名称，并且有少许讲解。这个解释器实现的是 CBV 顺序的 lambdacalculus，外加基本的算术。加入基本算术的原因是为了可以让初学者写出比较有趣一点的程序，不至于一开头就被迫去学 Churchencoding。</p><p style="margin:0px 0px 20px;padding:0px;">　　;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p><p style="margin:0px 0px 20px;padding:0px;">　　;;; 以下三个定义 env0, ent-env， lookup 是对环境（environment）的基本操作：</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 空环境</p><p style="margin:0px 0px 20px;padding:0px;">　　(define env0 '())</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境</p><p style="margin:0px 0px 20px;padding:0px;">　　(define ext-env</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (x v env)</p><p style="margin:0px 0px 20px;padding:0px;">　　(cons `(，x .，v) env)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 查找。在环境中 env 中查找 x 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　(define lookup</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (x env)</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([p(assq x env)])</p><p style="margin:0px 0px 20px;padding:0px;">　　(cond</p><p style="margin:0px 0px 20px;padding:0px;">　　[(not p) x]</p><p style="margin:0px 0px 20px;padding:0px;">　　[else (cdr p)]))))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境</p><p style="margin:0px 0px 20px;padding:0px;">　　(struct Closure (f env))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 共 5 种情况（变量，函数，调用，数字，算术表达式）</p><p style="margin:0px 0px 20px;padding:0px;">　　(define interp1</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (exp env)</p><p style="margin:0px 0px 20px;padding:0px;">　　(match exp                     ; 模式匹配 exp 的以下情况（分支）</p><p style="margin:0px 0px 20px;padding:0px;">　　[(? symbol? x) (lookup x env)]           ; 变量</p><p style="margin:0px 0px 20px;padding:0px;">　　[(? number? x) x]                 ; 数字</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(lambda (，x) ,e)                 ; 函数</p><p style="margin:0px 0px 20px;padding:0px;">　　(Closure exp env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(,e1 ,e2)                    ; 调用</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([v1 (interp1 e1 env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　[v2 (interp1 e2 env)])</p><p style="margin:0px 0px 20px;padding:0px;">　　(match v1</p><p style="margin:0px 0px 20px;padding:0px;">　　[(Closure `(lambda (，x) ,e) env1)</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp1 e (ext-env x v2 env1))]))]</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(,op ,e1 ,e2)                  ;算术表达式</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([v1 (interp1 e1 env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　[v2 (interp1 e2 env)])</p><p style="margin:0px 0px 20px;padding:0px;">　　(match op</p><p style="margin:0px 0px 20px;padding:0px;">　　['+ (+ v1 v2)]</p><p style="margin:0px 0px 20px;padding:0px;">　　['- (- v1 v2)]</p><p style="margin:0px 0px 20px;padding:0px;">　　['* (* v1 v2)]</p><p style="margin:0px 0px 20px;padding:0px;">　　['/ (/ v1 v2)]))])))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 解释器的“用户界面”函数。它把 interp1 包装起来，掩盖第二个参数，初始值为 env0</p><p style="margin:0px 0px 20px;padding:0px;">　　(define interp</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (exp)</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp1 expenv0)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">测试例子</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　这里有一些测试的例子。你最好先玩一下再继续往下看，或者自己写一些新的例子。学习程序的最好办法就是玩弄这个程序，给它一些输入，观察它的行为。有时候这比任何语言的描述都要直观和清晰。</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '(+ 1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 3</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '(* 2 3))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '(* 2 (+ 3 4)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 14</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '(* (+ 1 2) (+ 3 4)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 21</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '(((lambda (x) (lambda (y) (* x y))) 2) 3))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '((lambda (x) (* 2 x)) 3))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '((lambda (y) (((lambda (y) (lambda (x) (* y 2))) 3)0)) 4))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; 6</p><p style="margin:0px 0px 20px;padding:0px;">　　;; (interp '(1 2))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; =&gt; match: no matching clause for 1</p><p style="margin:0px 0px 20px;padding:0px;">　　在接下来的几节，我们来看看这个解释器里主要的分支（match）表达式的各种情况。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对基本算术操作的解释</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　算术操作在解释器里是最简单也是最“基础”的东西，因为它们不能再被细分为更小的元素了。所以在接触函数，调用等复杂的结构之前，我们来看一看对算术操作的处理。以下就是这个解释器里处理基本算术的部分，它是 interp1 的最后一个分支。</p><p style="margin:0px 0px 20px;padding:0px;">　　(matchexp</p><p style="margin:0px 0px 20px;padding:0px;">　　... ...</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(,op ,e1 ,e2)</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([v1 (interp1 e1env)]           ; 递归调用 interp1 自己，得到 e1 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　[v2 (interp1 e2env)])          ; 递归调用 interp1 自己，得到 e2 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　(matchop                           ; 分支：处理操作符 op 的 4 种情况</p><p style="margin:0px 0px 20px;padding:0px;">　　['+ (+ v1v2)]                    ; 如果是加号，输出结果为 (+ v1 v2)</p><p style="margin:0px 0px 20px;padding:0px;">　　['- (- v1v2)]                    ; 如果是减号，乘号，除号，相似的处理</p><p style="margin:0px 0px 20px;padding:0px;">　　['* (* v1 v2)]</p><p style="margin:0px 0px 20px;padding:0px;">　　['/ (/ v1 v2)]))])</p><p style="margin:0px 0px 20px;padding:0px;">　　你可以看到它几乎跟刚才写的计算器一模一样，不过现在 interp1 的调用多了一个参数 env 而已。这个 env 是什么，我们下面很快就讲。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">变量和函数</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　我想用两个小节来简单介绍一下变量，函数和环境。稍后的几节我们再来看它们是如何实现的。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">变量</strong>(variable)的产生是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使得<strong style="font-style:normal;font-weight:bold;font-size:100%;">函数</strong>的实现成为可能。比如数学函数f(x) = x * 2，其中 x 是一个变量，它把输入的值传递到函数的主体“x *2”里面。如果没有变量，函数就不可能实现。</p><p style="margin:0px 0px 20px;padding:0px;">　　对变量的最基本的操作是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 f (x)作为例子吧。当 x 等于 1 的时候，f(x) 的值是 2，而当 x 等于 2 的时候，f(x) 的值是 4。在上面的句子里，我们对x 进行了两次绑定。第一次 x 被绑定到了 1，第二次被绑定到了2。你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 f (x) 里面的那个 x，而 x * 2 里面的x，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该几乎相等。有点跑题了……反正只要记住一点：绑定就是插进插座的那个“动作”。</p><p style="margin:0px 0px 20px;padding:0px;">　　那么“取值”呢？再想一下前面的例子，当我们用伏特表测电线另外一端的电压的时候，我们就是在对这个变量进行取值。有时候这种取值的过程不是那么明显，比如电流如果驱动了风扇的电动机。虽然电线的另外一头没有显示电压，其实电流已经作用于电动机的输入端子，进入线圈。所以你也可以说其实是电动机在对变量进行取值。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">环境</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　我们的解释器是一个挺笨的程序，它只能一步一步的做事情。比如，当它需要求 f (1) 的值的时候，它做以下两步操作：1) 把 x 绑定到1; 2) 进入 f 的函数体对 x * 2 进行求值。这就像一个人做出这两个动作：1)把插头插进插座，2)走到电线的另外一头测量它的电压，并且把结果乘以 2。在第一步和第二步之间，我们如何记住 x 的值呢？它必须被传递到那个用来处理函数体的递归解释器里面。这就是为什么我们需要“<strong style="font-style:normal;font-weight:bold;font-size:100%;">环境</strong>”，也就是 interp1 的第二个参数 env。</p><p style="margin:0px 0px 20px;padding:0px;">　　环境记录变量的值，并且把它们传递到它们的“可见区域”，用术语说就叫做“作用域”(scope)。通常作用域是整个函数体，但是有一个例外，就是当函数体内有嵌套的函数定义的时候，内部的那个函数如果有同样的参数名，那么外层的参数名就会被“屏蔽”（shadow）掉。这样内部的函数体就看不到外层的参数了，只看到它自己的。比如(lambda (x) (lambda (x) (* x 2)))，里面的那个 x 看到的就是内层函数的x，而不是外层的。</p><p style="margin:0px 0px 20px;padding:0px;">　　在我们的解释器里，用于处理环境的主要部件如下：</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 空环境</p><p style="margin:0px 0px 20px;padding:0px;">　　(define env0 '())</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 对环境 env 进行扩展，把 x 映射到 v</p><p style="margin:0px 0px 20px;padding:0px;">　　(define ext-env</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (x v env)</p><p style="margin:0px 0px 20px;padding:0px;">　　(cons `(，x .，v) env)))</p><p style="margin:0px 0px 20px;padding:0px;">　　;; 取值。在环境中 env 中查找 x 的值</p><p style="margin:0px 0px 20px;padding:0px;">　　(define lookup</p><p style="margin:0px 0px 20px;padding:0px;">　　(lambda (x env)</p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([p(assq x env)])</p><p style="margin:0px 0px 20px;padding:0px;">　　(cond</p><p style="margin:0px 0px 20px;padding:0px;">　　[(not p) x]</p><p style="margin:0px 0px 20px;padding:0px;">　　[else (cdr p)]))))</p><p style="margin:0px 0px 20px;padding:0px;">　　这里我们用的是 Scheme 的 association list 来表示环境。Association list 看起来像这个样子：((x . 1) (y . 2) (z . 5))。也就是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写的直观一点就是：</p><p style="margin:0px 0px 20px;padding:0px;">　　((x . 1)</p><p style="margin:0px 0px 20px;padding:0px;">　　(y . 2)</p><p style="margin:0px 0px 20px;padding:0px;">　　(z . 5))</p><p style="margin:0px 0px 20px;padding:0px;">　　查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？</p><p style="margin:0px 0px 20px;padding:0px;">　　ext-env 扩展一个环境。比如，如果原来的环境是 ((y . 2) (z . 5)) 那么 (ext-env x1 ((y . 2) (z .5)))，就会得到 ((x . 1) (y . 2) (z . 5))。也就是把 (x . 1)放到最前面去。值得注意的一点是，环境被扩展以后其实是形成了一个新的环境，原来的环境并没有被“改变”。比如上面红色的部分就是原来的数据结构，只不过它被放到另一个更大的结构里面了。这叫做“函数式数据结构”。这个性质在我们的解释器里是至关重要的，因为当我们扩展了一个环境之后，其它部分的代码仍然可以原封不动的访问扩展前的那个旧的环境。当我们讲到调用的时候也许你就会发现这个性质的用处。</p><p style="margin:0px 0px 20px;padding:0px;">　　你也可以用另外的，更高效的数据结构（比如 splaytree）来表示环境。你甚至可以用函数来表示环境。唯一的要求就是，它是变量到值的“映射”(map)。你把 x 映射到 1，待会儿查询x 的值，它应该仍然是 1，而不会消失掉或者别的值。也就是说，这几个函数要满足这样的一种“界面约定”：如果 e 是 (ext-env'x 1 env) 返回的环境，那么 (lookup 'x e) 应该返回 1。只要满足这样的界面约定的函数都可以被叫做 ext-env 和 lookup，以至于可以它们用来完全替代这里的函数而不会导致其它代码的修改。这叫做“抽象”，也就是“面向对象语言”的精髓所在。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对变量的解释</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　了解了变量，函数和环境，让我们来看看解释器对变量的操作，也就是 interp1 的 match 的第一种情况。它非常简单，就是在环境中查找变量的值。这里的 (? symbol? x) 是一个特殊的模式，它使用 Scheme 函数 symbol? 来判断输入是否匹配，如果是的就把它绑定到 x，查找它的值，然后返回这个值。</p><p style="margin:0px 0px 20px;padding:0px;">　　[(? symbol? x) (lookup x env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　注意由于我们的解释器是递归的，所以这个值也许会被返回到更高层的表达式，比如 (* x 2)。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对数字的解释</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　对数字的解释也很简单。由于在 Scheme 里面名字 '2 就是数字 2（我认为这是 Scheme 设计上的一个小错误），所以我们不需要对数字的名字做特殊的处理，把它们原封不动的返回。</p><p style="margin:0px 0px 20px;padding:0px;">　　[(? number? x) x]</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对函数的解释</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　对函数的解释是一个比较难说清楚的问题。由于函数体内也许会含有外层函数的参数，比如 (lambda (y) (lambda (x) (* <strong style="font-style:normal;font-weight:bold;font-size:100%;">y</strong>2))) 里面的 y 是外层函数的参数，却出现在内层函数定义中。如果内层函数被作为值返回，那么 (* y 2) 就会跑到y的作用域以外。所以我们必须把函数做成“<strong style="font-style:normal;font-weight:bold;font-size:100%;">闭包</strong>”(closure)。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。所以我们对(lambda (x) e) 这样一个函数的解释就是这样：</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(lambda (，x) ,e)</p><p style="margin:0px 0px 20px;padding:0px;">　　(Closure exp env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　注意这里的 exp 就是 `(lambda (，x) ,e)自己。我们只是把它包装了一下，把它与当前的环境一起放到一个数据结构(闭包)里，并不进行任何复杂的运算。这里我们的闭包用的是一个 Racket 的 struct 结构，也就是一个记录类型(record)。你也可以用其它形式来表示闭包，比如有些解释器教程提倡用函数来表示闭包。其实用什么形式都无所谓，只要能存储 exp 和 env 的值。我比较喜欢使用 struct，因为它的界面简单清晰。</p><p style="margin:0px 0px 20px;padding:0px;">　　为什么需要保存当前的环境呢？因为当这个函数被作为一个值返回的时候，我们必须记住里面的外层函数的参数的绑定。比如，(lambda (y)(lambda (x) (* y 2)))。当它被作用于 1 之后，我们会得到内层的函数 (lambda (x) (* y 2))。当这个函数被经过一阵周折之后再被调用的时候，y应该等于几呢？正确的做法应该是等于1。这种把外层参数的值记录在内层函数的闭包里的做法，叫做“lexicalscoping”或者“static scoping”。</p><p style="margin:0px 0px 20px;padding:0px;">　　如果你不做闭包，而是把函数体直接返回，那么在 (lambda (x) (* y 2)) 被调用的位置，你可能会另外找到一个y，从而使用它的值。在调用的时候“动态”解析变量的做法，叫做“dynamic scoping”。事实证明 dynamicscoping 的做法是严重错误的，它导致了早期语言里面出现的各种很难发现的 bug。很多早期的语言是 dynamicscoping，就是因为它们只保存了函数的代码，而没有保存它定义处的环境。这样要简单一些，但是带来太多的麻烦。早期的 Lisp，现在的 Emacs Lisp 和 TeX 就是使用 dynamic scoping 的语言。</p><p style="margin:0px 0px 20px;padding:0px;">　　为了演示 lexical scoping 和 dynamic scoping 的区别。你可以在我们的解释器里执行以下代码：</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '((lambda (y) (((lambda (y)(lambda (x) (* y 2))) 3) 0)) 4))</p><p style="margin:0px 0px 20px;padding:0px;">　　其中红色的部分就是上面提到的例子。在这里，(* y 2) 里的 y，其实是最里面的那个 (lambda (y) ...)里的。当红色部分被作用于 3 之后。 (lambda (x) (* y2)) 被作为一个值返回。然后它被作用于 0（x 被绑定到 0，被忽略），所以 (*y 2) 应该等于 6。但是如果我们的解释器是 dynamic scoping，那么最后的结果就会等于 8。这是因为最外层的 y 开头被绑定到了 4，而 dynamic scoping 没有记住内层的 y 的值，所以使用了外层那个 y 的值。</p><p style="margin:0px 0px 20px;padding:0px;">　　为什么 Lexical scoping 更好呢？你可以从很简单的直觉来理解。当你构造一个“内部函数”的时候，如果它引用了外面的变量，比如这个例子里的 y，那么从外层的 y 到这个函数的内部，出现了一条“信道”（channel）。你可以把这个内部函数想象成一个电路元件，它的内部有一个节点 y 连接到一根从外部来的电线 y。当这个元件被返回，就像这个元件被挖出来送到别的地方去用。但是在它被使用的地方（调用），这个 y 节点应该从哪里得到输入呢？显然你不应该使用调用处的某个 y，因为这个 y 和之前的那个 y，虽然都叫 y，却不是“同一个y”，也就是同名异义。它们甚至可以代表不同的类型的东西。所以这个 y 应该仍然连接原来的那根 y 电线。当这个内部元件移动的时候，就像这跟电线被无限的延长，但是它始终连接到原来的节点。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">对函数调用的解释</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　好，我们终于到了最后的关头，函数调用。函数调用都是 (e1 e2) 这样的形式，所以我们需要先分别求出 e1 和 e2 的值。这跟基本运算的时候需要先求出两个操作数的值相似。</p><p style="margin:0px 0px 20px;padding:0px;">　　函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 (lambda (x) (* x 2)) 被作用于 1 时，我们把 x 绑定到 1，然后解释它的函数体 (* x2)。但是这里有一个问题，如果函数体内有未绑定的变量，它应该取什么值呢？从上面闭包的讨论，你已经知道了，其实操作数 e1 被求值之后应该是一个闭包，所以它的里面应该有未绑定变量的值。所以，我们就把这个闭包中保存的环境(env1)取出来，扩展它，把 x 绑定到 v2，然后用这个扩展后的环境来解释函数体。</p><p style="margin:0px 0px 20px;padding:0px;">　　所以函数调用的代码如下：</p><p style="margin:0px 0px 20px;padding:0px;">　　[`(,e1,e2)                                            </p><p style="margin:0px 0px 20px;padding:0px;">　　(let ([v1 (interp1 e1 env)]</p><p style="margin:0px 0px 20px;padding:0px;">　　[v2 (interp1 e2 env)])</p><p style="margin:0px 0px 20px;padding:0px;">　　(match v1</p><p style="margin:0px 0px 20px;padding:0px;">　　[(Closure `(lambda (，x) ,e) env1)  ;用模式匹配的方式取出闭包里的各个子结构</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp1 e (ext-env x v2env1))]  ; 在<strong style="font-style:normal;font-weight:bold;font-size:100%;">闭包的环境</strong>中把 x 绑定到 v2，解释函数体</p><p style="margin:0px 0px 20px;padding:0px;">　　))]</p><p style="margin:0px 0px 20px;padding:0px;">　　你可能会奇怪，那么解释器的环境 env 难道这里就不用了吗？是的。我们通过 env 来计算 e1 和 e2 的值，是因为 e1 和 e2 里面的变量存在于“当前环境”。我们把 e1 里面的环境 env1 取出来用于计算函数体，是因为函数体并不是在当前环境定义的，它的代码在别的地方。如果我们用 env 来解释函数体，那就成了 dynamic scoping。</p><p style="margin:0px 0px 20px;padding:0px;">　　实验：你可以把 (interp1 e (ext-env x v2 env1)) 里面的 env1 改成 env，再试试我们之前讨论过的代码，它的输出就会是 8：</p><p style="margin:0px 0px 20px;padding:0px;">　　(interp '((lambda (y) (((lambda (y) (lambda (x) (* y2))) 3) 0)) 4))</p><p style="margin:0px 0px 20px;padding:0px;">　　另外在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下几乎不可能有效的控制。每一次当我使用赋值操作来修改环境，最后都会出现意想不到的麻烦。所以在写解释器，编译器的时候，我都只使用函数式数据结构来表示环境。</p><p style="margin:0px 0px 20px;padding:0px;">　　<strong style="font-style:normal;font-weight:bold;font-size:100%;">下一步</strong></p><p style="margin:0px 0px 20px;padding:0px;">　　在懂得了这里讲述的基本的解释器构造之后，下一步可以做什么呢？其实从这个基本的解释器原型，你可以进一步发展出很多内容，比如：</p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">在这个解释器里加一些构造，比如递归和状态，你就可以得到一个完整的程序语言的解释器，比如 Scheme 或者 Python。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">对这个解释器进行“抽象”，你就可以对程序进行类型推导。感兴趣的话可以参考我实现的这个 <a href="https://github.com/yinwang0/magic/blob/master/infer.ss" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Hindley-Milner 系统</a>，或者 <a href="https://github.com/yinwang0/mini-pysonar" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Python 类型推导</a>。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">对这个解释器进行一些改变，就可以得到一个非常强大的 online partialevaluator，可以用于编译器优化。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><span>　　<a href="http://yinwang0.lofter.com/post/183ec2_47c086mailto:%E5%A6%82%E6%9E%9C%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%AC%A2%E8%BF%8E%E8%B7%9F%E6%88%91%E8%81%94%E7%B3%BB:shredderyin@gmail.com%E3%80%82%E5%8F%A6%E5%A4%96%E9%9C%80%E8%A6%81%E6%8C%87%E5%87%BA%E7%9A%84%E6%98%AF%EF%BC%8C%E5%AD%A6%E4%BC%9A%E8%BF%99%E4%B8%AA%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B9%B6%E4%B8%8D%E7%AD%89%E4%BA%8E%E7%90%86%E8%A7%A3%E4%BA%86%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E7%90%86%E8%AE%BA%E3%80%82%E6%89%80%E4%BB%A5%E5%9C%A8%E5%AD%A6%E4%BC%9A%E4%BA%86%E8%BF%99%E4%BA%9B%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%98%E6%98%AF%E8%A6%81%E7%9C%8B%E4%B8%80%E4%BA%9B%E8%AF%AD%E4%B9%89%E5%AD%A6%E7%9A%84%E4%B9%A6%E3%80%82" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">如果有问题的话，欢迎跟我联系:shredderyin@gmail.com。另外需要指出的是，学会这个解释器并不等于理解了程序语言的理论。所以在学会了这些之后，还是要看一些语义学的书。</a></span></p></blockquote></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1094"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47bd7b" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">让科学和理性回到计算机科学</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">想写点有用的文章，可是又不知道从哪里开始写。看过我曾经的文章的人，到现在还在给我来信，表达他们的欣喜。我觉得他们很可爱，我理解他们对真知的渴望，但是也深深的认识到我从前的文章对人的误导作用。我很想告诉他们我对这些事物现在的认识，却无法开口，怕给人泼凉水，怕被认为是对我以前“信仰”的倒戈。</p><br/>可是我也深深的感觉到计算机科学的研究中存在的宗教和非理性的思想。就算在世界顶尖的计算机科学家头脑中，这种偏激的思想一样存在，使得他们不能接受不一样的理念。各种研究团队提出自己的概念，形成很多知识的壁垒。多种纷繁复杂的设计，其实不过是用来解决同一个简单的问题。互相攻击，固执己见，却抓不住问题的关键。其实真理往往不在任何一方手中，它只存在于静心观察的人眼中。<p style="margin:0px 0px 20px;padding:0px;">我隐藏了好几年的真实想法，一直没有足够的信心说出来。因为我怕自己是错的，我不想给人错误的思想。直到现在，我终于有了足够的证据，证明我的一些想法的正确。我蓄积了足够的勇气，可以直抒己见，不再怕误导人。是科学和理性给了我这种勇气，所以我决定写一些文章。它们虽然可能会对你现在的思维方式带来冲击，但是我写作的初衷是给人以帮助，客观的分析问题。不过必须随时记住，我说的话都有可能是错的，你需要用自己的实践去检验。<br/></p><p style="margin:0px 0px 20px;padding:0px;"><br/>话说对Linux的看法，从实用角度上讲，它是一个挺不错的东西。然而从理论角度上讲，它并不是最先进的。从应用的角度上讲，它对用户确实非常不友好。我其实早就不是Linux，TeX，Emacs，或者别的稀奇古怪工具的忠实“信徒”或者用户。虽然我随时可以用Linux做一些事情，但是用Linux还是Windows已经没有太大关系。操作系统其实不是高深莫测的神物，只要你明白它们的本质是什么。会像“高手”一样的使用Linux或者Windows其实并不能说明什么问题。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">由于我受到的教育，我能设计各种各样的程序语言和编译器，我也在构想一个跟Unix非常不同的操作系统。我不满足于成为一个合格的“用户”，而总是试图成为一个创造者和改良者。我清楚的看到几乎所有操作系统，数据库和各种编程工具存在的缺点，我总是发现它们有可以改进的地方。它们总是可以变得更精悍，更高效，更方便。在不久的将来我会介绍一些我的设计和构想，你会发现它们与Unix工具的设计原则很不一样。我也会介绍一些新的程序语言，编程工具等等。希望这能帮助大家提高对操作系统（包括Unix），程序语言，数据库和各种工具的理解。我虽然可能会批评某些东西，可是这些批评都是经过理性的分析得出的结论，而并不针对它们的设计者个人。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>我先把以前悄悄写过的一篇对“Unix哲学”的看法贴在<a href="http://blog.sina.com.cn/s/blog_5d90e82f01014k5j.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">这里</a>，希望能帮助大家看清楚Unix的本质，从而可以灵活的应用它的潜力，避免它的缺点。我放假了比较闲，所以会陆续写一些文章。</p><p style="margin:0px 0px 20px;padding:0px;">我也经常写一个英文博客，里面包含一些比较深刻的道理:<br/></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://yinwang0.wordpress.com/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://yinwang0.wordpress.com</a></p><p style="margin:0px 0px 20px;padding:0px;">也欢迎看看我的主页，twitter或者微博:</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://www.cs.indiana.edu/~yw21</a></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://twitter.com/#!/yinwang0" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://twitter.com/#!/yinwang0</a></p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.weibo.com/yinwang0" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://www.weibo.com/yinwang0</a></p><p style="margin:0px 0px 20px;padding:0px;">当然我希望不是从计算机技术上给人以帮助，我希望我的经历能给在各学科摸索中的的同学们一定的启发。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1095"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bf43" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">反省</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠 </p><p style="margin:0px 0px 20px;padding:0px;">　　今天跟一个朋友打电话，被他说了一顿。没有听得下去，可是回头想了一想，我觉得他说得有道理。我是该反省一下的时候了。</p><p style="margin:0px 0px 20px;padding:0px;">　　1. 被函数式编程洗脑。显然，之前很长一段时间（从清华时代开始）我被“函数式编程”洗脑了，并且产生了函数式程序员常见的“宗教情绪”。其实，函数式语言跟普通语言没有本质的区别（以后详述）。这种宗教情绪导致了在跟人谈话时候的一些问题，比如跟 Google 那位 C++ 程序员的对话。现在平心而论，C++ 并没有我想象的那么糟糕（也许有人不同意？），是我自己的态度有问题。我恐怕是被传染了盲目鄙视“非函数式语言”的习惯。</p><p style="margin:0px 0px 20px;padding:0px;">　　2. 对 Google 的评价以偏概全。其实我所在的小组确实有我所描述的问题。我说的事情都发生过，而且很多 Google 员工也认为我老板是个“怪人”。不过以个别的人的言行来评价一个公司，确实是很偏颇的。一些 Google 的朋友也来信慰问我，告诉我其实他们过得很好，老板对他也挺好，虽然他没做什么了不起的事情。还有的邀请我这次去他们小组 intern，说可以让我喜欢什么就做什么。虽然也许我再也不可能去 Google，对此我深表感激。我每天都用着 Gmail，Google maps，Android 手机，…… 我很喜欢它们。唉，我都在指指点点些什么呢！也许在 Google 很难满足一些人的野心，不过如果做一个普通程序员，规规矩矩的做人，其实过得还挺舒服。傻乎乎的对什么“新奇事物”都好奇，管它到底是不是真的是新的，也许才是正确的态度吧。我也应该“糊涂”一点了。</p><p style="margin:0px 0px 20px;padding:0px;">　　3. 对“应用”领域的歧视态度。其实之前对一些理论领域的“透彻”了解，也让我看到了应用领域的价值。这不得不让我反省之前在清华的时候，是否准确的了解了 EDA 领域的价值。我总是对“理论”和“数学”有一种崇高的景仰，却偏颇的认为应用这些理论的领域都没有价值。所以导致了我研究进入高度理论，偏离实际的方向。我使用貌似高深的计算几何算法，其实并没有给实际的电路布线带来什么好处。我发现事实也许正好相反，某些理论的领域才是在扯淡，不做实事，而应用和工程的领域才是在给我们带来真正福利。程序语言做到一定程度的人，都开始想把程序“编译”成 VHDL 或者 Verilog，然后实现为 FPGA 或者 ASIC 电路，而之前我有个清华同学就是做这个的（SystemC）。也许这就叫做峰回路转？</p><p style="margin:0px 0px 20px;padding:0px;">　　4. 对学术界以偏概全。不得不承认，我之前的导师是有问题的。可是新的导师其实是不错的人，做了很多实在的工作，比如 Open MPI, 光场照相机 (light field camera）。我现在做的事情是为一个新的 GPU 语言实现高效的内存管理。虽然我不知道最后有没有人会用这语言，总的来说还是学到了一些东西，合作的同学也挺友好。确实，有几个同学有我提到的态度问题，总是在别人面前显示自己。可是其他同学也许都看不惯，然后就把他们忽略掉了。罗素说得好，永远也不要以为世界上的人都跟你现在看到的人一样。总有志同道合的人在某个地方，我们都需要去寻找，不要在自己狭窄的世界里困顿。</p><p style="margin:0px 0px 20px;padding:0px;">　　我以后可能会写一些实在一些，有用一些，开心一些的东西了。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1100"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c5630" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">谈程序的“通用性”</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在现实的软件工程中，我经常发现这样的一种现象。本来用很简单的代码就可以解决的问题，却因为设计者对“通用性”，“可维护性”和“可扩展性”的盲目推崇，被搞得绕了几道弯，让人琢磨不透。</p><p style="margin:0px 0px 20px;padding:0px;">这些人的思维方式是这样的：“将来这段代码可能会被用到更多的场合，所以我现在就考虑到扩展问题。”于是乎，他们在代码中加入了各种各样的“框架结构”，目的是为了在将来有新的需要的时候，代码能够“不加修改”就被用到新的地方。</p><p style="margin:0px 0px 20px;padding:0px;">我并不否认“通用性”的价值，实际上我的某些程序通用性非常之强。可是很多人所谓的“通用性”，其实达到的是适得其反的效果。这种现象通常被成为“过度工程” (over-engineer)。关于过度工程，有一个有趣的故事：</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.snopes.com/business/genius/spacepen.asp" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">http://www.snopes.com/business/genius/spacepen.asp</a></p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">传说 1960 年代美俄“太空竞赛”的时候，NASA 遇到一个严重的技术问题：宇航员需要一支可以在外太空的真空中写字的钢笔。最后 NASA 耗资150万美元研制出了这样的钢笔。可惜这种钢笔在市场上并不行销。</p><p style="margin:0px 0px 20px;padding:0px;">俄国人也遇到同样的问题。他们使用了铅笔。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">这个故事虽然是假的，但是却具有伊索寓言的威力。现在再来看我们的软件行业，你也许会发现：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">代码需要被“重用”的场合，实际上比你想象的要少</p><p style="margin:0px 0px 20px;padding:0px;">我发现很多人写程序的时候连“眼前特例”都没做好，就在开始“展望将来”。他们总是设想别人会“重用”这段代码。而实际上，由于他们的设计过于复杂，理解这设计所需的脑力开销，已经高于从头开始的代价。所以大部分人其实根本不会去用他们的代码，自己重新写一个就是了。也有人到后来发现，之前写的那段代码，连自己都看不下去了，恨不得删了重来，就不要谈什么重用了。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">修改代码所需要的工作，实际上比你想象的要少</p><p style="margin:0px 0px 20px;padding:0px;">还有一种情况是，这些被设计来“共享”的代码，其实根本没有被用在很多的地方，所以即使你完全手动的修改它们也花不了很多时间。现在再加上 IDE 技术的发展和各种先进的 refactor 工具，批量的修改代码已经不是特别麻烦的事情。曾经需要在“逻辑层面”上进行的“可维护性”设计，现在有可能只需要在 IDE 里面点几下鼠标就轻松完成。所以在考虑设计一个框架之前，你应该同时考虑到这些因素。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">“考虑”到了通用性，并不等于你就准确地“把握”住了通用性</p><p style="margin:0px 0px 20px;padding:0px;">很多人考虑到了通用性，却没有准确的看到，到底是哪一个部分将来可能需要修改，所以他们的设计经常抓不住关键。当有新的需要出现的时候，才发现原来设想的可能变化的部分，其实根本没有变，而原来以为不会变的地方却变了。</p><p style="margin:0px 0px 20px;padding:0px;">能够准确的预测将来的需要，能够从代码中“抽象”出真正通用的框架，是一件非常困难的事情。它不止需要有编程的能力，而且需要对真实世界里的事物有强大的观察能力。很多人设计出来的框架，其实只是照搬别人的经验，却不能适应实际的需要。在 Java 世界里的很多 design pattern，就是这些一知半解的人设计出来的。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">初期设计的复杂性</p><p style="margin:0px 0px 20px;padding:0px;">如果在第一次的设计中就过早的考虑到“将来”，由此带来的多余的复杂性，有可能让初期的设计就出现问题。所以这种对于将来的变化的考虑，实际上帮了倒忙。本来如果专注于解决现在的问题，能够得到非常好的结果。但是由于“通用性”带来的复杂度，设计者的头脑每次都要多转几道弯，所以它无法设计出优雅的程序。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">理解和维护框架性代码的开销</p><p style="margin:0px 0px 20px;padding:0px;">如果你设计了框架性的代码，每个程序员为了在这个框架下编写代码，都需要理解这种框架的构造，这带来了学习的开销。一旦发现这框架有设计问题，依赖于它的代码很有可能需要修改，这又带来了修改的开销。所以加入“通用性”之后，其实带来了更多的工作。这种开销能不能得到回报，依赖于以上的多种因素。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">所以在设计程序的时候，我们最好是先把手上的问题解决好。如果发现这段代码还可以被用在很多别的地方，到时候再把“框架”从中抽象出来也不迟。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1106"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47bf50" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">给 TeXmacs 的推荐信</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">　　好久没有推荐过自己喜欢的软件了，现在推荐一款我在美国写数学文档的私家法宝，来自法国的 <a href="http://texmacs.org/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">TeXmacs</a>。我恐怕不可能跟以前那么有闲心写个长篇的说明文档了，不过这东西如此的简单好用，所以基本上不用我写什么文档了。鉴于知道的人很少，不理解的人很多，这里只是帮它打个广告，吊一下胃口。</p><p style="margin:0px 0px 20px;padding:0px;">　　TeXmacs 的主要特点是：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">它不是 TeX 的包装，而是一个完全独立的，旨在超越 TeX 的系统。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">拥有跟 TeX 相同，甚至更好的排版美观程度。这是因为它采用跟 TeX 一样的排版算法，并且重新实现。据说分页的算法比 TeX 的还要好些。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">可导出，导入 TeX 文档。我多次导出 LaTeX 文件，然后跟同事的 LaTeX 文档合并。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">拥有超越 Word（或者任何一款字处理软件）的，真正的“所见即所得”。屏幕上显示的内容，跟打印下来的完全一样，就像直接在编辑 PDF。一些 TeX 的前端，比如 Lyx， Scientific Workspace 等都不能达到这种效果。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">直接可在屏幕文档里绘图。完全可视化的表格，公式编辑环境。需要当心的是，用过 TeXmacs 一段时间之后，你会发现再也不想回到 TeX 的公式编辑方式 :)</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">非常人性化的按键设计。比如，在数学公式环境下，你按任意一个字符，然后就可以用多次 TAB 键相继选择“拓扑相同”的字符。举个例子，如果你按 @，然后再按几下 TAB，就会发现这个字符变成各种各样的圆圈形的字符。如果你按&gt;，再按 =，就会出现大于等于号，之后再按 TAB，就会相继出现大于等于号的各种变体。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">在直观的同时不失去对底层结构的控制。比如，（见上图）窗口右下角的状态栏，显示出当前光标位置的“上下文”是“proofeqnarry* (1,1) start”，这表示的是这是在一个 proof 环境里的 eqnarry 的坐标 (1,1)的开始处。当你使用 Ctrl-Backspace，最靠近光标的那层“环境”会被删除。比如，如果你现在的字体是斜体，那么在 Ctrl-Backspace 之后，字体就立即还原成正体。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">结构化的浏览功能。比如，按 Ctrl-PgUp,Ctrl-PgDn 就可以在“相同类型”的结构里上下跳转。比如，如果你在小节标题里按这个键，就可以迅速的浏览所有的小节标题。如果你在数学公式里按这个键，就可以迅速浏览所有的数学公式。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">作为计算机代数系统（CAS）和各种交互式程序的前端。支持 Axiom, MAXIMA，Giac, Sage, Yacas, Octave, R, …… 这些系统返回的数学公式会直接被 TeXmacs 显示为“TeX 效果”。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">使用 Scheme 作为嵌入式语言，并且可以使用它来扩展系统。这比起 TeX 的语言是非常大的进步。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">　　目前由于 TeX 的“垄断地位”，这个系统在美国还不是很流行，很多人都没听说过有这种东西存在。美国学术圈的很多人由于受到像我这样的人的洗脑，都不理解这种图形化编辑软件的价值，并且继续对下一代进行洗脑（比如要求他们用 LaTeX 写作业）。现在当年的“教主”开始推广 WYSIWYG，试图解除 TeX 的魔咒，居然经常被人当成菜鸟，真是无语啊 。不过我相信真金不怕火炼的，TeXmacs 这样的软件总有一天会成为主流。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1107"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bec0" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是语义学</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">很多人问我如何在掌握基本的程序语言技能之后进入“语义学”的学习。现在我就简单介绍一下什么是“语义”，然后推荐一本入门的书。这里我说的“语义”主要是针对程序语言，不过自然语言里的语义，其实本质上也是一样的。<br/><br/>
一个程序的“语义”通常是由另一个程序决定的，这另一个程序叫做“解释器”(interpreter)。程序只是一个数据结构，通常表示为语法树(abstract syntax tree)或者指令序列。这个数据结构本身其实没有意义，是解释器让它产生了意义。对同一个程序可以有不同的解释，就像上面这幅图，对画面元素的不同解释，可以看到不同的内容（少女或者老妇）。<br/><br/>
解释器接受一个“程序”(program)，输出一个“值”(value)。用图形的方法表示，解释器看起来就像一个箭头：程序 ===&gt; 值。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。<br/><br/>
其实解释器不止存在于计算机中，它是一个很广泛的概念。其中好些你可能还没有意识到。写 Python 程序，需要 Python 解释器，它的输入是 Python 代码，输出是一个 Python 里面的数据，比如 42 或者“foo”。CPU 其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。如果你了解类型推导系统 (type inference)，就会发现类型推导的过程也是一个解释器，它的输入是一个程序，输出是一个“类型”。类型也是一种值，不过它是一种抽象的值。比如，42 对应的类型是 int，我们说 42 被抽象为 int。<br/><br/>
所以“语义学”，基本上就是研究各种解释器。解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的 lambda calculus 的解释器。lambda calculus 只有三种元素，却可以表达所有程序语言的复杂结构。<br/><br/>
专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《<a href="https://dl.dropbox.com/u/392085/PLLC.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Programming Languages and Lambda Calculi</a>》。只需要看完前半部分（Part I 和 II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是 lambda calculus）开始讲解什么是递归定义，什么是解释，什么是 Church-Rosser，什么是上下文 (evaluation context)。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如 lambda calculus 和 CEK，SECD 等抽象机 (abstract machine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。</p></div></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="1111"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_4cbdca" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">谈 Linux，Windows 和 Mac</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这段时间受到很多人的来信。他们看了我很早以前写的推崇 Linux 的文章，想知道如何“抛弃 Windows，学习 Linux”。天知道他们在哪里找到那么老的文章，真是好事不出门…… 我觉得我有责任消除我以前的文章对人的误导，洗清我这个“Linux 狂热分子”的恶名。我觉得我已经写过一些澄清的文章了，可是怎么还是有人来信问 Linux 的问题。也许因为感觉到“舆论压力”，我把文章都删了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">简言之，我想对那些觉得 Linux 永远也学不会的“菜鸟”们说：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1. Linux 和 Unix 里面包含了一些非常糟糕的设计。不要被 Unix 的教条主义者吓倒。学不会有些东西很多时候不是你的错，而是 Linux 的错，是“Unix 思想” 的错。不要浪费时间去学习太多工具的用法，钻研稀奇古怪的命令行。那些貌似难的，复杂的东西，特别要小心分析。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">2. Windows 避免了 Unix，Linux 和 Mac OS X 的很多问题。微软是值得尊敬的公司，是真正在乎程序开发工具的公司。我收回曾经对微软的鄙视态度。请菜鸟们吸收 Windows 设计里面好的东西。另外 Visual Studio 是非常好的工具，会带来编程效率的大幅度提升。请不要歧视 IDE。要正视 Emacs，VIM 等文本编辑器的局限性。当然，这些正面评价不等于说你应该为微软工作。就像我喜欢 iPhone，但是却不一定想给 Apple 工作一样。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">3. 学习操作系统最好的办法是学会（真正的）程序设计思想，而不是去“学习”各种古怪的工具。所有操作系统，数据库，Internet，以至于 WEB 的设计思想（和缺陷），几乎都能用程序语言的思想简单的解释。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">先说说我现在对 Linux 和相关工具（比如 TeX）的看法吧。我每天上班都用 Linux，可是回家才不想用它呢。上班的时候，我基本上只是尽我所能的改善它，让它不要给我惹麻烦。Unix 有许许多多的设计错误，却被当成了教条，传给了一代又一代的程序员，恶性循环。Unix 的 shell，命令，配置方式，图形界面，都是相当糟糕的。每一个新版本的 Ubuntu 都会在图形界面的设计上出现新的错误，让你感觉历史怎么会倒退。其实这只是表面现象。Linux 所用的图形界面（X Window）在本质上几乎是没救的。我不想在这里细说 Unix 的缺点，在它出现的早期，已经有人写了一本书，名叫 <a href="http://web.mit.edu/~simsong/www/ugh.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Unix Hater's Handbook</a>，里面专门有一章叫做 <a href="http://www.art.net/~hopkins/Don/unix-haters/x-windows/disaster.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">The X-Windows Disaster</a>。它分析后指出，X Window 貌似高明的 client-server 设计，其实并不像说的那么好。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这本书汇集了 Unix 出现的年代，很多人对它的咒骂。有趣的是，这本书有一个“反序言”，是 Unix 的创造者之一 Dennis Ritchie 写的。我曾经以为这些骂 Unix 的人都是一些菜鸟。他们肯定是智商太低，或者被 Windows 洗脑了，不能理解 Unix 的高明设计才在那里骂街。现在理解了程序语言的设计原理之后，才发现他们说的那些话里面居然大部分是实话！其实他们里面有些人在当年就是世界顶尖的编程高手，自己写过操作系统和编译器，功底不亚于 Unix 的创造者。在当年他们就已经使用过设计更加合理的系统，比如 Multics，Lisp Machine 等。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可惜的是，在现在的操作系统书籍里面，Multics 往往只是被用来衬托 Unix 的“简单”和伟大。Unix 的书籍喜欢在第一章讲述这样的历史：“Multics 由于设计过于复杂，试图包罗万象，而且价格昂贵，最后失败了。” 可是 Multics 失败了吗？Multics，Oberon，IBM System/38， Lisp Machine，…… 在几十年前就拥有了 Linux 现在都还没有的好东西。Unix 里面的东西，什么虚拟内存，文件系统，…… 基本上都是从 Multics 学来的。Multics 的机器，一直到 2000 年都还在运行。Unix 不但“窜改”了历史教科书，而且似乎永远不吸取教训，到现在还没有实现那些早期系统早就有的好东西。Unix 的设计几乎完全没有一致性和原则。各种工具程序功能重复，冗余，没法有效地交换数据。可是最后 Unix 靠着自己的“廉价”，“宗教”和“哲学”，战胜了别的系统在设计上的先进，统治了程序员的世界。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">如果你想知道这些“失败的”操作系统里面有哪些我们现在都还没有的先进技术，可以参考这篇文章：<a href="http://www.ics.uci.edu/~franz/Site/pubs-pdf/BC03.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Oberon - The Overlooked Jewel</a>。它介绍的是 Niklaus Wirth（也就是 Pascal 语言的设计者）的 Oberon 操作系统。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">胜者为王，可是 Unix 其实是一个暴君，它不允许你批评它的错误。它利用其它程序员的舆论压力，让每一个系统设计上的错误，都被说成是用户自己的失误。你不敢说一个工具设计有毛病，因为如果别人听到了，就会以为你自己不够聪明，说你“人笨怪刀钝”。这就像是“皇帝的新装”里的人们，明明知道皇帝没穿衣服，还要说“这衣服这漂亮”！总而言之，“对用户友好”这个概念，在 Unix 的世界里是被歧视，被曲解的。Unix 的狂热分子很多都带有一种变态的“精英主义”。他们以用难用的工具为豪，鄙视那些使用“对用户友好”的工具的人。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我曾经强烈的推崇 FVWM，TeX 等工具，可是现在擦亮眼睛看来，它们给用户的界面，其实也是非常糟糕的设计，跟 Unix 一脉相承。他们把程序设计的许多没必要的细节和自己的设计失误，无情的暴露给用户。让用户感觉有那么多东西要记，仿佛永远也没法掌握它。实话说吧，当年我把 TeXbook 看了两遍，做完了所有的习题（包括最难的“double bend”习题）。几个月之后，几乎全部忘记干净。为什么呢？因为 TeX 的语言是非常糟糕的设计，它没有遵循程序语言设计的基本原则。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这里有一个鲜为人知的小故事。TeX 之所以有一个“扩展语言”，是 Scheme 的发明者 Guy Steele 的建议。那年夏天，Steele 在 Stanford 实习。他听说 Knuth 在设计一个排版系统，就强烈建议他使用一种扩展语言。后来 Knuth 采纳了他的建议。不幸的是 Steele 几个月后就离开了，没能帮助 Knuth 完成语言的设计。Knuth 老爹显然有我所说的那种“精英主义”，他咋总是设计一些难用的东西，写一些难懂的书？ </p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/E___7395ZH00SIGG.gif" type="image/gif" height="22" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="22"/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">一个好的工具，应该只有少数几条需要记忆的规则，就像象棋一样。而这些源于 Unix 的工具却像是“魔鬼棋”或者“三国杀”，有太多的，无聊的，人造的规则。有些人鄙视图形界面，鄙视 IDE，鄙视含有垃圾回收的语言（比如 Java），鄙视一切“容易”的东西。他们却不知道，把自己沉浸在别人设计的繁复的规则中，是始终无法成为大师的。就像一个人，他有能力学会各种“魔鬼棋”的规则，却始终无法达到象棋大师的高度。所以，容易的东西不一定是坏的，而困难的东西也不一定是好的。学习计算机（或者任何其它工具），应该“只选对的，不选难的”。记忆一堆的命令，乌七八糟的工具用法，最后脑子里什么也不会留下。学习“原理性”的东西，才是永远不会过时的。 </p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Windows 技术设计上的很多细节，也许在早期是同样糟糕的。但是它却向着更加结构化，更加简单的方向发展。Windows 的技术从 OLE，COM，发展到 .NET，再加上 Visual Studio 这样高效的编程工具，这些带来了程序员和用户效率的大幅度提高，避免了 Unix 和 C 语言的很多不必存在的问题。Windows 程序从很早的时候就能比较方便的交换数据。比如，OLE 让你可以把 Excel 表格嵌入到 Word 文档里面。不得不指出，这些是非常好的想法，是超越“Unix 哲学”的。相反，由于受到“Unix 哲学”的误导，Unix 的程序间交换数据一直以来都是用字符串，而且格式得不到统一，以至于很多程序连拷贝粘贴都没法正确进行。Windows 的“配置”，全都记录在一个中央数据库（注册表）里面，这样程序的配置得到大大的简化。虽然在 Win95 的年代，注册表貌似老是惹麻烦，但现在基本上没有什么问题了。相反，Unix 的配置，全都记录在各种稀奇古怪的配置文件里面，分布在系统的各个地方。你搞不清楚哪个配置文件记录了你想要的信息。每个配置文件连语法都不一样！这就是为什么用 Unix 的公司总是需要一个“系统管理员”，因为软件工程师们才懒得记这些麻烦的东西。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">再来比较一下 Windows 和 Mac 吧。我认识一个 Adobe 的高级设计师。他告诉我说，当年他们把 Photoshop 移植到 Intel 构架的 Mac，花了两年时间。只不过换了个处理器，移植个应用程序就花了两年时间，为什么呢？因为 Xcode 比起 Visual Studio 真是差太多了。而 Mac OS X 的一些设计原因，让他们的移植很痛苦。不过他很自豪的说，当年很多人等了两年也没有买 Intel 构架的 Mac，就是因为他们在等待 Photoshop。最后他直言不讳的说，微软其实才是真正在乎程序员工具的公司。相比之下，Apple 虽然对用户显得友好，但是对程序员的界面却差很多。Apple 尚且如此，Linux 对程序员就更差了。可是有啥办法呢，有些人就是受虐狂。自己痛过之后，还想让别人也痛苦。就像当年的我。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我当然不是人云亦云。微软在程序语言上的造诣和投入，我看得很清楚。我只是通过别人的经历，来验证我已经早已存在的看法。所以一再宣扬别的系统都是向自己学习的 Apple 受到这样的评价，我也一点不惊讶。Mac OS X 毕竟是从 Unix 改造而来的，还没有到脱胎换骨的地步。我有一个 Macbook Air，一个 iPhone 5，和一个退役的，装着 Windows 7 的 T60。我不得不承认，虽然我很喜欢 Macbook 和 iPhone 的硬件，但我发现 Windows 在软件上的很多设计其实更加合理。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我为什么当年会鄙视微软？这很简单。我就是跟着一群人瞎起哄而已！他们说 Linux 能拯救我们，给我们自由。他们说微软是邪恶的公司…… 到现在我身边还有人无缘无故的鄙视微软，却不知道理由。可是 Unix 是谁制造的呢？是 AT&amp;T。微软和 AT&amp;T 哪个更邪恶呢？我不知道。但是你应该了解一下 Unix 的历史。AT&amp;T 当年发现 Unix 有利可图，找多少人打了多少年官司？说微软搞垄断，其实 AT&amp;T 早就搞过垄断了，还被拆散成了好几个公司。想想世界上还有哪一家公司，独立自主的设计出这从底至上全套家什：程序语言，编译器，IDE，操作系统，数据库，办公软件，游戏机，手机…… 我不得不承认，微软是值得尊敬的公司。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">公司还不都一样，都是以利益为本的。我们程序员就不要被他们利用，作为利益斗争的炮眼啦。见到什么好就用什么，就学什么。自己学到的东西，又不属于那些垄断企业。我们都有自由的头脑。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当然我不是在这里打击 Linux 和 Mac 而鼓吹 Windows。这些系统的纷争基本上已经不关我什么事。我只是想告诉新人们，去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">后记：“对用户友好”是一个值得研究，却又研究得非常不够的东西。很多 UI 的设计者，把东西设计的很漂亮，但是却不方便，不顺手。如果你想了解我认为怎样的设计才是“对用户友好的”，可以参考<a href="http://blog.sina.com.cn/s/blog_5d90e82f01014m7t.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">这篇博客</a>。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1113"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f6319" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">论对东西的崇拜</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在之前的几篇博文里面，我多次提到了 Lisp，它相对于其它语言的优势，以及 Lisp Machine 相对于 Unix 的优点。于是有人来信请教我如何学习 Lisp，也有人问我为什么 Lisp Machine 没有“流行”起来。我感觉到了他们言语中对 Lisp 的敬畏和好奇心，但也感觉到了一些隐含的怀疑。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这是一种复杂的感觉，仿佛我在原始人的部落兜售一些原子能小玩具，却被人当成了来自天外的传教士。敬畏和奉承，并不能引起我的好感。怀疑和嘲讽，也不能引起我的不平。当我看到有人说“别听他误导群众，学那些语言是找不到工作的”的时候，我心里完全没有愤怒，也没有鄙视，我也没必要说服他。我只是微笑着摇摇头，对自己说：可怜而可笑的人。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">不明白为什么，当我提到某个东西相对于另一个东西的优点的时候，我总是被人认为是在“推崇”某个东西，或者被人称为是它的“狂热分子”。现在显然已经有人认为我在推崇 Lisp 了，甚至在某个地方看到有人称我为“国内三大 Lisp 狂人之一”。他们仿佛觉得我推荐一个东西，就是想让他们完全的拥抱这个东西，而丢弃自己已经有的东西。而“支持”这另一个东西的人，也往往会产生敌视情绪。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人都不明白，每个东西都有它好的方面，也有它不好的方面。我推荐的只是 Lisp 好的方面，不好的方面我心里清楚，但是还没有机会讲。这些人显然已经在下意识里把“东西”当成了人。有人说“爱一个人就要爱她（他）的全部”，这是一种很无奈的说法，因为你没有能力把一个人分解成你喜欢的和不喜欢的两部分，然后重新组装成你的梦中情人。可是东西却不一样。因为东西是人造出来的，所以你可以把它们大卸八块，然后挑出你喜欢的部分。</p><p style="margin:0px 0px 20px;padding:0px;">所以我可以很清楚的告诉你，我并不推崇 Lisp，我也不是 Lisp 狂人，它只是我的小玩意儿之一。这个非常精巧的小玩意儿，包含了很多其它东西身上没有的优点。人们都说忘记历史就等于毁灭未来。如果 Java 没有从 Lisp 身上学会“垃圾回收”，C# 没有从 Lisp 身上学会 lambda，那么我们今天也许还在为 segfault 而烦恼，也许会继续使用没必要的 design patterns。如果你了解一点<a href="http://en.wikipedia.org/wiki/JavaScript" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">历史</a>就会发现，今天非常流行的 JavaScript，其实不过是一个“没能正确实现的 Scheme”。所以 Lisp 的精髓，其实正在越来越多的渗透到常用的语言里面。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">很多人没有设计程序语言的能力，所以他们把程序语言，操作系统一类的东西当成是不可改变的，凌驾于自己之上的。相比之下，我受到的训练却给了我设计和实现几乎任何语言的能力。我知道它们的优点和弱点，我有能力把它们大卸八十块，再组装还原。我有能力改变其中我不喜欢的地方，或者增加我觉得有必要的功能。当我谈论某个东西比另一个好的地方，总有人以为我在“抱怨”，说：“既然如此，那为什么你说的这个好东西被打败了？”他不明白，其实我只是在“分析”。我希望从各个东西里面提取出好的部分，然后想办法把它们都注入到一个新的东西里面。我也希望吸取前人教训，免得重犯这些东西里面的设计错误。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">如果在见识短浅的人们心目中，Paul Graham 和 Peter Norvig 算是“Lisp 牛人”的话，那么 <a href="http://blog.sina.com.cn/s/blog_5d90e82f010177qx.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Dan Friedman</a> 和 <a href="http://en.wikipedia.org/wiki/R._Kent_Dybvig" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">R. Kent Dybvig</a> 就应该被称为 “Lisp 天外来客”了。我不敢大言不惭的说我超过了恩师们，但我除了学到他们的真功夫之外，还偷学了一些他们不屑一顾的“旁门左道”。所以我经常能看到他们看不到的东西，我知道他们的弱点。他们对于 Lisp 的热爱，防止了他们看到它的一些缺点，但这些对于我却非常的清晰明了。然而也是因为他们对其它语言的不屑，才让我逐步的理解了，我曾经认为是优点的某些语言特征（比如 Hindley-Milner 类型系统），其实是缺点。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以，我其实并不是那么热心的希望有更多的人用 Lisp，Haskell 或者其它什么语言。我不会，也没那工夫去分享自己的秘诀。我没有责任，也没有能力去拯救世界。这是一种找到巨大宝藏的感觉，我蹲在一堆堆的财宝上休养生息。我知道世界上即使没有了我，太阳明天照样会升起。我为什么要那么热心的让别人也知道如何进入这个宝藏？我不是一个特别自私的人，但我也不需要推销什么。这就像我介绍了我的“减肥成功经验”，你觉得太辛苦，偏要去买那些吹得神乎其神的减肥药。我有什么动机来说服你呢？又不是我身上的肥肉。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">推崇一个东西，为一个东西狂热，这些感情都在我身上存在过。也许它们确实给我带来了一些益处，让我很快的学会了一些东西。但是这些感情的存在，其实也显示了一个人的弱小。当一个人没有办法控制一个东西的时候，他就会对它产生“崇拜”的心理，这就像所有的宗教和迷信一样。当人们处于自然灾害的凌威之下，没有能力掌握自己命运的时候，他们就对神和超自然的力量产生了崇拜。这是一种心灵的慰藉，至少有上帝或者观音菩萨，可以聆听他们的心声，可以给予他们度过灾难的勇气，但它同时也显示出人的无助和自卑。这种无助和自卑，也引发了偏激的宗教心理，因为他们害怕自己的“保护神”被别人的“保护神”所压倒，以至于让自己受制于他人。这是一种愚昧和卑劣的感情。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可是当你拥有了强大的力量，可以不再畏惧的时候，这种崇拜，以及由于崇拜所带来的偏激心理，就渐渐的消亡了。这就像是一个身怀绝世武功的人，他完全没必要让别人都相信他是高手。因为他知道，自己在谈笑之间，就可以让樯橹灰飞烟灭。于是，他自得其乐，对别人表现出的任何感情，都变得淡漠和无动于衷。</p></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="1117"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bfcd" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">再别IU</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/2012103111583122.jpg" type="image/jpeg" height="326" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="490"/></p><p style="margin:0px 0px 20px;padding:0px;">　　经过这么几个月的考虑和准备之后，我放弃博士学位，离开 IU，离开学术界，已经成为了定局。2010年的时候，我已经因为类似的原因离开过一年。这一次的离去，应该是不再复返。</p><p style="margin:0px 0px 20px;padding:0px;">　　这个美丽的校园，包含着我最美好的一些记忆，可是留在这个学术系统里，却给我带来了持久的痛苦。真正的学术自由，其实早已不存在于学术界了，我又何苦为你继续拼命呢？也许我在这里学到很多东西，可是在达到深入的理解之后才发现，其实在华丽的“新概念”背后，很少有人在做真正有意义的研究。为了毕业，为了凑够学分，我们被迫去做很多毫无意义的事情，浪费自己的宝贵时间。看到助理教授们身上的压力，急于表现的动机，以及他们转嫁到学生们身上的压力，我就看到了我的未来。为了一个“Professor”的头衔，为了冠冕堂皇的“学术交流”，竟然有人愿意忍受如此没有回报，没有安全感的生活。</p><p style="margin:0px 0px 20px;padding:0px;">　　我虽然没有直说，但是之前做的<a href="http://blog.sina.com.cn/s/blog_5d90e82f0101cv55.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">类型系统讲座</a>以及之前贴出来的 <a href="http://blog.sina.com.cn/s/blog_5d90e82f0101cdkn.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">oral exam 幻灯片</a>，包含了对本领域的绝大部分人来说前所未知的，根源性的发现。我有足够的底气说这样的话，因为我清楚的知道各个重要人物都做了些什么，我也清楚的知道自己看见了他们看不见的东西。虽然我现在像儿戏一样把我最重要的思想“免费送人”，可是这里面其实凝聚了我自己多年的心血。到最后我却惊讶的发现，深入的见解，原来远远不及某些权威的几句话。我感觉撞到了一堵墙，一堵人类认知的墙。智慧和愚昧，原来只隔着那么薄薄的一层，让你琢磨不透。权威，名气和令人困惑的术语，真是不可思议的东西，它们掩盖了许许多多显而易见的东西。我曾经成为了他们的同类，用一堆术语来压制人，可是我再也不是了。我想让这些简单的原理回到它们原来的面貌，尽快被人理解，从而对世界产生实际的作用。</p><p style="margin:0px 0px 20px;padding:0px;">　　还有一个多月就要别了，IU。我会用最后的时间去欣赏你花园一般美的校园，友善的同学，舒适安静的生活。无知是一种幸福，因为它让你感觉还有很多东西可以探索，所以我希望在不久的将来进入一个我从未探索的领域。我知道前面的路还很曲折，可是我也看到了机遇和挑战。</p><p style="margin:0px 0px 20px;padding:0px;">　　最后送给正执着于研究的人们几句话。人活着其实不是为了研究，也不是为了技术，也不是为了别的什么非生命体。人活着是为了自己，以及自己关心的人。放慢你匆忙的脚步吧，多多关心身边的人。愿学术界以内和以外的人们都过得幸福！</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1123"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bffb" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是社会主义</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">从小学开始，我们就被“政治”课本灌输着这样的教条：“社会主义和共产主义是历史的必然”，“当生产关系不能适应生产力发展需要的时候，社会就会发生变革”。然后就扯到“有中国特色”那些烂东西去了。但是在我看来，抛开别有用心的人夹杂在其中的谬论，真正的“社会主义”其实是有深刻的道理的，而且这道理是显而易见的。当今社会存在的这么多问题，其实归根结底就是这同一个问题：生产力与生产关系的矛盾。<br/><br/></p><p style="margin:0px 0px 20px;padding:0px;">我不想空谈什么理论，而只想进行一些很简单的分析和推理：<br/><br/>
1. 在原始社会的时候，由于人们的狩猎只能勉强满足自己和家人的需要，所以每个人都得工作。因为人们的收入根本没有结余可以被剥削，所以也不可能存在“人剥削人”的现象。你把我打来的猎物拿走了，你拿什么来养活我？不跟你拼了才怪。所以说“剥削”只可能存在于人们的劳动除了满足生存，还有结余的社会。<br/><br/>
2. 产生了农业之后，人们的劳动有了结余，所以出现了一部分人把另外一部分人作为奴隶的现象。奴隶主不喜欢工作，就指挥奴隶去工作，就像操作机器一样。奴隶只得到最少的生活必需品，他们没有自由。从计算机科学的角度来看，这是一种非常落后的“紧耦合”的系统设计。因为自由是人最基本的需要之一，所以只要有机会，奴隶们就会不惜代价来得到它。这样其实奴隶主的生活也不好过。<br/><br/>
3. 所以后来就产生了“封建社会”和“资本主义”社会。这两种社会都采用了一种更先进的“松耦合”的系统设计。在封建社会，因为农民要吃饭要住房子，所以虽然有自由，却不得不给地主干活。资本主义社会把这种关系放得更松了一些，用金钱来形成这道“无形的锁链”，这有点像消息传递 (message passing) 的并行系统。因为人要吃饭必须花钱买，住房子要交租金，而只有工作才能得到钱。所以人们虽然有自由，却“自愿”的来给你工作。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
4. 工业革命之后，社会的生产力得到了突飞猛进的发展，因为机器代替了人去做很多繁重枯燥的劳动。现在问题来了：当发明一种新的机器之后，原来每个人每天需要 8 个小时的工作，现在只需要 4 个小时就能完成。这本来看起来是相当美好的事情，因为每个人每天只需要工作 4 个小时了。可是落后的生产关系，却让一半的人继续每天工作 8 个小时，而让另一半的人失业。这是多么荒唐的事情！从并行计算的角度来看，这就是并行度低下。本来完全利用 1000 个计算节点，只用 4 个小时就算完的东西，结果只用上 500 个节点，算了 8 个小时！<br/><br/>
注意那一半失业的人。由于他们没有收入，所以他们就不去消费，而且到处滋事。没有失业的人也有了危机感，从而减少消费。他们不消费，下游的各种经济就发生阻塞：吃的，喝的，玩的，用的…… 所以就出现了今天我们看到的一些怪现象，以至于经济危机。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这种生产关系的不合理也会阻碍技术的发展。比如在 IT 业，有些时候我们明明有了更先进的技术，但是却迟迟得不到广泛的应用。很多人会强烈反对使用那些可以减少程序 bug 的语言或者程序验证工具，因为他们就是靠那些 bug 活着。如果你一下子把大部分 bug 消灭了，一个月写出别人好几年才写得出来的程序，有多少人会失业啊！所以他们即使知道新的技术比旧的好，也会装作不知道。大公司的效率低下和官僚主义，也就是这个原因。让系统开始 build，我们就去喝茶。这不能怪他们，而只能怪这个不合理的生产关系。<br/><br/>
但是技术的进步却是挡不住的历史潮流，机器只会越来越多的取代人的劳动，不管是体力劳动还是脑力劳动。人工智能，并行计算，机器人，…… 这些东西其实就是人忠实的奴隶，它们本来可以让每个人都过上“贵族”的生活，而不用担心机器会起来造反。可是落后的生产关系却让一部分“贵族”来剥削另外一些“贵族”，而且这种剥削愈演愈烈。这显然是不可能长久的。<br/><br/>
所以总有一天我们会实现“社会主义”。在这样的社会里，机器取代了人去做大部分的劳动，保障每个人的衣食住行。人们在受到高度发达的教育之后，每天自愿的进行短时间的有意义的工作，比如操作某种机器，或者进行科学研究，或者设计新的机器，或者进行艺术创造，或者为其他人服务。人们工作的原因是因为与人合作带来的乐趣，以及对社会做出贡献所带来的成就感，而不是因为工作可以让他们可以填饱肚子。所以人们选择自己喜欢的行业，而不是一味的去追求“热门”。很多人的工作变得跟娱乐差不多。那如果有人不工作怎么办呢？那就随他去了。别人都在开心的工作，所以他会没有“共同语言”。总有一天他会觉得孤独无聊，然后就会自愿的找事情来做。</p><p style="margin:0px 0px 20px;padding:0px;"><br/>
那么我们要起来“革命”吗？如果社会主义是历史的必然，那么它总有一天会到来的。所以我觉得它会是像“工业革命”一样的革命，而不是一场战争。它也不会在贫穷和文化落后的国家实现。它的实现只有在物质和文化水平到达相当高度的国家和地区，只有当人们的总体觉悟到达一定高度，只有当每个人都懂得什么叫做“给予”，并且知道这种给予会给自己带来回报和快乐。当然，这样的社会也需要我们来“设计”，就像设计一个机器一样，而不是高喊什么口号就可以达到的。应该有一种有条理，有计划，非破坏性的“过度程序”可以成功的将已有的社会转变为社会主义社会。而它的正常运转所需要的制度，需要经过科学的研究和设计，才能防止少数人的邪恶毁掉整个社会。另外，如何保证人们有足够的工作积极性，也是一个需要考虑的问题。<br/><br/>
有时候我很羡慕美国的小动物们，比如松鼠，花栗鼠和很多鸟。由于人类驱走了它们的天敌，并且到处都种下橡树，核桃树，桑树，…… 它们从来不缺吃的和住的地方。干嘛要给别人工作呢？上天给了我短暂的生命，我就应该利用它来感受这个美好的世界。相比之下，人类真是相当的愚蠢。我真希望人类有一天能找到一个完善的解决方案，让自己也像这些小动物一样幸福。</p></div></div></div></div></div></div></div></div><span style="text-align:center;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div><br/></div>
</div>
<hr>
<a name="1128"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:&amp;amp;apos;Hiragino Sans GB&amp;amp;apos;, &amp;amp;apos;Hiragino Sans GB W3&amp;amp;apos;, &amp;amp;apos;Microsoft YaHei&amp;amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f6312" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">谈“P=NP?”</a></div></div><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;"><div style="margin:0px;padding:0px;"><div style="margin:60px 0px 0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“P=NP?” 通常被认为是计算机科学最重要的问题。有一个叫 <a href="http://www.claymath.org/millennium/P_vs_NP/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Clay Math</a> 的研究所，甚至悬赏 100 万美元给解决它的人。可是我今天要告诉你的是，这个问题其实是不存在的，它根本不需要解决。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我并不是第一个这样认为的人。在很早的时候就有个<a href="http://www.math.rutgers.edu/~zeilberg/Opinion98.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">数学家</a>毫不客气的指出，P=NP? 是个愚蠢的问题，并且为了嘲笑它，专门在愚人节写了一篇“<a href="http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimPDF/pnp.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">论文</a>”，称自己证明了 P=NP。我身边有一些非常聪明的人，他们基本也都不把这问题当回事。如果我对他们讲这些东西，恐怕是 TOO OLD。可是我发现国内的计算机专业学生，提到这个问题总是奉为神圣，一点玩笑也开不得，所以我打算在这里科普一下。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这是一个不大好解释的问题。首先，你要搞清楚什么是“P=NP?” 为此，你必须先了解一下什么是“算法复杂度”。为此，你又必须先了解什么是“算法”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你可以简单的把“算法”想象成一台机器，就跟绞肉机似的。你给它一些“输入”，它就给你一些“输出”。比如，绞肉机的输入是肉末，输出是肉渣。牛的输入是草，输出是奶（或者牛米田共）。“加法器”的输入是两个整数，输出是这两个整数的和。“算法理论”所讨论的问题，就是如何设计这些机器，让它们更加有效的工作。就像是说如何培育出优质的奶牛，吃进相同数量的草，更快的产出更多的奶。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">通常所谓的“计算问题”，都需要算法经过一定时间的工作（也叫“计算”），才能得到结果。计算所需要的时间，往往跟输入的大小有关系。你的牛吃的草越多，它就需要越长时间，才能把草都变成奶。这种草和奶的转换速度，通常被叫做“算法复杂度”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">算法复杂度通常被表示为一个函数 f(n)，其中 n 是输入的大小。这个函数的值，通常是某种资源的需求量，比如时间或者空间。比如，如果你的算法时间复杂度为 n2，那么当输入10个东西的时候，它需要 100 个单元的时间才能完成计算。当输入 100 个东西的时候，它需要 10000 个单元的时间才能完成。当输入 1000 个数据的时候，它需要 1000000 个单元的时间。简单吧。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所谓的“P时间”，就是“Polynomial time”，多项式时间。简而言之，就是说这个复杂度函数 f(n) 是一个多项式。多项式你该知道是什么吧？不知道的话就翻一下中学数学课本。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“P=NP?”中的“P”，就是指所有这些复杂度为多项式的算法的“集合”，也就是“所有”的复杂度为多项式的算法。为了简要的描述以下的内容，我定义一些术语：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“f(n) 时间算法” = “能够在 f(n) 时间之内，解决某个问题的算法”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">当 f(n) 是个多项式（比如 n2）的时候，这就是“多项式时间算法”（P 时间算法）。当 f(n) 是个指数函数（比如 2n）的时候，这就是“指数时间算法”（EXPTIME 算法）。很多人认为 NP 问题就是需要指数时间的问题，而 NP 跟 EXPTIME，其实是风马牛不相及的。很显然，P 不等于 EXPTIME，但是 P 是否等于 NP，却没有一个结论。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">现在我来解释一下什么是 NP。通常的计算机都是确定性（deterministic）的，它们在同一个时刻只能有一种行为。如果用程序来表示，那么它们遇到一个条件判断（分支）的时候，只能一次探索其中一条路径。比如：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">if (x == 0) {</p><p style="margin:0px 0px 20px;padding:0px;">  one();</p><p style="margin:0px 0px 20px;padding:0px;">} else {</p><p style="margin:0px 0px 20px;padding:0px;">  two();</p><p style="margin:0px 0px 20px;padding:0px;">}</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这里，根据 x 的值是否为零，one() 和 two() 这两个操作，只有一个会发生。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">然而，有人幻想出来一种机器，叫做“非确定性计算机”（nondeterministic computer），它可以同时运行这程序的两个分支，one() 和 two()。这有什么用处呢？它的用处就在于，当你不知道 x 的大小的时候，根据 one() 和 two() 是否“运行成功”，你可以推断出 x 是否为零。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这种非确定性的计算机，在“计算理论”里面叫做“非确定性图灵机”。与之相对的就是“确定性图灵机”，也就是通常所谓的“计算机”。其实，“图灵机”这名字在这里完全无关紧要。你只需要知道，非确定性的计算机可以同时探索多种可能性。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">这不是普通的“并行计算”，因为每当遇到一个分支点，非确定性计算机就会产生新的计算单元，用以同时探索这些路径。这机器就像有“分身术”一样。当这种分支点存在于循环（或者递归）里面的时候，它就会反复的产生新的计算单元，新的计算单元又产生更多的计算单元，就跟细胞分裂一样。一般的计算机都没有这种“超能力”，它们只有固定数目的计算单元。所以他们只能先探索一条路径，失败之后，再回过头来探索另外一条。所以它们似乎要多花一些时间才能得到结果。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">到这里，基本的概念都有了定义，于是我们可以圆满的给出 P 和 NP 的定义。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">P 和 NP 是这样两个“问题的集合”：</p><p style="margin:0px 0px 20px;padding:0px;">  P  =   “确定性计算机”能够在“多项式时间”解决的所有问题</p><p style="margin:0px 0px 20px;padding:0px;">  NP = “非确定性计算机”能够在“多项式时间”解决的所有问题</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">（注意它们的区别，仅在于“确定性”或者是“非确定性”。）</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">定义完毕。现在回到对“P=NP?”问题的讨论。</p><p style="margin:0px 0px 20px;padding:0px;">“P=NP?”问题的目标，就是想要知道 P 和 NP 这两个集合是否相等。为了证明两个集合（A 和 B）相等，一般都要证明两个方向：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">1. A 包含 B</p><p style="margin:0px 0px 20px;padding:0px;">2. B 包含 A</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你也许已经看出来了，NP 肯定包含了 P。因为任何一个非确定性机器，都能被当成一个确定性的机器来用。你只要不使用它的“超能力”，在每个分支点只探索一条路径就行。所以“P=NP?”问题的关键，就在于 P 是否也包含了 NP。也就是说，对于所有的非确定性多项式时间算法能解决的问题（NP），能否找到确定性的多项式时间算法。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我们来细看一下什么是多项式时间（Polynomial time）。我们都知道，n2 是多项式，n1000000 也是多项式。多项式与多项式之间，却有天壤之别。把解决问题所需要的时间，用“多项式”这么笼统的概念来描述，其实是非常不准确的做法。在实际的大规模应用中，n2 的算法都嫌慢。能找到“多项式时间”的算法，其实根本不能说明问题。</p><p style="margin:0px 0px 20px;padding:0px;">对此理论家们喜欢说，就算再大的多项式(比如 n1000000)，也不能和再小的指数函数（比如 1.0001n）相比，因为总是“存在”一个 M，当 n &gt; M 的时候，1.0001n 会超过 n1000000。可是问题的关键，却不在于 M 的“存在”，而在于 它的“大小”。如果你的输入必须达到天文数字才能让指数函数超过多项式的话，那么还不如就用指数复杂度的算法。所以，“P=NP?”这问题的错误就在于，它并没有针对我们的实际需要，而是首先假设了我们有“无穷大”的输入，有“无穷多”的时间和耐心，可以让多项式时间的算法“最终”得到优势。“无穷”和“最终”，就是理论家们的杀手锏。</p><p style="margin:0px 0px 20px;padding:0px;">为了显示这个问题，我们可以画一个坐标曲线，来比较一下 n1000000 与 2n，并且解出它们相等时的 n。我不用 1.0001n 来比，免得有人说我不公平。我喜欢偷懒，经常用 Mathematica 来解决这些算式。下面就是我用它得出的结果和曲线图：</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://photo.blog.sina.com.cn/showpic.html#blogid=5d90e82f0101jiwf&amp;amp;amp;url=http://s14.sinaimg.cn/orignal/5d90e82fgd88e87f8441d" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/5d90e82fgd88e87f8441d&690.png" type="image/png" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="220"/></a></p><br/><p style="margin:0px 0px 20px;padding:0px;">你看到了，当 1 &lt; n &lt; 24549200 的时候，我们都有 2n &lt; n1000000 （n1000000 那根曲线，一超过1就冲上天去了）。 所以只要输入没有达到2千万这个量级，2n 的算法都比 n1000000 的算法快。</p>
n1000000 也许不说明问题，但是“多项式”的范围实在太大了。n10100 ，n1010100，…… 都是多项式。实际上，只要 c 是个常数，任何常数，nc 就是个多项式。
<p style="margin:0px 0px 20px;padding:0px;"><br/></p>
你能想象 n 需要多大，2n 才能超过 n10100 吗？当 n=2 的时候，n10100 就是 210100。你也许已经意识到，这个数相当于 2n 复杂度的算法，接受了 10100 个输入。如果你知道 10100（1的后面跟100个0）已经大于宇宙中基本粒子的数目，你也许就会意识到，这是在计算宇宙里所有的粒子的“幂集”（power set），也就是在枚举宇宙里所有粒子的所有组合。通俗一点说，就是在枚举宇宙里所有可能出现的物体。当任何超级电脑完成这个任务的时候，宇宙恐怕都已经不存在了。况且这个计算是根本无法完成的，因为即使每个粒子可以提供一次计数所需要的能量，你会在还没有数到 10100 的时候就用光宇宙里所有的能量。最后，因为这两个 n 是同步的，所以当 2n 的输入是 10100 的时候，n10100 等于 (10100)10100。所以即使枚举了宇宙里所有可能出现的物体，2n 仍然远远落后于 n10100。
<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">你也许发现了，其实上面的论述根本没必要用 n10100 这么大的多项式，只要用一个很大的常数（比如 10100）就够了，因为常数也算是多项式。使用多项式的原因，只是想演示一下多项式可以有多大。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以你看到了，常数，指数，输入的大小，对于算法的性能都是很关键的。“P=NP?”的问题就在于它用“多项式”这个笼统的概念抹杀了所有这些细节，以至于即使 P=NP 被证明出来，我们仍然不会得到可以实用的结果。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">正确的做法，应该是找到整个算法（代码）的具体的复杂度函数，最好细致到常数。比如 3.65n2 + 21n + 1000，做出类似上面所示的曲线图，然后根据具体输入的大小，看看哪个算法更快一些。在这一点上，Knuth 在 TAOCP 中对算法的细致入微的分析，确实是我们的榜样（虽然我不赞成他使用机器语言）。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p></div></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="1134"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px;padding:0px;-webkit-animation:fadein 1s;margin-bottom:25px;"><br/></div><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bfd1" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">清华综合征</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/2012110208445432.jpg" type="image/jpeg" height="312" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="303"/></p><p style="margin:0px 0px 20px;padding:0px;">　　我在清华的时候有一个很好的朋友，是北大的学生。我们都很喜欢运动，所以有时候一起玩滑板，跳街舞，打网球什么的。有一天打完网球她问我：“你怎么一点也不像清华的学生啊？我印象中的清华人不管做什么都想比别人强。连打网球这种娱乐活动都想练成专业的，动作要到位，角度要刁钻……所以跟他们玩起来一点也不轻松。看我们北大人，一拍子就把球拍飞…… ”</p><p style="margin:0px 0px 20px;padding:0px;">　　说实话，我确实不算是纯种“清华人”，因为我的本科不是在清华念的。可是这种处处追求“卓越”的特殊气质，不管是在清华还是在别的“牛校”（比如 Cornell），我还真是深有体会。虽然有点歧视的味道，但因为我是在清华才第一次感觉到这种气质的普遍存在，而且它貌似在毕业之后很长时间还伴随着清华学生，所以我暂时把它称为“清华综合症”吧。</p><p style="margin:0px 0px 20px;padding:0px;">　　清华综合症其实是一种心理疾病，因为患了这病的人很难开心起来。不管是否清华的学生，如果有如下情况，就应该考虑是否患了清华综合症。</p><p style="margin:0px 0px 20px;padding:0px;">　　症状1. 不管做什么都想做得最好，连唱歌跳舞这种娱乐活动都是。</p><p style="margin:0px 0px 20px;padding:0px;">　　症状2. 喜欢在聊天的时候提到自己认识的“牛人”，讲述他们如何如何的牛。</p><p style="margin:0px 0px 20px;padding:0px;">　　症状3. 参加了某学科竞赛之后就天天穿印有“X竞赛”字样的T恤衫，使用有竞赛标记的挎包一类的东西，或者使用竞赛的名字作为自己的网名前缀。</p><p style="margin:0px 0px 20px;padding:0px;">　　症状4. 对数字特别敏感：成绩，名次，学校排名，论文数，引用数，影响因子，……</p><p style="margin:0px 0px 20px;padding:0px;">　　……</p><p style="margin:0px 0px 20px;padding:0px;">　　我不得不承认，我自己也患过这病，以至于有一段时间别人都不想跟我说话，所以我对此病患者的痛苦深有体会。你没法快乐起来，因为连跳舞的时候你都在想，是否有其它牛人跳得比我好，所以我要练得更专业一些。你的朋友也是类似的人，所以聚会时你们总是在谈论各种“牛人”。明明打心眼里认为自己是最牛的，可是出于政治目的还得要吹捧一下别人。不管别人做了什么，总是说：“哇，好牛！”累不累啊？</p><p style="margin:0px 0px 20px;padding:0px;">　　我一直在思索这种病的由来。从小处于高度竞争的教育环境，应该是一个首要的因素。中国的孩子们从小就被拿来跟别人的孩子比，却没有真正的被教育。教育应该让人理解什么是“自己”的价值。每个人都有不同的价值，是不可以比较的。可是实际的教育却往往用一些固定的，不合理的标准来衡量一个人的价值。久而久之，这些标准就在被教育者的心里面根深蒂固，让他们永远也跳不出圈套。等他们有了儿女，就把这些标准传递给下一代，然后扩散到整个民族。</p><p style="margin:0px 0px 20px;padding:0px;">　　课业成绩，竞赛名次，论文数量，……</p><p style="margin:0px 0px 20px;padding:0px;">　　这些真的能衡量一个人的价值吗？古人云，宠为下，得之若惊，失之若惊。是谓宠辱若惊。有多少人做到了“宠辱不惊”呢？闭着眼睛按照他人的标准生活，这难道不像是带着眼罩帮别人拉磨的驴吗？为什么我们不是“设定”标准的人，而是“服从”标准的人呢？那些设定标准的人是谁，他们真的有资格来评价我们吗？我们能想出什么办法打破别人给我们设定的标准，翻身成为自己的主人呢？</p><p style="margin:0px 0px 20px;padding:0px;">　　我想每个人都应该思考一下这些问题了。</p></div></div></div></div></div></div></div></div></div></div></div></div>
</div>
<hr>
<a name="1140"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_4cbe14" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Oberon 操作系统：被忽略的珍宝</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">推荐一篇很久以前看的文章：<a href="http://www.ics.uci.edu/~franz/Site/pubs-pdf/BC03.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Oberon - The Overlooked Jewel</a></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">它介绍的是 Niklaus Wirth 设计的一种操作系统，叫做 Oberon。Niklaus Wirth 就是大家熟知的 Pascal 语言的设计者。绝大部分人都没听说过有 Oberon 这个东西存在，更难以把它跟 Niklaus Wirth 的大名挂上钩。所以作者说：“Wirth 因为 Pascal 而闻名于世，可是接下来几年，他成为了 Pascal 的受害者。” 确实是这样。Wirth 一直都不觉得 Pascal 是他的杰作。我想他应该会更喜欢以 Oberon 闻名于世。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">Oberon 比起 Unix，有很大的不同，在于它的数据都是结构化的。进程间不通过字符串交换数据，而是直接使用数据结构。很奇特的一点是，Oberon 操作系统是用一种同名的程序语言（Oberon 语言）写成。令人惊讶的是，在那个年代，ETH 计算机系的所有教职员工，学生，包括办公室的大妈，都是用的这种操作系统。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">操作系统的设计，真是天外有天。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">之所以找到这个系统，是因为我一直在试图利用程序语言的设计原理，设计一种超越“Unix 哲学”的操作系统。这里是我的设想：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">这种系统里面的程序间通信不使用无结构的字符串，而是使用带有类型和结构的数据。在这样的系统里面，“程序”的概念基本上完全消失。系统由一个个的“函数”组成，每个函数都可以调用另外一个函数，通过参数传递数据。每个函数都可以并发执行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于参数是一个数据结构，而不是字符串，这避免了程序间通信繁琐的“编码”和“解码”过程。使得“进程间通信”变得轻而易举。任何函数都可以调用另一个函数来处理特定类型的数据，这使得像 “OLE 嵌入”这样的机制变得极其简单。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">所有函数由同一种先进的高级程序语言写成，所以函数间的调用完全不需要“翻译”。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于这种语言不允许应用程序使用“指针运算”，应用程序不可能产生 segfault 一类愚蠢的错误。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">由于没有指针运算，系统不再需要现代处理器提供的“内存映射”机制，以及 TLB。这使得内存访问效率大幅提高。而且简化了处理器的设计。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">操作系统使用与应用程序相同的高级语言写成（可能需要支持一些“特权操作”），至于“系统调用”，只不过是调用另外一个函数。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">操作系统的“shell”，不过是一个这种高级语言的 REPL。用户可以在终端输入各种函数调用，从而启动进程的运行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">系统不需要 SQL，不需要关系式数据库。所有的数据都作为“对象”，保存在一个分布式的数据空间。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">系统不需要“文件系统”。所有的数据，包括“进程上下文”自动被“版本控制”，在合适的时候作为对象同步到磁盘。所以即使在机器掉电的情况，绝大部分的数据和进程能够在电源恢复后自动继续运行。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">程序员和用户完全不需要知道“数据库”或者“文件系统”的存在。程序假设自己拥有无穷大的空间，可以任意的构造数据。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">为了减少数据的移动，系统根据数据的位置，选择： 1）迁移数据，或者 2）迁移处理数据的“进程”。程序员不需要使用 MapReduce，Hadoop 等，就能进行大规模并行计算。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">这个操作系统是如此的“一致”，以至于所有的用户和程序员，只需要学会一种很简单的程序语言。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我曾经以为我是第一个想到这个做法的人。可惜的是，调查之后发现，很多人早就已经做出了类似的系统（虽然缺少对把它用于分布式计算的设想）。Lisp Machine 似乎是其中最接近的一个。Oberon 是另外一个。我只能说，英雄所见略同。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1141"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_5c5631" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">Google 到底是什么问题</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">有人也许看过我以前对 Google 的评论。虽然它说出了实情，但也带有一些我自己的主观情绪。如果你想从另一个角度看看 Google 的问题，可以参考一下 James Whittaker 的博文《<a href="http://blogs.msdn.com/b/jw_on_tech/archive/2012/03/13/why-i-left-google.aspx" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Why I left Google</a>》。这个 James 当时是 Google 主管 test 的 director，是我在 Google 的前老板的老板。我从来没跟他仔细说过话，所以我不能对他做出任何评价。这个文章仅供参考。</p><p style="margin:0px 0px 20px;padding:0px;">现在我在一个跟 Google 很不一样的公司工作。我虽然不能说很喜欢这里，但是它却没有 Google 的一些让我匪夷所思的特征。大家说话都直截了当，并不对自己的公司顶礼膜拜。在经过冷静的思考，以及与一些人的讨论之后，我觉得我应该对 Google 做出一个客观的分析，以便帮助大家找到适合自己的工作环境。在 Google 的朋友也许也能从中得到反馈，从而可以对自己的公司进行一些力所能及的改进。</p><p style="margin:0px 0px 20px;padding:0px;">在我上次批评 Google 之后，收到了一位老同学的反馈。他说有几个 Google 的朋友看了我的文章很气愤，说我“让他们显得很丑陋”。我觉得很奇怪，因为我根本就不认识这几个人，更不可能对他们有什么恶意，为什么批评 Google 就会引起“Google 员工”的如此强烈的反应呢？仔细想一下，如果我批评的不是 Google 而是麦当劳，那麦当劳的员工会有如此反应吗？</p><p style="margin:0px 0px 20px;padding:0px;">显然，Google 的很多员工已经失去了自我，把 Google 等同于了自己，所以他们才会对我的评价做出如此反应。Google 所做的一切，他们都不加判断的接受。Google 设计的所有东西，他们都认为是世界上最先进的技术。其实我对 Google 的工作环境唯一的反感之处，就是很多 Google 员工像是生活在中国的文化大革命时代，像“祖国花园里的花朵”一样天天向上，为 Google 高唱赞歌。Google 的“河蟹力量”，连中国共产党恐怕都自愧不如。</p><p style="margin:0px 0px 20px;padding:0px;">其实有一位曾经在 Google 工作的朋友（名字我为他保密）来信告诉我，我的感觉一点也没错，因为他当时在 Google 也是同样的感受，独立的人格和思维，在 Google 仿佛趋于消亡。最近跟另一个公司的朋友谈到这问题，他也说 Google 确实是这样的。他的一些朋友进了 Google 之后就仿佛完全变了一个人，连他都不敢相信这些人曾经是他的朋友。按他的话说，就是被“洗脑”了。</p><p style="margin:0px 0px 20px;padding:0px;">也许在技术上 Google 做出了一些好东西，但是在“公司文化”上，Google 确实有很严重的问题：Google 具有过于强烈的同化力量，这种力量使得员工失去自我，完全任由公司的意志所左右。这个问题的源头，貌似谁也没法说清楚。所以关于这些人是怎么被洗脑的，这位朋友开玩笑说，“肯定是因为那些免费的食物里面有什么特殊的东西。”</p><p style="margin:0px 0px 20px;padding:0px;">最后我再次声明，这只是我对 Google 作为一个公司的评价，跟 Google 的员工个人没有任何关系。他们虽然为公司工作，但我更愿意把他们作为独立的，不带有任何标签的人看待。当然我在这里发表的观点跟我所在的公司没有任何关系。虽然我为一个公司工作，但是我的思想是独立于任何公司的。我永远不属于任何公司，也不属于任何其他人。我只属于我自己。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1142"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_5c5614" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">程序语言专家的苦恼</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我的老师 Dan Friedman 曾经告诉我一句话。他说，成为一个程序语言专家之后，你就会遇到这样的问题，你会感觉到自己是</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">&quot;a programming language expert in a world where nobody knows what one is and what one does&quot;</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">“一个程序语言专家，生活在一个没有人知道什么是程序语言专家，以及他们做什么的世界上”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">翻译过来好像不大通顺，不过也就是那个意思。我的感觉是这样，世界上有太多的人，打着各种各样的术语和口号，冒充程序语言专家，或者自以为懂了，但却不真的懂，以至于没有人知道谁是真正的程序语言专家。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1146"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47a14a" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">我和Google的故事</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">也许有人看见过我批判 Google 的那篇英文文章。它有一部分片面性，所以被我从英文<br/>博客上拿下来了。我一直在反思自己在 Google 的经历，也许现在用自己的母语，我可<br/>以得出一个准确一点的结论吧。<br/><br/>也许有人觉得作为一个读了这么多年的 PhD 去给别人做实习生（intern）是一种耻辱<br/>，但是我亲眼看到，从一些名校比如 Yale 毕业的 PhD，在 Google 混了好几年，也不<br/>过是过着差不多的生活。只不过做了 intern 之后我长了经验，知道了自己的价值，以<br/>后不至于落到同样的位置。<br/><br/>这里我就讲述一下我在 Google 的实习经历吧，也许对人有参考作用。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">受命于危难</strong></p><p style="margin:0px 0px 20px;padding:0px;"><b style="font-size:100%;font-weight:bold;"><br/></b>先说说我的项目是怎么开始的吧。当我加入的时候，我的老板 Steve Yegge 的小组试<br/>图制造一个跨语言的“服务式”的编程工具，叫做 Grok。你可以把它想象成 Eclipse,<br/>但是 Grok 的设计目标不只是像 Eclipse 那样检索和分析本机的某一种语言的代码，<br/>而是大规模的检索和分析 Google 的所有项目，所有语言，所有代码。这包括 Google <br/>的“四大语言”：C++, Java, JavaScript, Python，一些工具性的语言：Sawzall，<br/>protobuf 等，还有一些“build file”和所有第三方的库。Grok 的初期设计目标是一<br/>个静态的代码索引服务，只要程序员点击任何一个变量或者函数名，就能“准确”的跳<br/>转到它定义的位置。动态的编辑功能稍后也在陆续加入。<br/><br/>这种检索不是像 ctags, etags 那种简单的正则表达式匹配，而是像 Eclipse 和 <br/>Visual Studio 那样的准确的“语义检索”，所以它必须真正的理解程序语言的语义。<br/>在 Grok 诞生以前，市面上和 Google 内部都没有一个工具能正确的支持所有“四大语<br/>言”，所以我不得不说，Steve 的项目比起 Google 的其他更编程语言相关的项目，是<br/>相当先进的。<br/><br/>虽然 Grok 的技术含量很高，但是 Google 的管理层对东西的评价并不是看技术含量的<br/>，而是看你有多少“影响力”(impact)，说白了也就是有多少用户。Google 当时本来<br/>就只有不到一万个程序员，一个“内部编程工具”能有多少“用户”呢？所以 Grok 比<br/>起像 CodeSearch 一类利用正则表达式来查询程序的“低端”项目来说，在管理层心目<br/>中并不占任何优势。而且由于其它项目界面好看些，用户多些，Grok 随时有被取消的<br/>危险，这使得 Steve 心理压力很大。我就是在这个“危难关头”进入他们的小组的。<br/>我当然没蠢到会自己进入这样一个组，但是 Steve 在电话面试时把一切都说得很美好<br/>的样子。当时小组里只有三个人：Steve 和另外两个组员。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">恐惧和疑惑</strong></p><p style="margin:0px 0px 20px;padding:0px;"><b style="font-size:100%;font-weight:bold;"><br/></b>当我开始的时候，Grok 小组已经初步完成了 Java 和 JavaScript 的检索模块。但是<br/>他们的检索并不是从头设计的，而是从 Eclipse (JDT) 和 JSCompiler 里面分别“挖<br/>取”了对 Java 和 JavaScript 语义检索的部分，修改之后插入到项目里的。Eclipse <br/>的设计非常的不模块化，以至于项目进行了一年多，大家还在忙着解决它带来的各种 <br/>bug。<br/><br/>最开头的时候 Steve 给了我两个选择：检索 C++ 或者是 Python。我觉得 C++ 的设计<br/>太繁琐，所以就选择了看起来好一点的 Python。Steve 就让我去找一个好一点的开源<br/>的 Python IDE，然后把里面的语义检索部分挖出来插入到项目里面。可是在看过十个<br/>左右的“Python IDE”之后，我发现它们没有一个能够正确的“跳转到定义”。分析其<br/>原因，是因为这些 IDE 基本上做的是正则表达式匹配，而完全不理解 Python 的语义<br/>。所以我对 Steve 说，我要自己从头写一个。但他反对这个提议，因为他觉得这是三<br/>个月的时间之内不可能完成的。不但是我不能，而且就算一个小组的高级程序员也不可<br/>能完成。就算完成了，他也不想“维护”这些代码。所以他宁愿让我去拿一个不怎么样<br/>的开源项目，因为这样“维护”的工作就转嫁到开源项目身上去了。<br/><br/>可是我很清楚的看到，这样一个语义检索，不过是一个抽象解释器 (abstract <br/>interpreter)。写解释器是我最在行的，所以我告诉他这是我可以完成的，而且由于设<br/>计上的简洁，我的代码的维护代价会比使用一个开源项目小很多。他没有说话。我同时<br/>也在进行一些内部培训，看一些视频，折腾 MapReduce 一类的内部工具教程，就这样<br/>过了一个星期。我隐约的感觉到 Steve 的不快，因为他不怎么说话了，可是我也没有<br/>太在意，仍然傻乎乎的到处凑热闹。到了周五的时候，Steve 下午很早就回家了。另一<br/>个组员还待在哪里，不时的叹气。我对她说：“Steve 是不是不高兴了？我知道我说话<br/>有点太自信，可能打击到他了。”她好像打满的气球被开了一个洞：“他怎么会被你打<br/>击到？你知道他以前做的项目有多厉害吗？他是怕你做不出来。之前有一些 intern 设<br/>的目标太高，以至于到最后没有完成他们的项目。”于是她打开 Eclipse，把 <br/>JSCompiler 的代码给我看。“你知道我们以前一个类似的项目 JSCompiler，花了多少<br/>时间才完成吗？一个小组的人，四年的时间！”她打开其中一个文件，也就是处理符号<br/>表的那个模块，说：“看这一个文件就有 9000 多行代码。你三个月能写出这么多代码<br/>吗？”我翻了一下白眼，搞笑似地说：“啊～ 怎么可能有 9000 多行？这些人真的知<br/>道怎么写这种代码吗……”<br/><br/>后来具体的对话我忘记了，但是她说得那么神乎其神，确实给了我一些压力。再加上 <br/>Steve 那个闷声子，真是不好受。所以那个周末我没有出去玩，我下载了一个 Jython<br/>，把它的 parser 文件 (ANTLR) 拿出来。自己设计了一个更简单的 AST 数据结构，把<br/>这个 parser 生成的 AST 转换成我的结构。然后就开始在上面写一个抽象解释器。由<br/>于 Java 的限制，我想出了一个更简洁的用 Java 实现解释器的方法，从而避免了使用<br/>繁琐的 visitor pattern。一个周末之后，我做出了一个基本的原型。当然因为 <br/>Python 语言的复杂性，有很多细节的东西到后来才完全的实现。<br/><br/>等到星期一的时候，我告诉 Steve 我做了一个原型出来，而且因为我拿了 Jython 的 <br/>parser，我们以后可以用这个理由把这代码 merge 回 Jython，给他们提供功能，让他<br/>们帮我们维护代码，对两方都有好处。他居然一点也不高兴，把我叫到一个白板前面，<br/>板着脸说：“来，给我讲一下你打算怎么做。”我就画了一个 AST 的类关系图，在里<br/>面每个类插入一个叫 interp 的方法，然后指出这个东西就是一个解释器。最后他豁然<br/>开朗了一样，说：“好。我相信你知道你在干什么了。就这样做吧。” <br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">陌路</strong></p><p style="margin:0px 0px 20px;padding:0px;"><b style="font-size:100%;font-weight:bold;"><br/></b>在 Google 的整个夏天我都觉得跟其他人没有共同语言。我感兴趣的东西他们一点都不<br/>了解，所以我也不想谈。我觉得不以为然的一些东西，却被他们捧上了天。也许就是所<br/>谓“价值观”不一致。总体感觉就是过度“和谐”，见到什么都夸赞，没有人说真话，<br/>以至于你不知道到底什么好，什么不好。而且人们总是喜欢谈论一些人的显赫“地位”<br/>，以及传说他们如何的“牛”。比如，有一次几个人在谈论一个 Google 的“牛人”，<br/>说他做了一个多么了不起的项目，很快就升为了 Staff Software Engineer （“Staff<br/>”是比“Senior”高一级的职位，Steve 就是个 Staff）。我去看了一下这项目，发现<br/>不过就是 JUnit 的“C++ 版本”。JUnit 这东西技术含量本来就是相当低的，做这样<br/>一个东西就能当“Staff”，那我岂不是轻而易举就可以成为“Principal”了？哈哈。<br/>我心里这样想，但是没有说出来。一个 Staff 就如此，谈到 Google 的两个创始人的<br/>时候，有些人就简直是黑白不分了。对他们的各种武断的甚至不讲理的做法，居然都津<br/>津乐道。创始人在他们眼里俨然就跟皇帝一样，他们做什么都是对的，甚至有人以他们<br/>曾经的办公室在创始人的正下方为豪。这种浮夸和互相吹捧之风，恐怕是在其它公司也<br/>少见的。Google 要求员工们保持一种“Googley”的态度，原来就是这样的态度，过度<br/>“正面”和“积极”。美国所崇尚的“个人主义”和“批判性思维”，我在 Google 还<br/>真的没有见到过。 <br/><br/>另一些时候，我会遇到一些对某种语言或者技术有宗教情绪的人。有一次一个工程师坐<br/>到我面前，像是在面试我一样，正儿八经的开始自我介绍，后来我们就谈到 C++。我说<br/>C++ 设计实在是太繁琐了，其实很多简单的语言效率并不比 C++ 低，C++ 最近其实在<br/>向其它高级语言学一些东西…… 后来这人就不说话了。那天以后我就发现跟他打招呼<br/>他都不理了。后来我才发现，在 Google 是不可以指出某种语言，特别是 C++ 的缺点<br/>的。C++ 在 Google 的势力之大，连 Java 都只能算二流货色。<br/><br/>最搞笑的其实是 Google 总喜欢故弄玄虚，把一些微不足道的东西说得很玄乎。很多文<br/>档，视频，活动都挂着“Google Confidential”的标签。等你去看了，却发现其实是<br/>众所皆知的东西，没有什么机密可言。可是大部分的实习生们却有一种受宠若惊的感觉<br/>，以至于产生优越感。每个星期五，都会有一个“TGIF”，两个创始人会像主持人一样<br/>组织一个大会。本来无可非议，但是总感觉气氛过于群情激昂了，有点像小学的时候升<br/>国旗开大会的感觉。好不容易大家聚在一起，总是在听新闻发布，不然就是谈工作进度<br/>，不然就是表彰某些人。总之，你总是感觉到虚荣心或者自尊心在受到某种挑拨，有一<br/>种传销公司大会的感觉。真正大家轻轻松松一起玩的 party，却非常稀少。你总感觉 <br/>Google 在你的生活里无所不在。所以一些别的公司的人（比如我寄宿的房子主人）都<br/>在疑惑，Google 的员工到底有没有下班的时间。<br/><br/>我就是这样度过在 Google 的每一天，以至于后来我都不怎么在饭桌上吃饭了。自己把<br/>饭端到靠墙的吧台去吃，或者坐在“冰激凌吧”跟里面的厨师聊天，省得遇到一些高谈<br/>阔论的人无语。我发现自己跟打扫卫生的大妈小妹们也谈得来，她们也喜欢跟我说话。<br/>后来我发现有这种感觉的不只是我，另外两个比较厉害的博士生也懒的在那边吃饭了。<br/>其中一个说他一个星期就把自己的项目做完了，然后假装仍然在做，免得又被增加任务<br/>。这就是所谓“能者多劳”吧。掌握了核心技术的人，往往会有比一般程序员大几十，<br/>上百倍的效率，可是得到的“回报”却是更多的任务量和压力。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">皇帝的织布工</strong><br/><br/>虽然 Steve “允许”我自己从头做一个 Python 分析器，但是这却不是没有压力的。<br/>这种感觉就像是“皇帝的新装”里的织布工一样。我扬言自己会做出精美绝伦的布料，<br/>皇帝的大臣们却看不见，所以他们就相当的小心。总是对我很敬畏的样子，有时会来问<br/>候一下，做得怎么样了。可是一旦扯到深入的话题，却又怕被看穿其实他们不懂很多东<br/>西。因为我的教授们研究 Scheme，所以 Steve 有时候也会很激动的表扬 Scheme，或<br/>者类似 Scheme 的语言比如 Clojure。这种奉承真的让我受不了，生搬来的术语都是错<br/>乱的。为什么程序语言总是引起这种宗教的态度，不是抵制就是膜拜？<br/><br/>有一次一个 Staff Software Engineer 来访。看我在做这个 Python 分析器，很鄙夷<br/>的样子，说：“你做那个东西干什么。Python 本来是没有类型的，怎么推导得出类型<br/>来？我倒希望 Java 的类型推导做得更好一些，不用手写很多类型。”显然他不知道什<br/>么是类型推导，他也不知道如何把 Java 的类型推导做得更好。很多人把自己的命运寄<br/>托在语言的设计者身上，自己没有能力去改进它们，所以他们才会对程序语言顶礼膜拜。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">压力</strong><br/><br/>直到有一天，我才发现 Steve 为什么这么紧张。那天有另一个“分舵”的 director <br/>来访。他给我们做了一个关于“创新”（innovation）的演讲。基本内容就是说，技术<br/>上的创新，如果吸引不到用户，那就不算什么创新，拉得到用户的东西才叫创新。<br/><br/>那天下午，这个 director 来到我们的办公室。表情严肃的“审问”Steve：“你说你<br/>每天有 5000 个用户。可是 Google 总共还不到 10000 个程序员。你是怎么算的？你<br/>把接受你的服务的那些下游项目的用户全都算进去了吧！”唉，想不到大名鼎鼎的 <br/>Steve Yegge 在这种皇帝的钦差大臣面前也只能唯唯诺诺。<br/><br/>我可以说，这个 Python 的东西，虽然不费我很多力气，但却是 Google 里很少有人可<br/>以做出来的。就算 Python 的创造者 Guido van Rossum 恐怕也玄。所以实际上我的这<br/>个东西在很大程度上拯救了这个濒临灭亡的项目，因为一旦 Grok 支持所有的“Google<br/>语言”，就会有很多人注意到这个东西，从而会有“影响力”。这确实是后来发生的<br/>事，我走了之后，Grok 开始通过 API 给很多项目提供服务，包括 CodeSearch。<br/><br/>Google 给我的那点工资，其实是根本买不起这样的软件的。你可以参考一下像 <br/>CodeSonar 之类“静态分析”软件的价格，一份基本上就是我三个月的工资。由于我上<br/>学想找点外快，让他们捡了一个便宜。可是这种“上级领导”的压力居然也间接的传到<br/>了我身上，而且是以一种非常不尊重的方式。这种感觉就是，你做得再多再出色，你相<br/>对于 Google 的“大拿”们，什么都不算。这也许就是 Google 为什么雇佣 Dennis <br/>Ritchie, Brian Kernighan, Ken Thompson, Rob Pike, Guido van Rossum 等大牛吧<br/>。因为它就可以说：“看我们 Google 有这些顶尖牛人，你算个什么，要不断努力！”<br/>Steve 不止一次的对我说：“你要为 Google 做出杰出的贡献啊！Google 的东西总是<br/>最好的，你要做出 Google 一贯的品质来。你知道 Python 的创造者 Guido 也是 <br/>Google 的员工吗？我一定会在他面前给你美言几句。” 这种语气，我好像在几十年前<br/>的中国听说过呢？“你要为祖国做出杰出的贡献！”他也许以为我会受宠若惊，可是我<br/>心里却不是个滋味。<br/><br/>其它组员如果看我貌似心情比较轻松，也会不时的提一下：“这个做完了吗？如果这个<br/>做完了，你可以做那个。反正我们有的是事情给你做……” 我心里其实在想，你知道<br/>这东西的“难度”吗？符号表模块都要写 9000 行代码的人，你自己来做一下，看看一<br/>年之内你做得出来不。总之他们就是用这种奉承，利诱，竞争，加威胁的方式，想方设<br/>法让我多做事情。可是我心里想的是，Google 老爹，您就给了那么点钱，您想买多少<br/>东西啊？<br/><br/>本来这系统能做出来就不错了，一个组员却一直催着我写 test。她根本不明白，一个<br/>程序并不是写了测试就会是个好程序。这个程序经过我多次的大规模修改甚至推翻重来<br/>，即使一早写了测试，那些测试也会很快作废。这种大公司给人灌输的“test-driven<br/>”编程方式，在这种创造性的程序设计里是根本就是行不通的。要写出这样一个系统，<br/>必须全神贯注，深入到语言的本质。而去写测试，往往会打乱原来的思路，所以测试应<br/>该是最后完成之后才写的。当我最后完成这个系统，可以大规模的处理 Python 代码的<br/>时候，却听见从她的桌上传来一声沉闷的咆哮：“WRITE--THE--TESTS---”这真的非常<br/>的 Googley！<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">结果 </strong><br/><br/>最后我顺利完成了整个项目，从头到尾都是我一个人设计实现的（除了 Jython 里的 <br/>parser）。现在它每天都会把 Google 所有的 Python 代码索引一遍。很多内部工具比<br/>如 CodeSearch 里面的 Python 文件上的链接，都是这东西做出来的。我所有的代码加<br/>起来才 4000 行。处理符号表的模块只有 600 行。我怎么也想不通为什么 JSCompiler<br/>会有 9000 行来处理这么简单的东西，但是也许这就是为什么 JSCompiler 花费了四<br/>年时间。<br/><br/><strong style="font-style:normal;font-weight:bold;font-size:100%;">总结</strong><br/><br/>所以这就是我对 Google 的印象。过度“和谐”的气氛，工作和生活不能明显区分，过<br/>度保密，能者多劳，官僚主义。Google 总是号称自己的工程师“build things ground<br/>up”，但是看来真正能做到的人没有几个。反倒你真想要“从头”设计的时候，会受<br/>到相当大的阻力。<br/><br/>有好几次我都看到很不错的工程师被 Google 雇佣了之后就销声匿迹了一样，为 <br/>Google “默默奉献”一生，不再有自己的发明创造。我感觉 Google 就是一个埋没人<br/>才的机器，而它的“创造性”的名声，却让越来越多的人才被埋没。主动找上门的人才<br/>被埋没了不说，还吞并其它公司，并且对他们施行同样的“Google 文化”，埋没更多<br/>的人才。<br/><br/>所以我建议有志气的人们，选择公司的时候不要看一个公司多么强大，雇了多少牛人，<br/>而要看它是否真的赏识和尊重你，因为你自己才是最重要的。<br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1147"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_47c029" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">ydiff: 结构化的程序比较</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/5d90e82fgc08e14417679&690.jpg" type="image/jpeg" height="159" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="220"/><br/></p><p style="margin:0px 0px 20px;padding:0px;">（不耐烦的人：点击<a href="http://www.cs.indiana.edu/~yw21/demos/demo1-demo2.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">【这里】</a>可进入 DEMO）</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>ydiff 是我去年做的一个概念模型，用于试验如何“结构化”的对比两个源程序，由此也引发了一些对版本控制 (version control) 的思考。这里我简要介绍一下。<p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">ydiff 的主要功能是检测代码的修改，包括删除，添加，修改，移动和分解。它跟 Unix 的 diff 程序所要解决的问题相似——对比两个程序，但是它们的方式有非常大的区别。diff 完全不理解程序语言，把程序当成字符串来比较。而 ydiff 像编译器那样对程序进行 parse，然后针对不同的语言进行<strong style="font-style:normal;font-weight:bold;font-size:100%;">结构化</strong>的比较。ydiff 比起 diff 有如下优点：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">比较结果与空白和格式无关。所以添加空行，换行，分隔符的位置，都不会影响比较的结果。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">不进行无关的对比。比如字符串 &quot;10000&quot; 和数字 10000，不会被认为是经过“修改”而得到。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">理解程序的部分语义。比如它会先比较名字相同的函数，再考虑你是否给函数换了名字。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">能检测代码的移动和分解。这对于寻找旧代码在新代码中的位置非常有用。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">友好的输出界面。输出的结果是交互式的，直观的，容易理解。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">ydiff 含有我自己写的多种程序语言的 parser（C++, JavaScript, Python，Scheme / Emacs Lisp）。虽然这些 parser 都是相当先进的设计，但是这里我要说明的主要问题是：如果程序被直接保存为一种标准化的<strong style="font-style:normal;font-weight:bold;font-size:100%;">数据结构</strong>，那么这些 parser 就完全没有必要写了！那样的话，这种结构化的比较会非常容易的扩展到支持<strong style="font-style:normal;font-weight:bold;font-size:100%;">所有</strong>程序语言。这是目前的文本编辑和存储的方式不可能做到的。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我正在设想如何实现结构化的版本控制 (structural version control)。这个内容比较复杂，我以后再讲。有兴趣的话可以暂时参考我之前的一个 <a href="http://yinwang0.wordpress.com/2012/02/12/structural-version-control" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">talk</a>。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">ydiff 是开源软件，主要算法使用 Scheme (Racket) 实现，比较结果的网页界面含有一点 JavaScript。由于是概念模型，还没有很友好的运行界面和文档，所以现在只是把生成的一些结果拿出来示意一下。如果有兴趣看代码，可以访问我的 <a href="https://github.com/yinwang0/ydiff" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">GitHub</a>。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">上图是 ydiff 对两个不同版本的 Python 程序生成对比结果之后的界面。</p><p style="margin:0px 0px 20px;padding:0px;">（点击<a href="http://www.cs.indiana.edu/~yw21/demos/demo1-demo2.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">【这里】</a>可进入 DEMO）</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">图例：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">白底红框</strong>：未修改的内容</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">红色</strong>：删除的内容</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">绿色</strong>：添加的内容</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">蓝色</strong>：修改过的内容（鼠标指针放上去之后显示修改的方式和相似度）</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这个网页里可以进行的基本的操作是：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">滚动任意一边的程序，另外一边随之滚动并且对齐。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">点击任意一个<strong style="font-style:normal;font-weight:bold;font-size:100%;">白底红框</strong>或者<strong style="font-style:normal;font-weight:bold;font-size:100%;">蓝色</strong>方框，另外一个窗口自动滚动到对应位置</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">另外的 DEMO：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/d8-3404-d8-8424.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">C++ DEMO1</a>：D8, Google的 V8 JavaScript引擎里的 debugger。这里比较的两个版本，跨域两年的时间间隔。普通的 diff 会输出非常不可读的内容，但是 ydiff 的比较结果可以一目了然的看到在两年里这个程序的变化。比如你会发现 Shell::Initialize 函数被分解成了4个函数： Shell::Initialize， Shell::CreateGlobalTemplate， Shell::RenewEvaluationContext 和 Shell::InstallUtilityScript</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/simulator-mips-simulator-arm.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">C++ DEMO2</a>：V8 中的两个处理器模拟器（MIPS 和 ARM）对比。这里对比的内容不是同一个程序的两个不同版本，而是两个不同的程序。对比结果可以清晰的显示其中的相似性，所以我觉得在检查程序侵权和作业抄袭方面可能会有用处。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/nav-nav-div.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">JavaScript</a>：对比 ydiff 自己的浏览器程序的两个版本。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/paredit20-paredit22.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Emacs Lisp</a>：对比 Taylor Campbell 的 paredit-mode.el 的两个版本。同时推荐 <a href="http://mumble.net/~campbell/emacs/paredit.el" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">paredit-mode</a>。它是一个非常不错的结构化编辑 Lisp 的 Emacs mode。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/mk-mk-c.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Scheme</a>：对比两个不的 miniKanren 实现。miniKanren 是 Dan Friedman 教授设计的，主要用于教学的逻辑式编程语言。这里比较的是原来的版本和一个我重新写过的版本。</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.cs.indiana.edu/~yw21/demos/pass1-pass2.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">S-expression</a>：对比我的 Scheme 编译器的一个优化算法生成的两个不同中间结果（IR），用于寻找编译器的 bug。</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">希望这些例子可以展示数据结构化存储之后可能带来的一些编程环境的变化。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1149"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal; font-family: &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Hiragino Sans GB W3&amp;apos;, &amp;apos;Microsoft YaHei&amp;apos;, 微软雅黑, tahoma, arial, simsun, 宋体;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_4f63e3" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">惯有类型推导的幻灯片</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;"><a href="http://blog.sina.com.cn/s/blog_5d90e82f0101cv55.html" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">关于类型推导的幻灯片 </a></p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/icon-go [1].gif" type="image/gif" height="13" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;" width="13"/></p><p style="margin:0px 0px 20px;padding:0px;">作者：王垠 发表时间：2012年10月20日</p><p style="margin:0px 0px 20px;padding:0px;"><a href="http://www.tudou.com/programs/view/GU9GtDuWSMk" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img height="18" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;" width="18"></img></a></p><br/><p style="margin:0px 0px 20px;padding:0px;">今天下午在 IU 做了一个讲座，关于类型推导（type inference）。现在把幻灯片的视频贴在<a href="http://www.tudou.com/programs/view/GU9GtDuWSMk" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">这里</a>。不敢说能让没有一定基础的人看懂，但是我确实放进了很多基本的直觉。这些都是用动画效果演示出来的。我没有想到做一个幻灯片会如此好玩。希望以后多做一些。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">视频是用 Keynote 转化而来的 MOV。这里也提供一个 <a href="https://www.dropbox.com/s/k6fwweq49be4cbh/type-infer-pdf.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">PDF 版本</a>（37MB）。基本的分步显示效果都还在，可是很多动画效果，比如物体的移动，电火花，火焰之类的全都没了。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">下面是这个讲座的内容简介：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在这个讲座里，我指出一个简单而统一的思维方式来解释和设计类型推导系统，从最简单的到最复杂的。这些系统包括：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">Hindley-Milner 系统（“HM 系统”，ML 和 Haskell 所用）</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">MLF 和它的竞争者们 （一种比 HM 系统更强大的系统）</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">Intersection type 系统</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">Polar type system 和 bidirectional type checking</p></li></ul><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">我试图回答以下这些问题：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ul style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">设计一个类型系统所需要的主要直觉有哪些？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;">ML 和 Haskell 所用的 Hindley-Milner 系统所提供的 &quot;let-polymorphism&quot; 有一个重要的问题。如何解决这个问题，而不增加程序员理解的负担？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 为什么比 Hindley-Milner 系统更强大的类型系统（MLF，intersection types）很少在实际的语言中用到？</p></li><li style="margin:0px;padding:0px;list-style:disc outside;"><p style="margin:0px 0px 20px;padding:0px;"> 为什么类型系统的“表达力”跟它的“效率”总是成反比的？如何从中找到一个平衡点？</p></li></ul></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1154"/>

<div><div><br/><div style="font-size: 16px"><div style="background-color:rgb(255, 255, 255);background-attachment:fixed;"><div style="word-wrap:break-word;font-style:normal;font-variant:normal;font-weight:normal;font-size:12px;line-height:200%;font-family:'Hiragino Sans GB', 'Hiragino Sans GB W3', 'Microsoft YaHei', 微软雅黑, tahoma, arial, simsun, 宋体;color:rgb(2, 2, 2);"><div style="zoom:1;text-align:center;"><div><div style="zoom:1;"><div><div><div><div><div style="zoom:1;font-size:14px;line-height:26px;">
								<h2 style="margin:0px 0px 25px;padding:0px;font-size:18px;font-weight:normal;line-height:30px;"><a href="http://yinwang0.lofter.com/post/183ec2_479bfc" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);">写给支持和反对《完全用Linux工作》的人们</a></h2>
								
								
								
								
								<div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;">
									
									
									<p style="margin:0px 0px 20px;padding:0px;">作者：王垠 </p><p style="margin:0px 0px 20px;padding:0px;"><br/>在一阵阵唾骂和欢呼声中，《完全用linux工作》被转载到了天涯海角。很多人支持我，也有很多人唾骂我。我不知道它是怎样流传到那么多地方，其实我不知道它都被转到哪里去了…… 我知道现在这篇文章又会罗里罗索写很长（因为我计划写这样一个东西已经很久了，坐在Emacs前面总是有一种巫师在炼丹的感觉……），所以先提出中心思想吧。中心思想就是： <br/><br/>我只是一个傻瓜。看《完全用Linux 工作》的时候请用你们自己的判断力。 <br/>几乎所有人都承认，那篇文章很偏激。当时的情况是这样，我用 Linux 的时候被一个同学鄙视了，说：&quot;你怎么用像 DOS 一样落后的东西，真土！看我漂亮的 Win2000...&quot; 这跟当面嘲笑别人老婆或者妈妈有什么区别？我义愤填膺啊，就几乎跟他吵起来。然后就写出了这篇文章放在主页上，叫了几个人来看。接着我珍爱的 TeX 又受到众人鄙视，于是我又写了一篇文章打击 Word，然后把 TeX 捧上了天。道理很简单，鄙视我喜欢的东西的人就是敌人 --邪教徒或者恐怖分子--他支持的我就反对，他反对的我就支持。为了使人信服，举例必用大科学家，世界一流大学，一流实验室的名号，虽然我不跟其中任何一种沾边。还好那时候我还不认识上帝，要不就打他的名字了。论据不管是实际经历还是自己推测的，先写上去再说。扬眉吐气啊！隔壁微软研究院的哥们居然都被我打动了，开始写 Linux 程序，学用 LaTeX 和 Emacs。不过几天之后我就把它删掉了，因为我自己都感觉到偏激。 <br/><br/>于是就没管那篇文章了。可是没想到它竟然已经被转载到那么多地方，似乎引起不小的波澜。有段时间每天都收到十几封email，国内的，国外的，问技术问题的，夸我的，骂我的，讲道理的，鄙视我的，想交朋友的，语重心长的，号称要删掉机器上的 Windows 的…… 我的主页居然也占据了&quot;王垠&quot;在 Google 上的首选位置，把那个日本的什么王公贵族&quot;李王垠殿下&quot;都挤下去了。大家似乎都知道我天花乱坠的本事了，有人就想找我写文章向别人推荐商业软件，我很后悔没有趁机狠狠赚一笔。走到图书馆，亮出借书证，管理员张大了嘴说：&quot;哇！你就是那个 Linux 牛人啊！&quot;，也不知道他是褒是贬。甚至有人把他的 BBS 昵称都改成了&quot;坚决拥护精神领袖花生&quot; （花生是我的外号）。为此还骗到了好几顿报告（报告&quot;是清华专用动词，意思是请客吃饭）。虽然我觉得自己身上没有什么值得自豪的东西，但是又有点为自己兴风作浪的本事感到惊讶。虽然我一再告诫自己要谦虚，但是不由的有一种毛泽东，甘地，甚至摩西的感觉。我更加体会到&quot;网络上没有人知道你是一头猪&quot;的真理性。其实，不但网络上没有人知道我是一头猪，实际生活中也没有人知道，其实我是一头笨猪。 <br/><br/>这么长的时间之后，还有人写信给我说&quot;深受鼓舞&quot;，&quot;提壶灌顶&quot;，&quot;对不起我还在用 Windows 给你写信&quot;，&quot;真想删掉Windows 啊&quot; …… 我很好奇，我的文章真的有那么大的威力？我再看这篇文章，觉得有点惨不忍睹，看了开头就不忍心再看下去。我告诉同学我很后悔写了一篇这么偏激的文章，可是他&quot;徼枉必须过正，你没有错&quot;，所以我也搞不清楚自己这样写对不对，这样自责对不对。就像我从来不敢看自己照片，却有时被人称为帅哥，就让我无法判断自己是否帅一样。所以现在我就开始怀疑我自己是否真是一头笨猪。也许多年以后，我会正确的评价我的想法。就像我现在觉得我15岁的照片挺养眼一样，也许我会发现自己其实是一头聪明猪？ <br/><br/>写这篇文章不是为了让自己免得被骂，也不是为了显示高深的猪的哲理。只是因为我深深的感到人应该有自己的判断力，不要简单的接受别人说的 DO's 和 DONT's。怀疑一切，同时又敞开心扉去了解一切。<br/></p>
									
								</div>
							<span style="font-size:14px;line-height:26px;clear:both;display:block;visibility:hidden;height:0px;overflow:hidden;">.</span></div></div></div></div></div></div></div></div></div></div></div><br/></div>
</div>
<hr>
<a name="1155"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_47bdea" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">什么是“对用户友好”</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;">当我提到一个工具“对用户不友好”(user-unfriendly)的时候，我总是被人“鄙视”。难道这就叫“以其人之道还治其人之身”？想当年有人对我抱怨 Linux 或者 TeX 对用户不友好的时候，我貌似也差不多的态度吧。现在当我指出 TeX 的各种缺点，提出新的解决方案的时候，往往会有美国同学眼角一抬，说：“菜鸟们抱怨工具不好用，那是因为他们不会用。LaTeX 是‘所想即所得’，所以不像 Word 之类的上手。”</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">殊不知他面前这个“菜鸟”，其实 TeX 功底比他高好几倍。他早已把 TeX 的配置搞得滚瓜烂熟，把 TeXbook 翻来覆去看了两遍，&quot;double bend&quot; 的习题都全部完成，可以用 TeX 的语言来写宏包，而且看透了 TeX 语言设计上的缺陷。而他被叫做“菜鸟”，这是一个非常有趣的问题。所以现在抛开个人感情不谈，我们来探讨一下这种“鄙视”现象产生的原因，以及什么叫做“对用户友好”。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">首先我们从心理的角度来分析一下为什么有人对这种“对用户不友好”的事实视而不见，而称抱怨的用户为“菜鸟”。这个似乎很明显，答案是“优越感”。如果每个人都会做一件事情，如何能体现出我的超群智力？所以我就是要专门选择那种最难用，最晦涩，最显得高深的东西，把它折腾会。这样我就可以被称为“高手”，就可以傲视群雄。我不得不承认，我以前也有类似的思想。从上本科以来我就一直在想，同样都会写程序，是什么让计算机系的学生与非计算机系的学生有所不同？经过多年之后的今天，我终于得到了答案（以后再告诉你）。可是在多年以前，我犯了跟很多人一样的错误：把“难度”与“智力”或者“专业程度”相等同。但是其实，一个人会用难用的工具，并不等于他智力超群或者更加专业。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">可惜的是，我发现世界上有非常少的人明白这个道理。在美国的大学里，公司里，彰显自己对难用的工具的掌握程度的人比比皆是。这不只是对于计算机系统，这也针对数学以及逻辑等抽象的学科。经常听人很自豪的说：“我准备用XX逻辑设计一个公理化的系统……”可是这些人其实只知道这个逻辑的皮毛，他们会用这个逻辑，却不知道它里面所有含混晦涩的规则都可以用更简单更直观的方法推导出来。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">爱因斯坦说：“Any intelligent fool can make things bigger and more complex... It takes a touch of genius - and a lot of <strong style="font-style:normal;font-weight:bold;font-size:100%;">courage</strong> to move in the opposite direction.”我现在深深的体会到这句话的道理。想要简化一个东西，让它更“好用”，你确实需要很大的<strong style="font-style:normal;font-weight:bold;font-size:100%;">勇气</strong>。而且你必须故意的忽略这个东西的一些细节。但是由于你的身边都是不理解这个道理的人，他们会把你当成菜鸟或者白痴。即使你成功了，可能也很难说服他们去尝试这个简化后的东西。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">那么现在我们来谈一下什么是“对用户友好”。如何定义“对用户友好”？如何精确的判断一个东西是否对用户友好？我觉得这是一个现在仍然非常模糊的概念，但是程序语言的设计思想，特别是其中的类型理论(type theory)可以比较好的解释它。我们可以把机器和人看作同一个系统：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">这个系统有多个模块，包括<strong style="font-style:normal;font-weight:bold;font-size:100%;">机器模块</strong>和<strong style="font-style:normal;font-weight:bold;font-size:100%;">人类模块</strong>。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">机器模块之间的<strong style="font-style:normal;font-weight:bold;font-size:100%;">界面</strong>使用通常的程序接口。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">人机交互</strong>的界面就是机器模块和人类模块之间的接口。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">每个界面必须提供一定的<strong style="font-style:normal;font-weight:bold;font-size:100%;">抽象</strong>，用于防止使用者得到它不该知道的细节。这个使用者可能是机器模块，也可能是人类模块。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">抽象使得系统具有<strong style="font-style:normal;font-weight:bold;font-size:100%;">可扩展性</strong>。因为只要界面不变，模块改动之后，它的使用者完全不用修改。</p></li></ol><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">在机器的各个模块间，抽象表现为函数或者方法的<strong style="font-style:normal;font-weight:bold;font-size:100%;">类型</strong>(type)，程序的<strong style="font-style:normal;font-weight:bold;font-size:100%;">模块</strong>(module)定义，操作系统的<strong style="font-style:normal;font-weight:bold;font-size:100%;">系统调用</strong>(system call)，等等。但是它们的本质都是一样的：他们告诉使用者“<strong style="font-style:normal;font-weight:bold;font-size:100%;">你能用我来干什么</strong>”。很多程序员都会注意到这些机器界面的抽象，让使用者尽量少的接触到实现细节。可是他们却往往忽视了<strong style="font-style:normal;font-weight:bold;font-size:100%;">人和机器</strong>之间的界面。也许他们没有忽视它，但是他们却用非常不一样的设计思想来考虑这个问题。他们没有真正把人当成这个系统的一部分，没有像对待其它机器模块一样，提供具有良好抽象的界面给人。他们貌似觉得人应该可以多做一些事情，所以把纷繁复杂的程序内部结构暴露给人（包括他们自己）。所以人对“我能用这个程序干什么”这个问题总是很糊涂。当程序被修改之后，还经常需要让人的操作发生改变，所以这个系统对于<strong style="font-style:normal;font-weight:bold;font-size:100%;">人</strong>的可扩展性就差。通常程序员都考虑到机器各界面之间的扩展性，却没有考虑到机器与人之间界面的可扩展性。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">举个例子。很多Unix程序都有配置文件，它们也设置环境变量，它们还有命令行参数。这样每个用户都得知道配置文件的名字，位置和格式，环境变量的名字以及意义，命令行参数的意义。一个程序还好，如果有很多程序，每个程序都在不同的位置放置不同名字的配置文件，每个配置文件的格式都不一样，这些配置会把人给搞糊涂。经常出现程序说找不到配置文件，看手册吧，手册说配置文件的位置是某某环境变量FOO决定的。改了环境变量却发现没有解决问题。没办法，只好上论坛问，终于发现配置文件起作用当且仅当在同一个目录里没有一个叫 &quot;.bar&quot; 的文件。好不容易记住了这条规则，这个程序升级之后，又把规则给改了，所以这个用户又继续琢磨，继续上论坛，如此反复。也许这就叫做“折腾”？他何时才能干自己的事情？</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/E___7395ZH00SIGG [1].gif" type="image/gif" height="22" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="22"/></p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">TeX 系统的配置就更为麻烦。成千上万个小文件，很少有人理解kpathsea的结构和用法，折腾好久才会明白。但是其实它只是解决一个非常微不足道的问题。TeX 的语言也有很大问题，使得扩展起来非常困难。这个以后再讲。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">一个良好的界面不应该是这样的。它给予用户的界面，应该只有一些简单的设定。用户应该用<strong style="font-style:normal;font-weight:bold;font-size:100%;">同样</strong>的方法来设置所有程序的所有参数，因为它们只不过是一个从变量到值的映射表（就像一个哈希表，或者数据库）。至于系统要在什么地方存储这些设定，如何找到它们，具体的格式，用户根本<strong style="font-style:normal;font-weight:bold;font-size:100%;">不应该</strong>知道。这跟高级语言的运行时系统(runtime system)的内存管理是一个道理。程序请求建立一个对象，系统收到指令后分配一块内存，进行初始化，然后把对象的引用(reference)返回给程序。程序并不知道对象存在于内存的哪个位置，而且<strong style="font-style:normal;font-weight:bold;font-size:100%;">不应该</strong>知道。程序不应该用对象的地址来进行运算。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">所以我们看到，“对用户不友好”的背后，其实是程序设计的不合理使得它们缺少抽象，而不是用户的问题。其实虽然这篇文章的题目叫“Unix的缺陷”，这种对用户不友好的现象在 Windows，Mac，iPhone, Android 里也普遍存在。比如很显然而几乎所有 iPhone 用户都被洗脑的一个错误是“iPhone 只需要一个按钮”。一个按钮其实是不够的。还有就是像 Photoshop, Illustrator, Flash 之类的软件的菜单界面，其实把用户需要的功能(function)和设置(settings)给掩藏了起来，分类也经常出现不合理现象，让他们很难找到这些功能。</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">如何对用户更加友好，是一两句话说不清楚的事情。所以这里只粗略说一下我想到过的要点：</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">统一</strong>：随时注意，人是一个统一的系统的一部分，而不是什么古怪的神物。基本上可以把人想象成一个程序模块。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">抽象</strong>：最大限度的掩盖程序内部的实现，尽量不让人知道他不必要知道的东西。不愿意暴露给其它程序模块的细节，也不要暴露给人。“机所不欲，勿施于人”。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">充要</strong>：提供给人充分而必要（不多于）的机制来完成人想完成的任务。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">正交</strong>：机制之间应该尽量减少冗余和重叠，保持正交(orthogonal)。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">组合</strong>：机制之间应该可以组合(compose)，尽量使得干同一件事情只有一种组合。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">理性</strong>：并不是所有人想要的功能都是应该有的，他们经常欺骗自己，要搞清楚那些是他们真正需要的功能。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">信道</strong>：人的输入输出包括5种感官，虽然通常电脑只与人通过视觉和听觉交互。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">直觉</strong>：人是靠直觉和模型(model)思考的，给人的信息不管是符号还是图形，应该容易在人脑中建立起直观的模型，这样人才能高效的操作它们。</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;"><strong style="font-style:normal;font-weight:bold;font-size:100%;">上下文</strong>：人脑的“高速缓存”的容量是很小的。试试你能同时想起7个人的名字吗？所以在任一特定时刻，应该只提供与当前被关注对象相关的操作，而不是提供所有情况下的所有操作供人选择。上下文菜单和依据上下文的键盘操作提示，貌似不错的主意。</p></li></ol></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1163"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_da9cc7" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">十年前的我的来信</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">作者：王垠</p><p style="margin:0px 0px 20px;padding:0px;"><br/></p><p style="margin:0px 0px 20px;padding:0px;">　　十年前的我的来信</p><p style="margin:0px 0px 20px;padding:0px;">今天收到一封 email，反对我在《<a href="http://www.yinwang.org/blog-cn/2013/04/14/os-design/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">一种新的操作系统设计</a>》一文中提到的所有想法。让我想起一句话，每一个好的想法都要经受疯狂的反对。很感谢这位读者。他让我想起十年前的那个我。如果十年前那个我来到今天看到这篇文章，恐怕也会发这样的信给现在的我吧。见到年轻的我真好，所以把这封 email 记录在这里。它会鼓舞着我，它让我明白，我能做到很多人想象不到的事情，看到他们看不到的东西。</p><p style="margin:0px 0px 20px;padding:0px;">简单的概述</p><p style="margin:0px 0px 20px;padding:0px;">首先</p><p style="margin:0px 0px 20px;padding:0px;">看了一篇你的&lt;一种新的操作系统设计&gt;的文章!有一些简单的想法!希望可以与你交流一下! 只限于技术性探讨,没有其他意思和目的!言辞不当之处请谅解!同时水平有限有不当之处可以批评!(另外我看了你的Ydiff,如果以后有机会也可以聊聊)</p><p style="margin:0px 0px 20px;padding:0px;">文章是Markdown的,复制到邮件中或许会变形,如果看着不方便可以把原文档发给你!</p><p style="margin:0px 0px 20px;padding:0px;">我不理解你是如何理解&quot;操作系统&quot;这个概念的,也不明白你所谓的超越“Unix 哲学”是什么含义(但是你既然提到了Unix我就暂且认为你想要要的是运行于硬件的操作系统)。 但是我觉得你关于操作系统的理解完全是基于用户层面的.可以看出你是个理想主义者,希望系统按照自己想要的方式做事情!</p><p style="margin:0px 0px 20px;padding:0px;">你所说的11条操作系统的设想,是完全不靠谱的.有的甚至背离的&quot;经典操作系统&quot;的概念的,或者你设想的根本不能算一个操作系统而是架设在操作系统上的一层壳!(就像Hadoop一样是一个分布式'组织系统'),只不过Hadoop只解决了分布式计算(MapReduce)和分布式存储(HDFS),而你想要的更多,但也只是停留在操控层面的,你只是希望屏蔽一些底层的东西,让业务层面的变得更简单,或者看起来更简单(事实上不是每个人的思维方式都和你一样的,有些人认为面向对象的思维方式更自然,而有的人不是,一个完美主义者或者理想主义者总是试图找到一条普世的理论去阐释这个世界,于是有了&quot;弦论&quot;,在科学界一是一,二是二的二元论断是非常值得推崇的,但是面对人性,面对需求你或许应该思考更多,爱因斯坦说上帝不玩骰子,然而他最终还是接受(至少是默许)了量子论,bash已经很好用了,却还有人鼓捣出各种各样的shell.)!</p><p style="margin:0px 0px 20px;padding:0px;">关于你文章对操作系统理解的总结:</p><p style="margin:0px 0px 20px;padding:0px;">通信是结构化的 一切都是用&quot;超语言&quot;定义的函数,所有的函数的规范是一元的 一切(系统本身,&quot;函数程序&quot;,用户Shell程序)都用超语言实现,超语言不能有指针运算 用&quot;对象数据库&quot;取代关系数据库 不需要文件系统 用户透明与&quot;无限&quot; 为了避免数据移动产生的IO开销,优先自动迁移进程! 标题不好说</p><p style="margin:0px 0px 20px;padding:0px;">你的设计思路对操作系统没有任何现实意义,更多的是空中楼阁,水中月!是没有任何现实基础的&quot;美好瞎想&quot;!</p><p style="margin:0px 0px 20px;padding:0px;">你的文章中只有推翻,而没有建设!你只是说这个不要,那个不要(不要进程,不要文件系统,不要关系数据库...),而没有提供实际的可以取代他们的真正有意义的方案!</p><p style="margin:0px 0px 20px;padding:0px;">你的思维方式不是在设计一种操作系统,而是在设计一种编程语言!</p><p style="margin:0px 0px 20px;padding:0px;">按照你的理论:Python或者Java就是一个完美的操作系统!它几乎满足你要的一切!</p><p style="margin:0px 0px 20px;padding:0px;">超语言(上帝语言)的概念很吸引人,但这绝对是错误的!正如我上面所说人性和需求是复杂的,是动态的,是多变的,哪怕你提供是诸如&quot;英语&quot;一样的通用语言也会有很多人需要添加一个&quot;中文翻译器&quot;!完全不用翻译的意思就是你得要求所有人都遵循和接受你的思维方式!当然或许你会说这种超语言满足一切人的需求,拥有一切易用的特性!好吧,如果真的有上帝语言可以跟任何人沟通,我想还是会有很多人愿意尝试的!</p><p style="margin:0px 0px 20px;padding:0px;">你完全没有理解操作系统是什么,他扮演什么角色具体要处理哪些工作!你所要求的都只是操作系统的外延,而不是操作系统的内涵!你博客的文章标题或许变成&lt;我需要这样一套分布式管理系统&gt;或者&lt;一种新编程语言的设计&gt;更加合适!</p><p style="margin:0px 0px 20px;padding:0px;">就现在计算机的体系结构而言没有指针运算是不现实的,就架构而言现实机器大多是基于寄存器的,讨论基于堆栈的虚拟机对于设计和实现操作系统没有意义,事实上无论那种机型,想要快速随机的访问特定位置的数据间接寻址是一个非常不错的工具,除非你完全抛弃&quot;间接寻址&quot;!或许你在&quot;语法解析&quot;这种逻辑层面不需要这种特性,但系统层面的间接寻址是必须的,除非你设计一套新基于更高理论水平和哲学层次的硬件!</p><p style="margin:0px 0px 20px;padding:0px;">把系统看作为一个&quot;仆人&quot;,只要对他下命令他就能按照你想要的方式为你做任何事情(这或许是你的终极目标或者是你目标的一种更为极端的表述)!只想用高级语言的特性而忽略计算机体系结构设想出来的东西根本就不能算作&quot;典型意义上的操作系统&quot;!按照你的方式我完全可以这样设计一个操作系统:只要我告诉他我想做什么,计算机就可以为我做任何事情,比如去厨房做个番茄炒蛋!他就傻乎乎的跑去买番茄和鸡蛋然后...这样的设计岂不是更完美?</p><p style="margin:0px 0px 20px;padding:0px;">我觉得你可能是做&quot;语法分析&quot;的!或许对各种语言的&quot;哲学思想&quot;有独到的见解,但是把这种思想或者更高层次的抽象带到&quot;操作系统&quot;的设计上就是很大职业病!为此你需要推翻现代计算机的体系结构,重新设计和研究可计算理论,不切实际的泛泛而论只会让我看到你的幼稚与任性,露脸与现眼只差一步!</p><p style="margin:0px 0px 20px;padding:0px;">如果你希望你做的是惊世骇俗,前五百年后五百年都不曾有和超越的东西.请先不要将它叫做&quot;操作系统&quot;,或者跟&quot;Unix哲学&quot;比较!如果必须这样做,请先搞搞清楚什么事操作系统和Unix哲学!</p><p style="margin:0px 0px 20px;padding:0px;">我的一些相对现实与丑陋(没有那么理想化,很多甚至是迂腐)的看法</p><p style="margin:0px 0px 20px;padding:0px;">我理解的操作系统</p><p style="margin:0px 0px 20px;padding:0px;">最原始的需求:如果将计算机看作一堆冷冰冰的电子元件操作系统的角色就是&quot;驱动,它将这堆冷冰冰的器件合理的组织起来,让他们构成一个系统团结起来工作;要知道程序是直接可以跑在机器上的,不需要任何系统的,但是这意味着你就必须面对这一堆冷冰冰的电子元件了! 我们要的更多:尽管硬件系统变越来越复杂,如果将计算机的计算能力,内存空间,外存空间等看作资源,然而这部分资源终究还是有限的;操作系统的目标是如何更有效的使用和管理这些资源!就因为资源有限所以才需要管理,才需要操作系统,当然你所设想的&quot;无限空间&quot;,不需要&quot;文件系统&quot;这种概念完全是背离的! 基于以上两点,现在多数真正的操作系统是面向&quot;硬件&quot;的,如何高效的利用硬件是他们的重点!(宏内核与微内核的争论在这一点上看起来像是对立的,事实上确实是这样么?我觉得,孜孜不倦的挖掘计算机的潜力是每个系统开发者的目标与乐趣所在)</p><p style="margin:0px 0px 20px;padding:0px;">程序,进程与函数</p><p style="margin:0px 0px 20px;padding:0px;">什么是程序什么是进程?去掉进程的概念是不是意味着你需要用别的方法代替?函数吗?事实上他们完全不是一回事儿,进程概念的存在是为了让程序看起来是并行执行的(还是以上这一点,为了更有效的利用CPU资源)!</p><p style="margin:0px 0px 20px;padding:0px;">函数呢? 函数是一种&quot;可计算模型&quot;的表示方法(你完全可以用图灵机,lambda演算,寄存器模型,或者递归来代替,因为他们的本质是一样的)!</p><p style="margin:0px 0px 20px;padding:0px;">你只是用函数描述了计算方法,而进程是有时间考量的,可计算理论中并没有&quot;时间&quot;这个维度!你抛弃了进程,就势必要在函数的定义一个时间维度,在你的观念里函数是一切,它可以做任何事情!现实意义上的计算机更多的是基于寄存器模型和递归模型的,编译器大多数只是将函数表述翻译成寄存器表述或者递归表述,这个过程是一一对应的,他们都是静态的,编译器在这个过程无法给他附上时间维度.编译器不做,操作系统也不做,也就意味着程序员得在代码中加入控制调度的代码,好吧我们回到了最原始的时代了.(当然除非你假设CPU的计算能力是无限的,任何函数都是可以并行执行的,函数的执行是不需要时间的,函数之间的依赖关系是不存在的...就另当别论了)</p><p style="margin:0px 0px 20px;padding:0px;">&quot;“系统调用”，只不过是调用另外一个函数,&quot;对于你的轻蔑傲慢的语气我真的不想吐槽!事实上系统调用还真是调用另外一个函数,对于很多微内核系统虽然其实现是&quot;基于消息&quot;的,但是其外在依然表现为&quot;过程调用&quot;形式,对于被调用资源的实现也依然是个函数! 我不知道你是如何理解函数这个概念的,&quot;任何可计算的问题都能用可计算模型(比如函数)来表示,而可计算模型之外的则是不可计算的&quot;,这或许看起来像句废话,但他确实证明你所说的,可计算的一切都可以是函数,但是仅此而已,没有任何外延了,如何安排计算,如何调度计算,可计算理论并没有给出任何有意义的说明;</p><p style="margin:0px 0px 20px;padding:0px;">当然实际问题要复杂的多,除了时间问题,还有你提到的权限问题等!</p><p style="margin:0px 0px 20px;padding:0px;">关于关系数据库与文件系统</p><p style="margin:0px 0px 20px;padding:0px;">系统不需要 SQL，不需要关系式数据库。</p><p style="margin:0px 0px 20px;padding:0px;">我需要强调一点:关系数据库并不仅仅是一个数据存储方案,也是一个数据&quot;计算方案&quot;(很多人用他是不是因为存储方便,事实上它存储不方便也限制多多,诸如数据必须是结构化的,对于树形的或者图形结构的数据还需要扁平化)! 数据存储的方案有很多,你可以直接将数据按一定的格式排版放到一个文件,可以使用键值模型存储简单的数据,或者将数据保存为特定通用格式(比如JSON,XML),或者有很多基于树形结构的文档数据库.基于图论的图形数据库(Neo4j)和狗屎的对象数据,当然也包括基于关系模型的关系数据库!(或许有一天有人会来个大一统,但是谁取代谁的说法显然是不靠谱的),他们各有各的优缺点,而关系数据库更是基于严谨成熟的关系数据理论构建的,他的数据结构简单,运算简介高效,不明白为什么有人会讨厌SQL,事实上他是最简洁方便直观的工具,他隐藏了很多计算细节,甚至你只需要告诉他我需要什么(而不是如何做),他就能很好的为你提供服务!</p><p style="margin:0px 0px 20px;padding:0px;">如果一切都是对象,随意的构造数据,存取无疑是最方便的),但构建在对象之上的算法就必须自己实现(这将会是灾难),相比于自己在对象之上实现算法,&quot;构造结构化数据&quot;显然更简单(或者机械化),基于成熟的关系数据理论也可以让你避免很多错误!我想这也是关系数据库占统治地位的主要原因!</p><p style="margin:0px 0px 20px;padding:0px;">对于文件系统,理解有很多种,基于磁盘的文件系统和构建于文件系统之上的&quot;文件系统&quot;!操作系统意义上的是前者,而后者大多数是是一些&quot;虚拟文件系统&quot;,网络文件系统,或者分布式文件系统!后者更接近于&quot;文件管理系统&quot;,他没有解决数据如何存储在物理介质上的问题,主要面向业务,提供&quot;文件系统透明&quot;这一概念!操作系统设计提出&quot;不要文件系统&quot;和&quot;金三胖不要姑父&quot;一样荒唐!</p><p style="margin:0px 0px 20px;padding:0px;">解码是必须的</p><p style="margin:0px 0px 20px;padding:0px;">解码(解析)是一个&quot;理解数据&quot;的过程!</p><p style="margin:0px 0px 20px;padding:0px;">你可以把任何数据看作一个&quot;有特定语意的对象&quot;,作为人很容易凭直觉和经验认定12345是数字,abcde是字母!但对于计算机他只是一块放在特定位置的&quot;没有特定意义&quot;的&quot;数据&quot;,我们使用数据就必须对其赋予一定的含义,知道他是什么,如何组织!计算机不会下意识的知道12345是数字,而abcde是字母!理解数据必须存在,哪怕是一个结构化的数据,要使用它你就必须理解他,同时要让计算机理解他!(事实上你在判断12345是数字之前已经对他做了解码了)</p><p style="margin:0px 0px 20px;padding:0px;">所以我的结论是:解码是必须的!不是所有事情都是理所应当的, 或许向你这样的人思维速度非常快,有些问题你凭直觉和经验就得出了结论!以至于你甚至意识不到你对问题做出了思考!但是理性是必然存在的!</p><p style="margin:0px 0px 20px;padding:0px;">那么这个问题就变成了&quot;谁来解码&quot;!</p><p style="margin:0px 0px 20px;padding:0px;">目前而言可以有下面几个选择:</p><p style="margin:0px 0px 20px;padding:0px;">计算机自己(硬件系统和操作系统)</p><p style="margin:0px 0px 20px;padding:0px;">事实上计算机有一定的解析数据的能力 就冯诺依曼体系结构的计算机而言,它要求程序按照特定的指令系统被编码存放,这种规范的是一个有限的集合!无限延伸让他处理任何的数据是不可能的(比如你给计算机一个Torrent文件他或许只是个文本,但让计算机知道接下来要做什么是不可能的,不可能任何系统都安装了这个解码器,因为不是所有人都需要的,你必须许更具特定的需求自己安装Bencode/Bdecode)!更高层次的解析(理解)需要具体问题具体处理,除非你颠覆现有的体系结构重新设计基于更高理论水平和哲学层次的可计算模型. 把所有的东西交给系统来处是不切实际且没有必要的(如果特定场景或许可以),所以你或许应该把这些事情交给下面的选项来做!</p><p style="margin:0px 0px 20px;padding:0px;">编译器(或者解释器) 当我们编译一个C的结构体的时候,编译器提供了编码和解码,它根据语法定义的数据的宽度得到特定偏移,将数据按照特定偏移排布在特定的位置这是一个编码的过程,计算机根据自己的指令系统的定义和规范对编码的数据进行加载和运算,这是一个解码的过程!从函数式编译到寄存器模型亦是一个翻译的过程,这个翻译过程为了让不同系统之间相互交流编码和解码是不可避免的!</p><p style="margin:0px 0px 20px;padding:0px;">程序库</p><p style="margin:0px 0px 20px;padding:0px;">我们很容易的使用已有的库去解析JSON,XML,让他们变成你所谓的对象,应为你或许觉得在用户层面上使用对象的概念会更简单!</p><p style="margin:0px 0px 20px;padding:0px;">用户(程序员): 对前无古人的个性化数据赋予一定的语意,用户必须制定特定的格式或者协议,然后手动编写相应的代码实现编码与解析!然而这是大多数创造力的来源!如果你做创造性的工作,我想这会是大多数情况!</p><p style="margin:0px 0px 20px;padding:0px;">关于如何解决分布式问题</p><p style="margin:0px 0px 20px;padding:0px;">你提到的移动&quot;计算&quot;优于&quot;移动数据&quot;,这在大多数情况下是正确,包括Hadoop这种系统也是那么做的,这并无新意!</p><p style="margin:0px 0px 20px;padding:0px;">然而事实上分布式问题的核心在于调度,在于如何抽象成一个分布式计算模型来一劳永逸的解决任何可分布式计算的问题,在这里还要明确一点有很多问题是不可分布式计算的,就是因为存在这种问题,构建一劳永逸的模型就几乎成为不可能的至少是有代价的事情,MapReduce或许是一个很不错的模型,但在特定的情景下依然会显得力不从心,同时无可避免的引入了无关代码去分解问题(只是将这个过程模式化了),很多情况下特定的业务逻辑下,这种方案并不是最高效的.</p><p style="margin:0px 0px 20px;padding:0px;">而Java和其他一些分布式方案并不是真正意义上的&quot;分布式模型&quot;,他并没有解决任何&quot;问题分解&quot;和&quot;调度&quot;的问题,程序员仍然需要根据自己的业务需求分解简化问题,决定哪些问题在哪些节点运行,何时运行!</p><p style="margin:0px 0px 20px;padding:0px;">不需要显式的使用特定的方法就能让系统跟安排进程执行一样自动的分布这些计算和数据到不同的节点的通用系统我没见过(或许还真有)!</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div>
<hr>
<a name="1196"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br/><div style="background-color: rgb(255, 255, 255); background-attachment: fixed;"><div style="word-wrap: break-word; font-style: normal; font-variant: normal; font-weight: normal;"><div style="zoom: 1; text-align: center;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px; zoom: 1;"><div style="margin:0px auto;padding:0px;width:300px;border-bottom-width:3px;border-bottom-style:solid;border-bottom-color:rgb(34, 38, 48);margin-top:40px;border-color:rgb(240, 240, 240);"><a href="http://yinwang0.lofter.com/post/183ec2_d0cd94" style="font-size: 18px; line-height: 30px; cursor: pointer; outline: 0px; text-decoration: none; -webkit-transition: all 0.3s ease; color: rgb(22, 126, 252);">程序语言与……</a></div></div><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px; zoom: 1;"><div style="margin: 0px; padding: 0px;"><div style="margin: 60px 0px 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><div style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; margin: 0px; padding: 0px;"><div style="margin:0px;padding:0px;zoom:1;font-size:14px;line-height:26px;"><div style="margin:0px;padding:0px;width:700px;margin-left:auto;margin-right:auto;text-align:left;"><p style="margin:0px 0px 20px;padding:0px;">　　程序语言与……</p><p style="margin:0px 0px 20px;padding:0px;">程序语言的设计类似于其它很多东西的设计。有些微妙的地方只有用过更好的设计的人才能明白。现在我就简要介绍一下我自己的体会。</p>
程序语言与微波炉
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/microwave.png" type="image/png" height="775" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="700"/></p><p style="margin:0px 0px 20px;padding:0px;">有的程序语言就像左边的，现在中国市场上流行的微波炉。布满了花哨的一年都用不到一次的专用菜单，却连最基本的 0-9 数字键都没有。输入个时间都要费脑筋组合一下，按键位置不顺手，不能一次按到位，而且还不能达到需要的精度。</p><p style="margin:0px 0px 20px;padding:0px;">有的程序语言就像右边的，美国市场上常见的微波炉，几十年不变的设计。虽然按键很少，但十个数字键总是少不了，而且采用标准的“电话键盘”排列。十个数字能够组合产生出任意的时间，所以不管是在自己家里，别人家里，公司或者学校，你总是可以按照自己的经验，食物包装或者菜谱上的说明，迅速而精确的输入想要的时间。</p><p style="margin:0px 0px 20px;padding:0px;">可惜的是，在中国你已经买不到这么简单实惠的微波炉了。我们中国人学会了美国的很多糟粕，却没有把这么简单，这么好的设计思想学过去。</p><p style="margin:0px 0px 20px;padding:0px;">中国的微波炉厂商之所以放上这么多的花样，是因为商家抓住了中国人的贪便宜心理。看，一个微波炉可以煮米饭，烤肉串，还可以蒸排骨，那其他的厨具都可以不用买啦！可惜因为所以，科学道理，微波就是微波。加热牛奶剩饭之类的事它做得很好，可是要做美味佳肴它就不行了。煮米饭不如电饭煲，烤肉串不如烧烤架，蒸排骨不如蒸锅，炖东西不如砂锅…… 美国人和稍微有点经验的中国人早就知道这个道理，所以从来不期望微波炉能做超越它所擅长的事情。</p><p style="margin:0px 0px 20px;padding:0px;">虽然美国人在这些硬件上非常精明，可是在软件上还没发展到那种地步，很多时候对一些不可救药的软件技术寄予太多的希望。左边的微波炉就好像某些程序语言，本来当初设计就是给标准没那么高的人用来处理很简单的网页的。可是后来有人忽然想让它成为一个“万能语言”，用来做复杂的，对性能和可靠性都很高的服务器程序甚至机器人控制程序。然后你就发现类似微波炉的问题，因为一些不可逾越的设计差别决定了它是不可能把那些事情做好的，而且对有些应用还有严重的安全隐患。当然你可以缓慢的“改进”这语言，让它慢慢的提高做这些事的水平。可是这种改进的终点也许只是另一种早已存在的语言。而且由于不想破坏已有的代码和特性，所以每一步的改进都异常艰难。这种方式远远不如直接针对需要选择不同的语言，或者设计新的语言来的迅速和有效。</p>
程序语言与减肥
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/jianfei.png" type="image/png" height="181" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="278"/></p><p style="margin:0px 0px 20px;padding:0px;">很多人都想减肥，就像很多人都想学会编程。姑且不说一味的减肥好不好，现在只谈一下什么是有效的减肥方法。</p><p style="margin:0px 0px 20px;padding:0px;">我自己也有一段时间很胖，也有减肥的经历，而且非常成功。如果有一天我不小心又变胖了，我有非常科学而可靠的办法减回去。我的方法就是一句话：让每天吃进去的热量比消耗的少一些，但是不至于难受，另外适当运动来增加热量的消耗。很显然嘛，根据热力学定律，每天消耗的能量比摄入的多，多出来的部分只能通过分解你身上的物质（脂肪）来产生。我的减肥方法就像某些程序语言教会我的编程理念，是不随潮流而改变的真理。它让我的程序不管用什么语言写都优美而精悍。</p><p style="margin:0px 0px 20px;padding:0px;">我不是自私的人，我希望大家都健康一点，养眼一点。我已经轻易地告诉了你减肥的终极真理，一分钱都不收，可是你不相信我。你觉得肯定没那么简单，或者你觉得那样太辛苦，自己不可能照办。这就像很多人对编程的希望：要是我不学编程也能编程该多好啊！</p><p style="margin:0px 0px 20px;padding:0px;">很多程序语言就是针对这群人而产生的，它们大部分的工作花在了研究人的心理和做广告上面。它们就像电视广告里铺天盖地的减肥药：不需运动，不用节食，一个星期瘦 20 斤！它们提出各种新的术语，什么减肥茶，片，胶囊，螺旋，燃脂，纤维，宫廷，祖传，秘方，各种生化术语…… 再加上一些 PS 出来的前后效果对比图，你痛快地花不菲的价钱买了这药，然后每天好几次的像做化学实验一样精确的按时按量服用。这时候任何人跟你说这药不灵的话你都不会相信，你觉得这些人都是想跟你争夺异性的目光故意想让你继续胖下去而其实她（他）们自己背地里也吃这药，所以你对此减肥药必胜的信心有增无减。</p><p style="margin:0px 0px 20px;padding:0px;">当然你不会成功。在持续服用好多个月，甚至好几年之后，你按照广告里说的“无效退款”条例要求退款。可是减肥药公司说，是你自己没有按说明书服用，或者你吃药之前肯定比现在还胖很多。你拿不出证据，后悔当初没到公证处开你当时体重的证明。可是你仍然相信，世界上一定会有真正有效的减肥药。你觉得国内的公司喜欢骗人，所以你到了美国，寻找传说中那世界一流的减肥药……</p>
程序语言与棋
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/chess.png" type="image/png" height="768" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="700"/></p><p style="margin:0px 0px 20px;padding:0px;">有人说好的程序语言就像国际象棋（chess），在了解简单的规则之后，你就可以用它们组合出变幻无穷的棋局。而我认为，好的程序语言应该像国际象棋去掉像“王车易位”（castling）一类<a href="http://en.wikipedia.org/wiki/Chess#Castling" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">复杂古怪的规则</a>。实际上，好的程序语言会更加近似于中国象棋，而不是国际象棋。中国象棋只有一条规则比较特殊—“蹩脚马”，可是它其实很直观，容易理解。其它的规则，比如兵卒过河才能横行，几乎都画在棋盘上了。</p><p style="margin:0px 0px 20px;padding:0px;">可不要小看国际象棋里这少数几个特殊规则，它们需要在好几个非常特殊的条件满足之后才会生效，而且路线诡异。比如，王车易位必须满足：</p><ol style="margin:0px 0px 20px;padding:0px 0px 0px 25px;"><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">王和跟他换位的车都没有移动过</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">王和车之间没有其它棋子</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">王不能处于被“将军”的状态而且王在换位之后不能处于被攻击的位置但是车可以在换位后处于被攻击位置</p></li><li style="margin:0px;padding:0px;list-style:decimal outside;"><p style="margin:0px 0px 20px;padding:0px;">王和车处于同一条水平线上</p></li></ol><p style="margin:0px 0px 20px;padding:0px;">另外换位的时候王和车不是直接互换位置那么简单，而是这样的路线：</p><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/ChessCastlingMovie.gif" type="image/gif" height="210" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="206"/></p><p style="margin:0px 0px 20px;padding:0px;">一条这样的特殊规则就够伤脑筋了，据我所知国际象棋还有至少其它两条类似的规则。它们跟其他的规则组合在一起的时候就产生了组合爆炸效应，你发现每走一步，甚至貌似无关的动作都得检查它们是否会出现。你不得不随时把这么复杂的规则放在脑子里。没事找事也不要找这么麻烦的事啊。</p><p style="margin:0px 0px 20px;padding:0px;">这些规则就像是要你记住 C 语言里的 ++i+i++ 或者 if (x = &quot;foo&quot;) {...} 是什么意思。经过多年的痛苦经历之后，你多希望不再需要理解这样的代码。可是一旦这样的规则被加到语言里面，总会有人为了显示自己的水平和记忆力去用它们。不得已，你只好陪他们玩。</p><p style="margin:0px 0px 20px;padding:0px;">如果你觉得多了这些无厘头的规则会让国际象棋比中国象棋难度大或者更加有趣，那你就低估了中国象棋了。中国象棋的“游戏树复杂度”其实比国际象棋还要高，高达 10150，而国际象棋只有 10123。这跟中国象棋的棋盘要稍微大点有关系，但是总比记忆那些麻烦的规则好多了。所以相对来说中国象棋既简单又耐玩。</p><p style="margin:0px 0px 20px;padding:0px;">如果国际象棋还凑合算是简单的话，大部分的程序语言就像是魔鬼棋，飞行棋，或者三国杀。它们几乎完全由类似的特殊规则构成。哇，那么多的人物，道具和特殊技，好玩！可是会玩象棋或者国际象棋的人都会觉得它们无聊透顶。</p><p style="margin:0px 0px 20px;padding:0px;">那么是不是规则越简单越少的棋越好呢？围棋就比中国象棋还简单，那么围棋是不是更好玩呢？我觉得不是的。围棋对我来说太慢，太单调，棋盘太大，耗时太多，而且胜负居然不能一眼就看出来，要数好一会儿！这哪里是在玩，纯粹就是在做组合优化题嘛。我觉得这种任务适合交给电脑去做。所以其实简单也有一个界限，超过了这个界限对于人就没有很大区别了，反而会开始感觉缺少一些东西。</p><p style="margin:0px 0px 20px;padding:0px;">我觉得中国象棋和围棋一样简单，它的规则虽然比围棋多，但是仍然处于人脑容易记忆的范围，而且每条规则都很直接了当，没有很隐晦的条件。中国象棋的长距离武器（车和炮）让它比围棋多了很多乐趣，而对于象，马和王的走法的限制，让它比起国际象棋多了几分安心和舒适。国际象棋的后，两个车，两个相的攻击距离和范围太大，让人觉得眼睛很辛苦，因为每一个位置都可能被从太多个方向远距离攻击。而那个王，由于可以到处乱跑，以至于你感觉不是在抓一个住在戒备森严的城堡里的人，而是一只在野外乱跑的老鼠。</p><p style="margin:0px 0px 20px;padding:0px;">什么游戏会让人觉得有趣，真是一个值得研究的问题。我觉得象棋和我以前推荐过的一个游戏 <a href="http://www.yinwang.org/blog-cn/2013/03/04/braid/" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Braid</a> 里面含有同一种吸引人的设计：屈指可数但又有足够变化的简单规则，组合起来制造出许许多多的变化。这种特征其实也是鉴别一个优秀的程序语言的标准。</p>
程序语言与音乐
<p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/goldberg.png" type="image/png" height="400" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="400"/></p><p style="margin:0px 0px 20px;padding:0px;">程序语言就像音乐。当听过很好的音乐之后，你会自然而然的厌倦以前曾经喜欢过，为之疯狂过的那些，觉得它们很无趣，甚至很惊讶自己以前怎么会喜欢它们。当有人问你为什么不喜欢他们推荐给你的音乐，你却说不出来。你只是自然而然觉得太单调，不入耳，不对劲，甚至扰乱你美好的心情。你的判断完全是依靠声波对鼓膜的震动而引起的脑电波的起伏，而不带有任何的成见。完全根据这音乐自己，而不需要知道它的作者是谁。就像玩过像《Braid》之类的游戏之后，你再也不想玩像《生化危机》那种搞不清楚到底是自己在玩游戏还是游戏在玩自己的。你的脑子里有一种对“趣味”的新定义，但是你却说不出来它到底是怎么回事。</p><p style="margin:0px 0px 20px;padding:0px;">每当有人问我喜欢什么样的音乐我都不好说出口，因为我最喜欢的音乐家是巴赫（J. S. Bach）。他的音乐不知道为什么，一天听一百遍也不会腻。只有当巴赫的音乐一天放了实在太多遍之后，我才会开始放肖邦的，不过肖邦的一般比较快就腻了。听饱听撑着了，我才开始考虑用 Dream Theater 和少数几首 hiphop 来调一下味。很奇怪的是，我根本不喜欢很多人推崇的贝多芬之类的交响乐，不管是多好的世界级的乐队，不管是现场演奏还是听录音，每次听都打瞌睡，觉得罗里吧嗦滥竽充数的。</p><p style="margin:0px 0px 20px;padding:0px;">巴赫音乐的演奏者里面我最喜欢 Glenn Gould，他演奏的巴赫曲目里面我最喜欢 Goldberg Variations，而他的两次 Goldberg 录音（1955 和 1981 年）里面我只喜欢 1955 年的，虽然当时录音技术落后一些，有一些杂音和 Gould 的哼哼声。我怎么能够区别出自己喜欢哪一个？因为最初的时候它们每个都被我听了几百遍，然后我的心就自然而然做出了选择。</p><p style="margin:0px 0px 20px;padding:0px;">哇，这样说出来总是有附庸风雅之嫌，所以我每次都说“嗯，什么乱七八糟的从古典，rock 到 hiphop 都听点……”倒也差不多是事实，但是我喜欢巴赫显然超过其他人一千倍以上。我每天晚上听着巴赫的音乐睡觉，白天用耳机听着他的音乐上班，没有人知道我在听什么。我每个月付给 Spotify $9.99 享受可以听尽世界上所有音乐的服务，可惜的是过了一两年我仍然每天反复地听那一两张巴赫的唱片，还不如直接把它们买下来。</p><p style="margin:0px 0px 20px;padding:0px;">其实我基本不识谱而且五音不全，也不会乐器，但是听了一阵子巴赫的音乐之后，我再也不想听流行音乐甚至很多其他古典音乐家的作品了。巴赫在我心里丝毫没有名气或者“高雅”的成分，如果他是在街头卖 CD 的音乐演奏者，我一样每天晚上听着他的音乐睡觉。我喜欢他的音乐的原因很简单：有趣听不腻。我反倒觉得大部分人喜欢流行音乐是因为名气和喜欢显示自己，那才是真正意义上的附庸风雅。这里的科学道理就是，绝大部分流行音乐是 4/4 拍，容易唱，但是太单调了，跟一二一齐步走似的，很难做出什么好音乐。然而就是因为这些附庸流行音乐的“风雅”的人，巴赫如果活在今天说不定也就是在街头演奏卖 CD 的命。</p><p style="margin:0px 0px 20px;padding:0px;">程序语言是同样的感觉，这是一个“流行语言”招摇过市的年代。每当有人问我喜欢什么程序语言我都不好跟他说，因为一旦说出来就有显摆之嫌，而其实真正显摆的是其他人。很多人期望你的回答是他所膜拜的那个最近很热门的语言，你一旦告诉他你喜欢的语言就会被冷嘲热讽，因为你的语言不热门。他们会说你是“学院派”，而他们是“工程派”，而其实这只是给垃圾的存在找借口。他们利用你害怕自己被认为是附庸风雅或者居高临下的心理来变相地压制你，让你不敢直率的袒露自己的兴趣。你不敢显示对有些东西的不屑，而他们却可以任意的显示对真正优秀的技术的不屑。你觉得应该手下留情一些，谦虚一些，结果最后一些垃圾一样的语言就骑到你头上来，让你不得不用它们。</p><p style="margin:0px 0px 20px;padding:0px;">用过很好的语言，然后自己设计过程序语言之后，我再也不对很多新的语言，或者有些人很崇拜的古老的语言感兴趣了。我完全是凭自己的感觉来判断，一些所谓的“新特性”其实是老酒换新瓶，或者是勾兑的假酒。程序语言本来就只有那么点东西，为什么有人仍然像对那些扮相的流行歌手一样热衷和疯狂。</p><p style="margin:0px 0px 20px;padding:0px;">我知道这些话说了也白说，因为他们没有用过我用过的语言，他们只看到名字却感觉不到本质，他们靠别人的评价来判断，而不是靠自己的心。所以像音乐一样，只有等有一天他们忽然觉悟，就像很多年前的我一样。</p>
程序语言与武器
<p style="margin:0px 0px 20px;padding:0px;"><a href="http://weaponsman.com/?p=12534" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank"><img src="YinWang_files/AK-47.png" type="image/png" height="253" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="700"/></a></p><p style="margin:0px 0px 20px;padding:0px;">前段时间 AK-47 的设计者 <a href="http://en.wikipedia.org/wiki/Mikhail_Kalashnikov" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">Kalashnikov</a> 去世的时候，我从一篇文章了解到他设计 <a href="http://weaponsman.com/?p=12534" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">AK-47 的故事</a>，发现 AK 跟我喜欢的程序语言设计有异曲同工之妙。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">AK 简单得就像一把锤子。它身上没有太空时代的材料。大多数汽车修理店都有可以制造出 AK 的工具。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">这篇文章首先提到，AK 的高可靠性最主要来自于它的简单，而其实简单也是程序语言最重要的东西。程序员需要解决的问题一般都挺复杂，如果他们的工具再被设计得复杂，那么他们大量的脑力就被浪费在解决这语言的问题，而不是真正需要解决的问题了。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">Kalashnikov 开始的时候把任何有可能出问题的设计都排除在外了。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">与简单的设计背道而驰，现在很多程序语言为了赶潮流或者吸引眼球，喜欢标新立异，喜欢加入很多“特性”，可是这些特性很有可能不但不解决问题，而且会制造问题。绝大部分程序员都不理解这个道理，所以有些人听说我在设计自己的语言就问我：“它有什么新特性吗？”我没法回答他们，因为我的设计几乎没有新的特性。我现在所做的一切思考和试验都是在去掉不必要的麻烦。一个语言缺少一些好的特性，以后还可以加进去，可是它如果多了一些问题特性，那一旦有人开始用就没法去掉了。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">AK 上面没有袖珍和娇气的部件。这样你就不用费事在草丛里，泥地上或者溪流里找它们了。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">士兵是人，会摔跤犯错误，程序员也是人，所以程序员的武器应该像士兵的武器一样，方便他们找到问题。可是很多程序语言让程序员犯错误之后花很多时间和精力才能找到错误的所在，浪费大量本来可以用来解决问题的时间。我的前同事 TJ 说他刚进入博士学习的时候花了好几个月，就为了找到 C 代码里面一个指针计算错误，导致内存结构破坏和莫名其妙的错误结果，而出现指针计算错误的位置跟错误结果出现的位置毫无关系。我也遇到过类似的问题。C 语言的指针不就像是某些武器上面的袖珍部件吗？一不小心掉在地上就找不到了。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">AK 只有一个复杂一点的部件，那就是它的弹夹。弹夹的设计很大程度上影响到枪的整体性能，所以 Kalashnikov 在上面花了很多设计时间。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;"><img src="YinWang_files/ak-magazine.png" type="image/png" height="181" style="border:0px;margin:0px 0px 20px;max-width:500px;vertical-align:middle;cursor: default;cursor: default;" width="279"/></p><p style="margin:0px 0px 20px;padding:0px;">这个工程经验其实对于程序语言的设计者有启发意义，因为弹夹与枪主体的接口，和程序语言的函数接口很类似。Tony Hoare 在他的《<a href="https://www.cs.berkeley.edu/~necula/cs263_sp14/handouts/hoarehints.pdf" rel="nofollow" style="cursor:pointer;outline:0px;text-decoration:none;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;color:rgb(22, 126, 252);" target="_blank">给程序语言设计的建议</a>》中也提到，函数的调用必须简单而且快速，因为调用的开销会累积起来形成很大的性能问题。可惜的是很多语言没有注意到这个问题，函数调用时总是有一堆的动态检查和重载要做，很大程度的影响了它们的性能。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">Kalashnikov 不是天才，他不是为了发明而发明，他解决不了问题的时候就高兴地从别人那里学过来。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">这是非常值得我们程序语言设计者学习的。很多程序语言专家都有盲目排斥“对手”的心理，“自己人”的东西就不假思索的表扬，对手的东西就一味的批评。最后的结果是没有把敌人的好东西学过来，让自己人吃亏。在操作系统和数据库等领域也有类似的思维方式，这是非常有害的。</p><blockquote style="margin:0px 0px 20px;padding:0px;border-left-width:1px;border-left-style:solid;border-left-color:rgb(221, 221, 221);padding-left:10px;"><p style="margin:0px 0px 20px;padding:0px;">直到被更好的东西取代，AK 会继续和我们在一起。什么才是“更好”，这是由历史和民族来定义的，而不是枪支设计专家。</p></blockquote><p style="margin:0px 0px 20px;padding:0px;">在计算机的世界里也是一样，程序语言，操作系统，数据库…… 它们的好坏不应该是由它们的设计者决定的，而是看它们是否经得起时间的考验。很多几十年前以为是好的设计，到现在已经很明显的显示出了它们的缺点。这就是为什么我喜欢批评一些语言，操作系统和数据库的设计，因为我看到了它们在历史的长河中已经快要到达终点。自欺欺人的掩盖这些缺陷只会让我们输掉战争。</p>
程序语言与梦中情人
<p style="margin:0px 0px 20px;padding:0px;">很多程序员都把选择一种程序语言看成像结婚一样的大事，所以导致很多心理矛盾。一个程序语言真的很像一个人，有你喜欢的地方，也有让你恼火的地方。就像你跟很多人约会，结果没有一个人身上有你喜欢的一切，她们身上总是有你不喜欢的地方。每次遇到新的人，你总是希望她就是那个命中注定的人，可是无一例外的，上帝悄悄在她们身上放了一些你没法去掉的缺点，有时候要到结婚以后才会发现。有时候你有了新的情人，却发现有的地方还是以前的那个好，留恋却又不敢说出来。有时候你喜欢两个人，一人一半，可是传统和法律要求你只能跟一个人结婚，所以你就进入了无穷的烦恼，仿佛错的人是你。无数的小说，电视剧，电影就是为了这个问题被制作出来的。如果有一天编程成为了每个人生活里的一件大事，肯定有作家或者电影公司愿意出品这样的东西。少年黑客的烦恼，Oh，某某语言，想说爱你是一件不容易的事。</p><p style="margin:0px 0px 20px;padding:0px;">不同的是，程序语言并不是上帝创造出来的，而是人类自己。你无法把人大卸八块，只把好的部分组装成你的梦中情人，然而对程序语言你却可以这么做。可惜不幸的是，拥有制造新语言的能力的程序员是非常稀有的，其中有好的品位的就更少了，所以这种人往往被当成上帝。你多希望一个新的上帝能够创造出你想要的语言，去掉其它语言身上你不喜欢的地方，然而他们却一次次的让你失望，就像制造人类的那些上帝一样。所以你等不了了，就跟一个还算谈得来的凑合过了。可是你每天晚上梦见的，却不是睡在你身边的那个人。她不存在于这个世界上，她只存在于你的梦境里。</p><p style="margin:0px 0px 20px;padding:0px;">于是有一天你觉醒了，你决定要成为那貌似可望而不可即的上帝，为自己量身定做一个情人……</p>
程序语言与法律
<p style="margin:0px 0px 20px;padding:0px;">法律是一种非常类似程序的东西。法律的语言也很像程序语言。完美的法律应该像一个程序，把案例输入进去，它就会告诉你这件事是合法还是不合法，如果不合法该怎么弥补。当然，法律处理的事情比起程序处理的问题困难太多了，所以没有任何国家的法律可以达到以上的标准。但总而言之，我觉得像程序一样工作就是法律的精髓。</p><p style="margin:0px 0px 20px;padding:0px;">相对而言，有些国家的法律比起另外一些国家要好很多。美国就是这样一个所谓“法制健全”的国家。美国的法律条款都很详细，对每一个名词（变量名）都有精确的定义和“作用域”。每一个条件之下应该怎么办，都有详细的规定（条件语句）。所以法律条文一般都是大条小条的很长，而且所用语言为了严格而显得古怪，一般人不容易读完。但美国有大批经过严格训练的律师和警察，他们就像 CPU 一样，专门学习和执行这些条文。所以一旦有人被指控违法，很容易就能根据法律条款作出判断。如果有人犯法被捕，就算是再有钱的人，也没法绕过法律而不受惩罚。</p><p style="margin:0px 0px 20px;padding:0px;">美国所有的警察，就算交警都是身强力壮，荷枪实弹。对就算家庭暴力这种事情都是说一不二，严格无误，搜身，录口供，谁对谁错毫不含糊。美国法律执行的单位是个人，而不是家庭。中国人几乎都不明白这个道理，这就是为什么有些中国夫妇到美国之后打架，导致其中一方被驱逐出境。相比之下，中国的法律就是一个充满了 bug 和未定义变量的程序。如果遇到家庭纠纷，几乎没有人叫警察，叫来了也不过是做好好先生。哎呀，两口子打架，过一会儿就好了，叫什么警察。中国的法律空子太多，执法又不严，所以很多人钻法律的空子，让老百姓吃亏，甚至警察都腐败掉。</p><p style="margin:0px 0px 20px;padding:0px;">在美国你经常收到银行和商场之类的地方寄来的通知，说法律要求我们告诉你，我们的隐私政策变了。我们根据某商业法规第X条，可以跟以下范围的商家分享关于你的以下信息。说白了，就是说跟他们结盟的商家会得到你的地址之类的信息，方便往你的邮箱里寄广告。在你租房子之前，房东的租约里面都会附带一些公告，比如说，法律要求我们告诉你，我们的房子由于年代久远，有些公寓的大门（而不是内门）上的油漆里面还有 nn 浓度的铅。请参考以下网址了解铅对人体特别是婴幼儿的危害。</p><p style="margin:0px 0px 20px;padding:0px;">为什么银行，商场和房东要告诉你那些呢？不是因为他们好心，而是因为如果他们没有告诉你，一旦有人指控他们就麻烦了。法律不管你是多么有钱的公司，只要违反了法律条文，一律按条例处罚。有时候你会觉得这些东西麻烦，多此一举，然而等到你跟中国的情况相比，才会理解其中的好处。</p><p style="margin:0px 0px 20px;padding:0px;">程序语言也是一样。很多人觉得写类型是一件麻烦事，所以他们用动态语言。有些动态语言（比如 Ruby, JavaScript，PHP）在变量没有定义的时候居然也能输出结果而不当掉。这就有点像中国的法律，过于灵活和柔弱，结果导致错误不能及时被检测，检测到了了也很难找到具体在什么位置。</p>
程序语言与政治
<p style="margin:0px 0px 20px;padding:0px;">很多人都曾经妄想着所谓的“社会主义”和“共产主义”能拯救全人类，就像很多程序员都妄想着某一种最近流行的语言能够把他们从繁琐的编程工作里拯救出来一样。几十年前，所谓的“革命者”为了这些很酷很炫的名词，试图把从前的一切文化都焚毁掉。腐朽的资本主义！吃人的旧社会！这就像现在很多 Scala/Clojure/Go 的狂热分子对 Java 之类的语言充满了敌意，一提到这些语言心里就是火。腐朽的 Java，不思进取的 Lisp，Scala/Clojure/Go 就是你们的掘墓人！然而他们没有发现，那些他们试图完全抛弃的语言里面其实有科学合理之处。他们没有看到这些东西之所以存在于那些语言里，是经过了历史的经验教训。这些教训如果不被理解和吸取，当遇到同样的问题，这些新语言就会一样的堕落掉。</p><p style="margin:0px 0px 20px;padding:0px;">有些程序员妄想着 Clojure 和 Go 所谓的 “纯函数式数据结构”，“transactional memory”，“goroutine”等酷毙帅呆的新概念能够一劳永逸的解决并发计算的重重困难，妄想着 Scala 能够让面向对象和函数式编程完美的结合。可是他们没有看到的是人心的险恶，他们就像那些革命者和红卫兵一样，被别有企图的人利用了。在经过深入的研究之后，你会发现这些炫名词其实并不能解决并发计算的关键问题。并行计算之所以困难，是因为物理决定了信息通道的性质。信息只能是单向的，顺序的通过这些信道，而信道的通过速率是有限的。不管你用多么炫的新方式让信息通过它，都不会改变这个事实。所以这些新名词其实不能解决我们的关键问题，要想解决它只有依靠程序员自己的领悟和设计。这就像再先进的工具也不可能帮助你设计出马力翻倍的引擎一样，你必须自己动脑筋，做实验，就像爱迪生发明灯泡一样。</p></div></div></div></div></div></div></div></div><span style="color: rgb(2, 2, 2); font-size: 12px; line-height: 200%; text-align: center; clear: both; display: block; visibility: hidden; height: 0px; overflow: hidden;">.</span></div></div></div><br/></div>
</div></body></html> 