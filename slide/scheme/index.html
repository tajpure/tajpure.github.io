<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <meta 3="viewport" content="width=1024" />
    <meta 3="apple-mobile-web-app-capable" content="yes" />
    <title>小型编译器的实现及可视化研究</title>
    
    <meta 3="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com." />
    <meta 3="author" content="Bartek Szopka" />

    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />

    <link href="css/impress-demo.css" rel="stylesheet" />
    
    <link rel="shortcut icon" href="favicon.png" />
    <link rel="apple-touch-icon" href="apple-touch-icon.png" />
</head>
<body class="impress-not-supported">

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="bored" class="step slide" data-x="-1000" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br>
        <br>
        <q>小型编译器的实现及可视化研究</q>
        <br>
        <br>
        <div class="sub-title">
        <h3>陶佳轩</h3>
        </div>
        <br>
        <div class="sub-title">
        <h3>Email:tajpure@gmail.com</h3>
        </div>
    </div>

    <div class="step slide" data-x="0" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br><br>
        <p><strong>研究内容:</strong><br><div style="margin-left: 16%;">完成一个小型语言的编译系统，包括:</div></p>
        <ul class="slide-ul">
            <li>(1)  词法分析</li>
            <li>(2)  语法分析</li>
            <li>(3)  语义分析和中间代码生成</li>
            <li>(4)  目标代码生成</li>
            <li>(5)  该系统的可视化实现</li>
        </ul>
    </div>


    <div class="step slide" data-x="1000" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>以Scheme语言作为该课题要求的小型语言</strong></p><br>
        <p><strong>为什么要使用Scheme？</strong></p><br>
        <div style="margin-left: 2%;">Scheme是Lisp语言的一种方言，语言核心非常精简，是基于“S表达式”的语法。<br><br>
        例如：<div style="margin-left: 4%;">(+ 1 1) <br> (display "hello world")</div><br>所有操作符都放在表达式最前面，不需要考虑运算符优先级，将Scheme程序转换成抽象语法树（AST）非常轻松。</div>
    </div>

    <div class="step slide" data-x="1000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br><br>
        <p><strong>使用Scala来开发编译器</strong></p><br>
        <p><strong>为什么要使用Scala？</strong></p><br>
        <div style="margin-left: 2%;">(1) 拥有强大的面向对象特性，便于扩展和维护；</div><br>
        <div style="margin-left: 2%;">(2) 可以使用Java世界里海量的开源项目，节省精力；</div><br>
        <div style="margin-left: 2%;">(3) 包含优秀的函数式语言特性，远离Java繁冗的数据处理；</div>
    </div>

    <div class="step slide" data-x="0" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br><br>
        <p>使用<strong>LLVM</strong>作为编译器后端。</p><br>
        <p><strong>LLVM的简单介绍：</strong></p><br>
        <div style="margin-left: 2%;">Low Level Virtual Machine，是以C++编写而成构架编译器的框架系统。具体请查看：<a href="http://llvm.org/" target="_blank">http://llvm.org/</a></div><br>
        <p>由于在Scala中可以直接调用Java库，因此我直接使用jllvm来使用LLVM。</p><br>
        <div style="color: #DF0101; font-size: 25px;">注释：jllvm是一个开源的LLVM Bindings， 可以在基于JVM的语言里使用。地址：<a href="https://code.google.com/p/jllvm/" target="_blank">https://code.google.com/p/jllvm/</a></div>
    </div>

    <div class="step slide" data-x="-1000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>研究方案大概：</strong></p><br>
        <div style="margin-left: 2%;">(1) 词法分析：对scheme源码进行Tokenize，将其转成一个个词法单元；
        <image src="./checked.png" class="checked-image"></image></div><br>
        <div style="margin-left: 2%;">(2) 语法分析：使用自顶向下语法分析处理词法分析的输出；
        <image src="./checked.png" class="checked-image"></image></div><br>
        <div style="margin-left: 2%;">(3) 语法制导翻译：将生成的抽象语法树翻译成LLVM的IR码(供LLVM使用的中间码)；<div style="color: #40FF00; font-size: 25px;">(正在进行)</div></div><br>
        <div style="margin-left: 2%;">(4) LLVM用于目标代码生成，运行时环境等阶段；</div><br>
        <div style="margin-left: 2%;">(5) 将编译器各个处理阶段在图形界面上体现出来；</div>
    </div>

    <div class="step slide" data-x="-2000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法分析的状态转移图</strong></p><br>
        <image src="./lex01.png"></image>
        <div style="color: #DF0101; font-size: 25px;">以上可以清晰地看出词法分析器的结构.</div>
    </div>

    <div class="step slide" data-x="-2000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法单元的抽象父类的结构</strong></p><br>
        <div>Node:
            <pre style="font-size: 25px;">

  val file: String  // 用于标识该Node属于哪个文件
  val start: Int   // 该Node在文件中的起始位置
  val end: Int       // 结束位置
  val row: Int       // 所在行数
  val col: Int       // 所在列数

  def interp(s: Scope): Value // 用于解释器求值
  def typecheck(s: Scope): Value  // 用于类型检查
  def codegen(s: Scope): org.jllvm.value.Value  // 用于中间代码生成
            </pre>
        </div>
    </div>

    <div class="step slide" data-x="-1000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法分析示例</strong></p><br>
        <div>输入：
            <pre style="font-size: 25px;">
               (define double 
                (lambda (n) (+ n 2)))
            </pre>
            输出：
            <pre  style="font-size: 25px;">
                (=>delimeter define=>name double=>name 
                    (=>delimeter lambda=>name (=>delimeter n=>name )=>delimeter 
                        (=>delimeter +=>name n=>name 2=>int )=>delimeter 
                        )=>delimeter )=>delimeter 
            </pre>
        </div>
        <div style="color: #DF0101; font-size: 25px;">以上 <strong>Delimeter (界定符)，Name (具名量)，Int (整形)</strong>。源文件被解析成由一个个Node组成的列表,每个<strong>*=>*</strong>都是一个node.toString()的输出.</div>
    </div>

    <div class="step slide" data-x="0" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>语法分析</strong></p><br>
        <div style="margin-left: 2%;">
            <pre style="font-size: 25px;">语法分析是对前面的词法分析生成的Node列表进行如下处理：
            1，Literal (字面量) Node直接返回本身；
            例如：
            else if (curNode.isInstanceOf[IntNum]) {
              curNode.asInstanceOf[IntNum]
            }
            else if (curNode.isInstanceOf[FloatNum]) {
              curNode.asInstanceOf[FloatNum]
            }
            else if (curNode.isInstanceOf[Char]) {
              curNode.asInstanceOf[Char]
            }
            当前节点为字面量,则直接返回
            </pre>
        </div><br>
    </div>

    <div class="step slide" data-x="1000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p>
            <pre>
            2，Name (具名量) Node递归下降进行解析；
               例如：
                if (curNode.isInstanceOf[Name]) {
                  curNode.asInstanceOf[Name].id match {
                    case Constants.DEFINE => parseDefine(tuple)
                    case Constants.IF => parseIf(tuple)
                    case Constants.LET => parseAssign(tuple)
                    case Constants.LAMBDA => parseLambda(tuple)
                    case Constants.SEQ => parseBlock(tuple)
                    case default => parseCall(tuple)
                  }
                }
                会递归解析出相应的语法树
            <pre>
    目前的语法分析已经完成了变量定义，函数申明，闭包转换
    及函数调用。</p>
    </div>

    <div class="step slide" data-x="2000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br>
        <p><pre>下面是AST解释器对生成的AST进行解释的示例：
        
    <strong>正确示例：</strong>
    （1）乘2
        (define double (lambda (x) (* x 2))) 
        (display (double 2))
        输出：4
    （2）求倒数
        (define reciprocal (lambda (x) (/ 1 x))) 
        (display (reciprocal 2))
        输出：1/2
    <strong>错误示例：</strong>
        (define reciprocal (lambda (x) (/ 1 x))) (display (reciprocal 0))
        输出：row: 1 col: 32 Exception: incorrect arguments in 
        call '/'</pre></p><br>
        <div style="margin-left: 2%;">
            <pre>目前的语义分析加入了自动类型转换。例如：(+ 1 1.0) => 2.0
            </pre>
        </div>
    </div>

    <div class="step slide" data-x="1000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>LLVM IR的生成</strong></p><br>
        <div style="margin-left: 2%; font-size: 20px;">
            <pre>目前由Scheme生成的LLVM IR这一阶段还在进行中，
以下是几个在Scala里调用LLVM接口生成的IR示例：
    (1) getelementptr 测试
        ; ModuleID = 'test'
        %ee = type { i64, i32 }
        define i32 @fac(i32) {
        entry:
          %testHeapAllocation = alloca %ee
          %hell = getelementptr %ee* %testHeapAllocation, i32 0, i32 0
          store i32 2, i64* %hell
          %hell1 = load i64* %hell
          %hell2 = getelementptr %ee* %testHeapAllocation, i32 0, i32 0
          ret i64 %hell1
        }
    运行LLVM提供的Execution Engine得出的结果：2
            </pre>
        </div><br>
    </div>

    <div class="step slide" data-x="0" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>LLVM IR的生成(2)</strong></p>
        <div style="margin-left: 2%; font-size: 20px;">
            <pre>(2) switch 测试
        ; ModuleID = 'test'
        define i32 @fac(i32) {
        b:switch i32 2, label %b1 [
            i32 1, label %b3
            i32 2, label %b4
          ]
        b1:br label %b2                                            ; preds = %b
        b2:ret i32 1                                               ; preds = %b3, %b1
        b3:br label %b2                                            ; preds = %b
        b4:ret i32 2                                               ; preds = %b
        }
运行LLVM提供的Execution Engine得出的结果：2
            </pre>
        </div>
        <div style="color: #DF0101; font-size: 25px;">最后直接使用LLVM将生成的IR码转换成目标代码</div>
    </div>

    <div class="step slide" data-x="-1000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>接下来需要完成的工作：</strong></p>
        <p></p><br><br>
        <pre>
            (1)  完成通过使用LLVM将生成的IR码转换成目标代码的
                 部分

            (2)  实现编译器各个过程的可视化
        </pre><br><br>
    </div>
    <div id="its-in-3d" class="step" data-x="-1200" data-y="1300" data-z="-100" data-rotate-x="-40" data-rotate-y="10" data-scale="2">
        <h1>谢谢 ;)</h1>
    </div>

    <div id="overview" class="step" data-x="-500" data-y="0" data-scale="5">
    </div>

</div>

<script>
if ("ontouchstart" in document.documentElement) { 
    document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate</p>";
}
</script>

<script src="js/impress.js"></script>
<script>impress().init();</script>

</body>
</html>
