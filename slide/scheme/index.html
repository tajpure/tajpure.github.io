<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <meta 3="viewport" content="width=1024" />
    <meta 3="apple-mobile-web-app-capable" content="yes" />
    <title>小型编译器的实现及可视化研究</title>

    <meta 3="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com." />
    <meta 3="author" content="Bartek Szopka" />

    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />

    <link href="css/impress-demo.css" rel="stylesheet" />

    <link rel="shortcut icon" href="favicon.png" />
    <link rel="apple-touch-icon" href="apple-touch-icon.png" />
</head>
<body class="impress-not-supported">

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="bored" class="step slide" data-x="-1000" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br>
        <br>
        <q>小型编译器的实现及可视化研究</q>
        <br>
        <br>
        <div class="sub-title">
        <h3>班级：计科1103</h3>
        <h3>导师：丁丁</h3>
        <h3>姓名：陶佳轩</h3>
        </div>
    </div>

    <div class="step slide" data-x="0" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br><br>
        <p><strong>研究内容:</strong><br><div style="margin-left: 16%;">完成一个小型语言的编译系统，包括</div></p>
        <ul class="slide-ul">
            <li>(1)  词法分析</li>
            <li>(2)  语法分析</li>
            <li>(3)  语义分析和中间代码生成</li>
            <li>(4)  目标代码生成</li>
            <li>(5)  该系统的可视化实现</li>
        </ul>
    </div>


    <div class="step slide" data-x="1000" data-y="-1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>以Scheme语言作为该课题要求的小型语言</strong></p><br>
        <p><strong>为什么要使用Scheme？</strong></p><br>
        <div style="margin-left: 2%;">Scheme是Lisp语言的一种方言，语言核心非常精简，是基于“S表达式”的语法。<br><br>
        例如：<div style="margin-left: 4%;">(+ 1 1) <br> (display "hello world")</div><br>所有操作符都放在表达式最前面，不需要考虑运算符优先级，将Scheme程序转换成抽象语法树（AST）非常轻松。</div>
    </div>

    <div class="step slide" data-x="1000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br><br>
        <p><strong>使用Scala来开发编译器</strong></p><br>
        <p><strong>为什么要使用Scala？</strong></p><br>
        <div style="margin-left: 2%;">(1) 拥有强大的面向对象特性，便于扩展和维护；</div><br>
        <div style="margin-left: 2%;">(2) 可以使用Java世界里海量的开源项目，节省精力；</div><br>
        <div style="margin-left: 2%;">(3) 包含优秀的函数式语言特性，远离Java繁冗的数据处理；</div>
    </div>

    <div class="step slide" data-x="0" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p>使用<strong>LLVM</strong>作为编译器后端。</p><br>
        <p><strong>LLVM的简单介绍：</strong></p><br>
        <div style="margin-left: 2%;">Low Level Virtual Machine，是以C++编写而成构架编译器的框架系统。现下新型语言如Rust、Swift等均使用LLVM作为编译器后端。具体请查看：<a href="http://llvm.org/" target="_blank">http://llvm.org/</a></div><br>
        <p>由于在Scala中可以直接调用Java库，因此我直接使用jllvm来使用LLVM。</p><br>
        <div style="color: #DF0101; font-size: 25px;">注释：jllvm是一个开源的LLVM Bindings， 可以在基于JVM的语言里使用。地址：<a href="https://code.google.com/p/jllvm/" target="_blank">https://code.google.com/p/jllvm/</a></div>
    </div>

    <div class="step slide" data-x="-1000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>研究方案概述：</strong></p><br>
        <div style="margin-left: 2%;">(1) 词法分析：对scheme源码进行Tokenize，将其转成一个个词法单元；</div><br>
        <div style="margin-left: 2%;">(2) 语法分析：使用自顶向下语法分析处理词法分析的输出；</div><br>
        <div style="margin-left: 2%;">(3) 语法制导翻译：将生成的抽象语法树翻译成LLVM的IR码(供LLVM使用的中间码)；</div><br>
        <div style="margin-left: 2%;">(4) LLVM用于目标代码生成，运行时环境等阶段；</div><br>
        <div style="margin-left: 2%;">(5) 将编译器各个处理阶段的数据在图形界面上体现出来；</div>
    </div>

    <div class="step slide" data-x="-2000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法分析</strong></p><br>
        <div style="margin-left: 15%;">(1) 节点的结构；</div><br>
        <div style="margin-left: 15%;">(2) 词法单元的类型；</div><br>
        <div style="margin-left: 15%;">(3) 词法分析的状态转移图；</div><br>
        <div style="margin-left: 15%;">(4) 词法分析示例；</div><br>
    </div>

    <div class="step slide" data-x="-3000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>节点的结构</strong></p><br>
        <div>Node:
            <pre style="font-size: 25px;">

  val file: String  // 用于标识该Node属于哪个文件
  val start: Int   // 该Node在文件中的起始位置
  val end: Int       // 结束位置
  val row: Int       // 所在行数
  val col: Int       // 所在列数
  def interp(s: Scope): Value // 用于解释器求值
  def typecheck(s: Scope): Value  // 用于类型检查
  def codegen(s: Scope): org.jllvm.value.Value  // 用于中间代码生成
   <div style="color: #DF0101; font-size: 25px;">词法单元与语法单元均继承于该节点结构。</div>
            </pre>
        </div>
    </div>

    <div class="step slide" data-x="-4000" data-y="-500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法单元</strong></p><br>
        <div>
            <pre style="font-size: 25px;">
        1) Bool 布尔值，#t代表true,#f代表false
        2) CharNum 字符
        3) IntNum 整数
        4) FloatNum 浮点数
        5) String 字符串
        6) Symbol 符号，在Scheme里用来表示关键字、变量名或函数名。
        7) Delimiter 界定符，例如用于分割程序的括号，继承于Node。
        8) Quote 引用，使用quote或’标记的特殊词法单元。
           包含一个Node类型的成员变量，用来记录quote关键字标记的单元。
        </pre>
        </div>
        <div style="color: #DF0101; font-size: 25px;">以上词法单元均继承于Node，用于词法分析.</div>
    </div>

    <div class="step slide" data-x="-4000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法分析的状态转移图</strong></p><br>
        <image src="./lex01.png"></image>
        <div style="color: #DF0101; font-size: 25px;">以上可以清晰地看出词法分析器的结构.</div>
    </div>

    <div class="step slide" data-x="-3000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法分析示例</strong></p><br>
        <div>输入：
            <pre style="font-size: 25px;">
               (define main (lambda () (display "hello world!")))
            </pre>
            输出：
            <pre  style="font-size: 25px;">
               List((=>Delimeter, define=>Symbol, main=>Symbol, (=>Delimeter, 
               lambda=>Symbol, (=>Delimeter, )=>Delimeter, (=>Delimeter, 
               display=>Symbol, "hello world!"=>String, )=>Delimeter, 
               )=>Delimeter, )=>Delimeter)
            </pre>
        </div>
        <div style="color: #DF0101; font-size: 25px;">以上 <strong>Delimeter (界定符)，Symbol (具名量)，String (字符串)</strong>。源文件被解析成由词法单元组成的列表,<strong>“=>”</strong>之后是词法单元的类型.</div>
    </div>

    <div class="step slide" data-x="-2000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>语法分析</strong></p><br>
        <div>
            <pre style="font-size: 25px; margin-left: 20px;">
        1) 语法单元

        2) 语法分析示例

        2) 对AST(抽象语法树)进行解释示例
        </pre>
        </div>
    </div>

    <div class="step slide" data-x="-1000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>语法单元</strong></p><br>
        <div>
            <pre style="font-size: 25px;">
        1) Block  
            语句块，使用begin关键字标识。
        2) Tuple 
            元组，由括号括起来的节点列表，用于表示语句块或者函数
            参数等形式。
        3) Func 
            函数，包含参数、函数体和父级块的词法域。
        4) Call 函数调用，记录调用函数名和参数。
        5) Define 
            定义，用来定义变量或者函数。
        6) If If条件控制语句
        7) Let 过程绑定语句。
        </pre>
        </div>
        <div style="color: #DF0101; font-size: 25px;">以上词法单元均继承于Node，用于词法分析.</div>
    </div>

    <div class="step slide" data-x="0" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>语法分析示例</strong></p><br>
        <div style="margin-left: 2%;">
            <pre style="font-size: 25px;">语法分析是对前面的词法分析生成的Node列表进行如下处理：
            1，非语法单元节点直接返回本身；
            例如：
            else if (curNode.isInstanceOf[IntNum]) {
              curNode.asInstanceOf[IntNum]
            }
            else if (curNode.isInstanceOf[FloatNum]) {
              curNode.asInstanceOf[FloatNum]
            }
            else if (curNode.isInstanceOf[Char]) {
              curNode.asInstanceOf[Char]
            }
            当前节点为字面量,则直接返回
            </pre>
        </div><br>
    </div>

    <div class="step slide" data-x="1000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p>
            <pre>
    2，对语法单元节点递归下降进行解析；
        例如：
                if (curNode.isInstanceOf[Symbol]) {
                  curNode.asInstanceOf[Symbol].id match {
                    // 分别对应相应语法单元的解析方法
                    case Constants.DEFINE => parseDefine(tuple) 
                    case Constants.IF => parseIf(tuple)
                    case Constants.LET => parseAssign(tuple)
                    case Constants.LAMBDA => parseLambda(tuple)
                    case Constants.SEQ => parseBlock(tuple)
                    case default => parseCall(tuple)
                  }
                }
            <pre>
    语法分析会根据传入的词法单元列表生成相应的抽象语法树，
    这棵抽象语法树可以用来进行中间代码生成。</p>
    </div>

    <div class="step slide" data-x="2000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><pre>下面选取一个最简单的解析函数作为示例：

        def parseBlock(tuple: Tuple): Node = {
            val elements: List[Node] = tuple.elements
            val statements = parseList(elements.slice(1, elements.size))
            new Block(statements, tuple)
        }
        </pre></p><br>
        <div style="margin-left: 2%;">
            <pre>在进行语法解析时，编译器会将词法分析生成的词法单元列表
转成一个语法块形式。之后进行递归下降解析，上述示例为语
法块的解析示例，对Tuple元组里的元素进行遍历解析，最后将
其构造成一个Block语法单元输出。
            </pre>
        </div>
    </div>

    <div class="step slide" data-x="3000" data-y="500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br>
        <p><pre>    为了验证生成AST(抽象语法树)的正确性，下面是AST解释器
对生成的AST进行解释的示例：

    <strong>正确示例：</strong>
    （1）乘2
        (define double (lambda (x) (* x 2)))
        (display (double 2))
        输出：4
    （2）求倒数
        (define reciprocal (lambda (x) (/ 1 x)))
        (display (reciprocal 2))
        输出：1/2
    <strong>错误示例：</strong>
        (define reciprocal (lambda (x) (/ 1 x))) (display (reciprocal 0))
        输出：row: 1 col: 32 Exception: incorrect arguments in
        call '/'</pre></p><br>
    </div>

    <div class="step slide" data-x="3000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>语义分析说明</strong></p><br>
        <div style="margin-left: 2%; font-size: 20px;">
            <pre style="font-size:25px;">
            1) 语义分析和中间代码生成在同一阶段进行。

            2) 在进行中间代码生成时，会对抽象语法树进行语义分析。

            3) 这里的语义分析主要是基础运算符的参数类型进行验证，
               对于不满足条件的情况抛出异常。

            4) 基础运算符由内建函数实现，在编译器初始化时将内建
               函数存入顶级词法域，以便之后的调用。

            5) 基础运算符都有自己限定的值类型，如果值类型不满足
               基础运算符的要求，则抛出异常。
            </pre>
        </div><br>
    </div>

    <div class="step slide" data-x="2000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>中间代码生成</strong></p>
        <div style="margin-left: 2%; font-size: 25px;">
            <pre>
            1) 词法域的实现
               词法域即静态作用域。

            2) 实现codegen方法
               为每种节点实现相应的codegen方法，这个方法用
               来生成相应的中间代码形式。

            3) 调用codegen方法
                遍历调用抽象语法树节点的codegen方法，将结果输出
               至指定输出。
            </pre>
        </div>
    </div>

    <div class="step slide" data-x="1000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>词法域的实现</strong></p>
        <div style="margin-left: 2%; font-size: 25px;">
            <pre>

            这里使用Block语句块的codegen实现作为示例：
            def codegen(s: Scope): org.jllvm.value.Value = {
              val curScope: Scope = new Scope(s)
              s.setInnerScope(curScope)
              statements.map {
                node =>
                  node.codegen(curScope)
              }.last
            }
            </pre> 
        <div style="color: #DF0101; font-size: 25px;"></div>
        </div>
    </div>

    <div class="step slide" data-x="0" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>实现codegen方法示例</strong></p>
        <div style="margin-left: 2%; font-size: 25px;">
            <pre>

            这里使用Block语句块的codegen实现作为示例：
            def codegen(s: Scope): org.jllvm.value.Value = {
              val curScope: Scope = new Scope(s)
              s.setInnerScope(curScope)
              statements.map {
                node =>
                  node.codegen(curScope)
              }.last
            }
            </pre> 
        <div style="color: #DF0101; font-size: 25px;"></div>
        </div>
    </div>

    <div class="step slide" data-x="-1000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>调用codegen方法</strong></p>
        <div style="margin-left: 2%; font-size: 25px;">
            <pre>

            这里使用Block语句块的codegen实现作为示例：
            def codegen(s: Scope): org.jllvm.value.Value = {
              val curScope: Scope = new Scope(s)
              s.setInnerScope(curScope)
              statements.map {
                node =>
                  node.codegen(curScope)
              }.last
            }
            </pre> 
        <div style="color: #DF0101; font-size: 25px;"></div>
        </div>
    </div>

    <div class="step slide" data-x="-2000" data-y="1500">
        <div class="color-bar">
            <div class="color-bar-pink"></div>
            <div class="color-bar-orange"></div>
            <div class="color-bar-yellow"></div>
            <div class="color-bar-green"></div>
            <div class="color-bar-grey"></div>
        </div>
        <br><br>
        <p><strong>使用LLVM编译中间代码</strong></p>
        <div style="margin-left: 2%; font-size: 25px;">
            <pre>

            这里使用Block语句块的codegen实现作为示例：
            def codegen(s: Scope): org.jllvm.value.Value = {
              val curScope: Scope = new Scope(s)
              s.setInnerScope(curScope)
              statements.map {
                node =>
                  node.codegen(curScope)
              }.last
            }
            </pre> 
        <div style="color: #DF0101; font-size: 25px;"></div>
        </div>
    </div>



    <div id="its-in-3d" class="step" data-x="-1200" data-y="1300" data-z="-100" data-rotate-x="-40" data-rotate-y="10" data-scale="2">
        <h1>谢谢 ;)</h1>
    </div>

    <div id="overview" class="step" data-x="-500" data-y="0" data-scale="5">
    </div>

</div>

<script>
if ("ontouchstart" in document.documentElement) {
    document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate</p>";
}
</script>

<script src="js/impress.js"></script>
<script>impress().init();</script>

</body>
</html>
